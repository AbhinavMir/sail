(*Generated by Lem from gnu_extensions/gnu_ext_symbol_versioning.lem.*)
(** The [gnu_ext_symbol_versioning] defines constants, types and functions
  * relating to the GNU symbol versioning extensions (i.e. contents of
  * GNU_VERSYM sections).
  *
  * TODO: work out what is going on with symbol versioning.  The specification
  * is completely opaque.
  *)

open Lem_basic_classes
open Lem_bool
open Lem_list
open Lem_maybe
open Lem_num
open Lem_string

open Byte_sequence
open Endianness
open Error

open Elf_dynamic
open Elf_file
open Elf_header
open Elf_section_header_table
open Elf_symbol_table
open Elf_types_native_uint

open Missing_pervasives
open Show

open Gnu_ext_dynamic
open Gnu_ext_section_header_table

(** [gnu_ext_elf32_symbol_version_table] is an array (linked list, here) of
  * [elf32_half] entries.
  *)
type gnu_ext_elf32_symbol_version_table = Uint32.uint32
  list
  
type gnu_ext_elf64_symbol_version_table = Uint32.uint32
  list

(*val obtain_gnu_ext_elf32_symbol_version_table : elf32_file -> byte_sequence -> error gnu_ext_elf32_symbol_version_table*)
let obtain_gnu_ext_elf32_symbol_version_table f1 bs0:((Uint32.uint32)list)error=  
 (let sht = (f1.elf32_file_section_header_table) in
  let endian = (get_elf32_header_endianness f1.elf32_file_header) in
  let vers = (List.filter (fun ent ->
    ent.elf32_sh_type = Uint32.of_string (Nat_big_num.to_string sht_gnu_versym)
  ) sht)
  in
    (match vers with
      | []    -> return []
      | [ver] ->
        let off = (Nat_big_num.of_string (Uint32.to_string ver.elf32_sh_offset)) in
        let siz = (Nat_big_num.of_string (Uint32.to_string ver.elf32_sh_size)) in
        let lnk = (Nat_big_num.of_string (Uint32.to_string ver.elf32_sh_link)) in
        get_elf32_symbol_table_by_index f1 lnk >>= (fun symtab ->
        let dlen = (Nat_big_num.of_int (List.length symtab)) in
        Byte_sequence.offset_and_cut off siz bs0         >>= (fun ver      ->
        Error.repeatM' dlen bs0 (read_elf32_half endian) >>= (fun (ver, _) ->
        return ver)))
      | _     -> fail "obtain_gnu_ext_elf32_symbol_version_table: multiple sections of type .gnu_versym present in file"
    ))
 
(*val obtain_gnu_ext_elf64_symbol_version_table : endianness -> elf64_section_header_table -> elf64_symbol_table -> byte_sequence -> error gnu_ext_elf64_symbol_version_table*)
let obtain_gnu_ext_elf64_symbol_version_table endian sht dynsym bs0:((Uint32.uint32)list)error=  
 (let dlen = (Nat_big_num.of_int (List.length dynsym)) in
    if Nat_big_num.equal dlen(Nat_big_num.of_int 0) then
      return []
    else
      let vers = (List.filter (fun ent ->
          ent.elf64_sh_type = Uint32.of_string (Nat_big_num.to_string sht_gnu_versym)
        ) sht)
      in
        (match vers with
          | []    -> return []
          | [ver] ->
            let off = (Nat_big_num.of_string (Uint64.to_string ver.elf64_sh_offset)) in
            let siz = (Ml_bindings.nat_big_num_of_uint64 ver.elf64_sh_size) in
            Byte_sequence.offset_and_cut off siz bs0         >>= (fun ver      ->
            Error.repeatM' dlen bs0 (read_elf64_half endian) >>= (fun (ver, _) ->
            return ver))
          | _     -> fail "obtain_gnu_ext_elf64_symbol_version_table: multiple sections of type .gnu_versym present in file"
        ))
  
type gnu_ext_elf32_verdef =
  { gnu_ext_elf32_vd_version : Uint32.uint32
   ; gnu_ext_elf32_vd_flags   : Uint32.uint32
   ; gnu_ext_elf32_vd_ndx     : Uint32.uint32
   ; gnu_ext_elf32_vd_cnt     : Uint32.uint32
   ; gnu_ext_elf32_vd_hash    : Uint32.uint32
   ; gnu_ext_elf32_vd_aux     : Uint32.uint32
   ; gnu_ext_elf32_vd_next    : Uint32.uint32
   }
   
type gnu_ext_elf64_verdef =
  { gnu_ext_elf64_vd_version : Uint32.uint32
   ; gnu_ext_elf64_vd_flags   : Uint32.uint32
   ; gnu_ext_elf64_vd_ndx     : Uint32.uint32
   ; gnu_ext_elf64_vd_cnt     : Uint32.uint32
   ; gnu_ext_elf64_vd_hash    : Uint32.uint32
   ; gnu_ext_elf64_vd_aux     : Uint32.uint32
   ; gnu_ext_elf64_vd_next    : Uint32.uint32
   }
   
(*val string_of_gnu_ext_elf32_verdef : gnu_ext_elf32_verdef -> string*)
let string_of_gnu_ext_elf32_verdef verdef:string=  
 (unlines [    
("Version: " ^ Uint32.to_string verdef.gnu_ext_elf32_vd_version)
  ; ("Flags: " ^ Uint32.to_string verdef.gnu_ext_elf32_vd_flags)
  ; ("Index: " ^ Uint32.to_string verdef.gnu_ext_elf32_vd_ndx)
  ; ("Count: " ^ Uint32.to_string verdef.gnu_ext_elf32_vd_cnt)
  ; ("Hash: " ^ Uint32.to_string verdef.gnu_ext_elf32_vd_hash)
  ])
  
(*val string_of_gnu_ext_elf64_verdef : gnu_ext_elf64_verdef -> string*)
let string_of_gnu_ext_elf64_verdef verdef:string=  
 (unlines [    
("Version: " ^ Uint32.to_string verdef.gnu_ext_elf64_vd_version)
  ; ("Flags: " ^ Uint32.to_string verdef.gnu_ext_elf64_vd_flags)
  ; ("Index: " ^ Uint32.to_string verdef.gnu_ext_elf64_vd_ndx)
  ; ("Count: " ^ Uint32.to_string verdef.gnu_ext_elf64_vd_cnt)
  ; ("Hash: " ^ Uint32.to_string verdef.gnu_ext_elf64_vd_hash)
  ])
   
(*val read_gnu_ext_elf32_verdef : endianness -> byte_sequence -> error (gnu_ext_elf32_verdef * byte_sequence)*)
let read_gnu_ext_elf32_verdef endian bs0:(gnu_ext_elf32_verdef*byte_sequence)error=  
 (read_elf32_half endian bs0 >>= (fun (ver, bs0) ->
  read_elf32_half endian bs0 >>= (fun (flg, bs0) ->
  read_elf32_half endian bs0 >>= (fun (ndx, bs0) ->
  read_elf32_half endian bs0 >>= (fun (cnt, bs0) ->
  read_elf32_word endian bs0 >>= (fun (hsh, bs0) ->
  read_elf32_word endian bs0 >>= (fun (aux, bs0) ->
  read_elf32_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf32_vd_version = ver; gnu_ext_elf32_vd_flags = flg;
      gnu_ext_elf32_vd_ndx = ndx; gnu_ext_elf32_vd_cnt = cnt;
        gnu_ext_elf32_vd_hash = hsh; gnu_ext_elf32_vd_aux = aux;
      gnu_ext_elf32_vd_next = nxt }, bs0)))))))))
      
(*val read_gnu_ext_elf64_verdef : endianness -> byte_sequence -> error (gnu_ext_elf64_verdef * byte_sequence)*)
let read_gnu_ext_elf64_verdef endian bs0:(gnu_ext_elf64_verdef*byte_sequence)error=  
 (read_elf64_half endian bs0 >>= (fun (ver, bs0) ->
  read_elf64_half endian bs0 >>= (fun (flg, bs0) ->
  read_elf64_half endian bs0 >>= (fun (ndx, bs0) ->
  read_elf64_half endian bs0 >>= (fun (cnt, bs0) ->
  read_elf64_word endian bs0 >>= (fun (hsh, bs0) ->
  read_elf64_word endian bs0 >>= (fun (aux, bs0) ->
  read_elf64_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf64_vd_version = ver; gnu_ext_elf64_vd_flags = flg;
      gnu_ext_elf64_vd_ndx = ndx; gnu_ext_elf64_vd_cnt = cnt;
        gnu_ext_elf64_vd_hash = hsh; gnu_ext_elf64_vd_aux = aux;
      gnu_ext_elf64_vd_next = nxt }, bs0)))))))))
      
(*val gnu_ext_elf32_verdef_size : natural*)
let gnu_ext_elf32_verdef_size:Nat_big_num.num= (Nat_big_num.of_int 160)
  
(*val gnu_ext_elf64_verdef_size : natural*)
let gnu_ext_elf64_verdef_size:Nat_big_num.num= (Nat_big_num.of_int 256)
   
type gnu_ext_elf32_veraux =
  { gnu_ext_elf32_vda_name : Uint32.uint32
   ; gnu_ext_elf32_vda_next : Uint32.uint32
   }
   
type gnu_ext_elf64_veraux =
  { gnu_ext_elf64_vda_name : Uint32.uint32
   ; gnu_ext_elf64_vda_next : Uint32.uint32
   }
   
(*val gnu_ext_elf32_veraux_size : natural*)
let gnu_ext_elf32_veraux_size:Nat_big_num.num= (Nat_big_num.of_int 64)

(*val gnu_ext_elf64_veraux_size : natural*)
let gnu_ext_elf64_veraux_size:Nat_big_num.num= (Nat_big_num.of_int 128)
   
(*val read_gnu_ext_elf32_veraux : endianness -> byte_sequence -> error (gnu_ext_elf32_veraux * byte_sequence)*)
let read_gnu_ext_elf32_veraux endian bs0:(gnu_ext_elf32_veraux*byte_sequence)error=  
 (read_elf32_word endian bs0 >>= (fun (nme, bs0) ->
  read_elf32_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf32_vda_name = nme; gnu_ext_elf32_vda_next = nxt }, bs0))))
    
(*val read_gnu_ext_elf64_veraux : endianness -> byte_sequence -> error (gnu_ext_elf64_veraux * byte_sequence)*)
let read_gnu_ext_elf64_veraux endian bs0:(gnu_ext_elf64_veraux*byte_sequence)error=  
 (read_elf64_word endian bs0 >>= (fun (nme, bs0) ->
  read_elf64_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf64_vda_name = nme; gnu_ext_elf64_vda_next = nxt }, bs0))))
   
type gnu_ext_elf32_verneed =
  { gnu_ext_elf32_vn_version : Uint32.uint32
   ; gnu_ext_elf32_vn_cnt     : Uint32.uint32
   ; gnu_ext_elf32_vn_file    : Uint32.uint32
   ; gnu_ext_elf32_vn_aux     : Uint32.uint32
   ; gnu_ext_elf32_vn_next    : Uint32.uint32
   }
   
type gnu_ext_elf64_verneed =
  { gnu_ext_elf64_vn_version : Uint32.uint32
   ; gnu_ext_elf64_vn_cnt     : Uint32.uint32
   ; gnu_ext_elf64_vn_file    : Uint32.uint32
   ; gnu_ext_elf64_vn_aux     : Uint32.uint32
   ; gnu_ext_elf64_vn_next    : Uint32.uint32
   }
   
(*val gnu_ext_elf32_verneed_size : natural*)
let gnu_ext_elf32_verneed_size:Nat_big_num.num= (Nat_big_num.of_int 128)

(*val gnu_ext_elf64_verneed_size : natural*)
let gnu_ext_elf64_verneed_size:Nat_big_num.num= (Nat_big_num.of_int 224)
   
(*val read_gnu_ext_elf32_verneed : endianness -> byte_sequence -> error (gnu_ext_elf32_verneed * byte_sequence)*)
let read_gnu_ext_elf32_verneed endian bs0:(gnu_ext_elf32_verneed*byte_sequence)error=  
 (read_elf32_half endian bs0 >>= (fun (ver, bs0) ->
  read_elf32_half endian bs0 >>= (fun (cnt, bs0) ->
  read_elf32_word endian bs0 >>= (fun (fle, bs0) ->
  read_elf32_word endian bs0 >>= (fun (aux, bs0) ->
  read_elf32_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf32_vn_version = ver; gnu_ext_elf32_vn_cnt = cnt;
      gnu_ext_elf32_vn_file = fle; gnu_ext_elf32_vn_aux = aux;
        gnu_ext_elf32_vn_next = nxt }, bs0)))))))

(*val read_gnu_ext_elf64_verneed : endianness -> byte_sequence -> error (gnu_ext_elf64_verneed * byte_sequence)*)
let read_gnu_ext_elf64_verneed endian bs0:(gnu_ext_elf64_verneed*byte_sequence)error=  
 (read_elf64_half endian bs0 >>= (fun (ver, bs0) ->
  read_elf64_half endian bs0 >>= (fun (cnt, bs0) ->
  read_elf64_word endian bs0 >>= (fun (fle, bs0) ->
  read_elf64_word endian bs0 >>= (fun (aux, bs0) ->
  read_elf64_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf64_vn_version = ver; gnu_ext_elf64_vn_cnt = cnt;
      gnu_ext_elf64_vn_file = fle; gnu_ext_elf64_vn_aux = aux;
        gnu_ext_elf64_vn_next = nxt }, bs0)))))))
   
type gnu_ext_elf32_vernaux =
  { gnu_ext_elf32_vna_hash  : Uint32.uint32
   ; gnu_ext_elf32_vna_flags : Uint32.uint32
   ; gnu_ext_elf32_vna_other : Uint32.uint32
   ; gnu_ext_elf32_vna_name  : Uint32.uint32
   ; gnu_ext_elf32_vna_next  : Uint32.uint32
   }
   
type gnu_ext_elf64_vernaux =
  { gnu_ext_elf64_vna_hash  : Uint32.uint32
   ; gnu_ext_elf64_vna_flags : Uint32.uint32
   ; gnu_ext_elf64_vna_other : Uint32.uint32
   ; gnu_ext_elf64_vna_name  : Uint32.uint32
   ; gnu_ext_elf64_vna_next  : Uint32.uint32
   }
   
(*val string_of_gnu_ext_elf32_vernaux : gnu_ext_elf32_vernaux -> string*)
let string_of_gnu_ext_elf32_vernaux vernaux:string=  
 (unlines [    
("Hash: " ^ Uint32.to_string vernaux.gnu_ext_elf32_vna_hash)
  ; ("Flags: " ^ Uint32.to_string vernaux.gnu_ext_elf32_vna_flags)
  ; ("Other: " ^ Uint32.to_string vernaux.gnu_ext_elf32_vna_other)
  ; ("Name: " ^ Uint32.to_string vernaux.gnu_ext_elf32_vna_name)
  ; ("Next: " ^ Uint32.to_string vernaux.gnu_ext_elf32_vna_next)
  ])
  
(*val string_of_gnu_ext_elf64_vernaux : gnu_ext_elf64_vernaux -> string*)
let string_of_gnu_ext_elf64_vernaux vernaux:string=  
 (unlines [    
("Hash: " ^ Uint32.to_string vernaux.gnu_ext_elf64_vna_hash)
  ; ("Flags: " ^ Uint32.to_string vernaux.gnu_ext_elf64_vna_flags)
  ; ("Other: " ^ Uint32.to_string vernaux.gnu_ext_elf64_vna_other)
  ; ("Name: " ^ Uint32.to_string vernaux.gnu_ext_elf64_vna_name)
  ; ("Next: " ^ Uint32.to_string vernaux.gnu_ext_elf64_vna_next)
  ])
   
(*val gnu_ext_elf32_vernaux_size : natural*)
let gnu_ext_elf32_vernaux_size:Nat_big_num.num= (Nat_big_num.of_int 16)

(*val gnu_ext_elf64_vernaux_size : natural*)
let gnu_ext_elf64_vernaux_size:Nat_big_num.num= (Nat_big_num.of_int 224)
   
(*val read_gnu_ext_elf32_vernaux : endianness -> byte_sequence -> error (gnu_ext_elf32_vernaux * byte_sequence)*)
let read_gnu_ext_elf32_vernaux endian bs0:(gnu_ext_elf32_vernaux*byte_sequence)error=  
 (read_elf32_word endian bs0 >>= (fun (hsh, bs0) ->
  read_elf32_half endian bs0 >>= (fun (flg, bs0) ->
  read_elf32_half endian bs0 >>= (fun (otr, bs0) ->
  read_elf32_word endian bs0 >>= (fun (nme, bs0) ->
  read_elf32_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf32_vna_hash = hsh; gnu_ext_elf32_vna_flags = flg;
      gnu_ext_elf32_vna_other = otr; gnu_ext_elf32_vna_name = nme;
    gnu_ext_elf32_vna_next = nxt }, bs0)))))))

(*val read_gnu_ext_elf64_vernaux : endianness -> byte_sequence -> error (gnu_ext_elf64_vernaux * byte_sequence)*)
let read_gnu_ext_elf64_vernaux endian bs0:(gnu_ext_elf64_vernaux*byte_sequence)error=  
 (read_elf64_word endian bs0 >>= (fun (hsh, bs0) ->
  read_elf64_half endian bs0 >>= (fun (flg, bs0) ->
  read_elf64_half endian bs0 >>= (fun (otr, bs0) ->
  read_elf64_word endian bs0 >>= (fun (nme, bs0) ->
  read_elf64_word endian bs0 >>= (fun (nxt, bs0) ->
    return ({ gnu_ext_elf64_vna_hash = hsh; gnu_ext_elf64_vna_flags = flg;
      gnu_ext_elf64_vna_other = otr; gnu_ext_elf64_vna_name = nme;
    gnu_ext_elf64_vna_next = nxt }, bs0)))))))
