(*Generated by Lem from abis/power64/abi_power64_elf_header.lem.*)
(** [abi_power64_elf_header], Power64 ABI specific definitions related to the 
  * ELF file header.
  *)

open Lem_basic_classes
open Lem_bool
open Lem_list
open Lem_maybe
open Missing_pervasives

open Elf_header
open Elf_types_native_uint

open Endianness

(** [is_valid_abi_power64_machine_architecture m] checks whether the ELF header's
  * machine architecture is valid according to the ABI-specific specification.
  * Machine architecture must be Power64 (Section 4.1).
  *)
(*val is_valid_abi_power64_machine_architecture : nat -> bool*)
let is_valid_abi_power64_machine_architecture m:bool=  
 (m = Nat_big_num.to_int elf_ma_ppc64)

(** [is_valid_abi_power64_magic_number magic] checks whether the ELF header's
  * magic number is valid according to the ABI-specific specification.
  * File class must be 64-bit (Section 4.1)
  * Data encoding must be little or big endian and must match the data encoding
  * of the file. (Section 4.1)
  *)
(*val is_valid_abi_power64_magic_number : list unsigned_char -> endianness -> bool*)
let is_valid_abi_power64_magic_number magic endian:bool=  
 ((match Lem_list.list_index magic (Nat_big_num.to_int elf_ii_class) with
    | None  -> false
    | Some cls ->
      (match Lem_list.list_index magic (Nat_big_num.to_int elf_ii_data) with
        | None -> false
        | Some ed ->
          (match endian with
            | Little ->
                ( Nat_big_num.equal(Nat_big_num.of_string (Uint32.to_string cls)) elf_class_64) &&
                  ( Nat_big_num.equal(Nat_big_num.of_string (Uint32.to_string ed)) elf_data_2lsb)
            | Big    ->
                ( Nat_big_num.equal(Nat_big_num.of_string (Uint32.to_string cls)) elf_class_64) &&
                  ( Nat_big_num.equal(Nat_big_num.of_string (Uint32.to_string ed)) elf_data_2msb)
          )
      )
  ))
