(* generated by Ott 0.25 from: l2.ott *)


type text = string

type l = Parse_ast.l

type 'a annot = l * 'a


type x = text (* identifier *)
type ix = text (* infix identifier *)

type 
base_kind_aux =  (* base kind *)
   BK_type (* kind of types *)
 | BK_nat (* kind of natural number size expressions *)
 | BK_order (* kind of vector order specifications *)
 | BK_effect (* kind of effect sets *)


type 
kid_aux =  (* variables with kind, ticked to differntiate from program variables *)
   Var of x


type 
base_kind = 
   BK_aux of base_kind_aux * l


type 
kid = 
   Kid_aux of kid_aux * l


type 
kind_aux =  (* kinds *)
   K_kind of (base_kind) list


type 
nexp_aux =  (* expression of kind Nat, for vector sizes and origins *)
   Nexp_var of kid (* variable *)
 | Nexp_constant of int (* constant *)
 | Nexp_times of nexp * nexp (* product *)
 | Nexp_sum of nexp * nexp (* sum *)
 | Nexp_minus of nexp * nexp (* subtraction, error for nexp1 to be smaller than nexp2 *)
 | Nexp_exp of nexp (* exponential *)
 | Nexp_neg of nexp (* For internal use *)

and nexp = 
   Nexp_aux of nexp_aux * l


type 
kind = 
   K_aux of kind_aux * l


type 
base_effect_aux =  (* effect *)
   BE_rreg (* read register *)
 | BE_wreg (* write register *)
 | BE_rmem (* read memory *)
 | BE_wmem (* write memory *)
 | BE_barr (* memory barrier *)
 | BE_undef (* undefined-instruction exception *)
 | BE_unspec (* unspecified values *)
 | BE_nondet (* nondeterminism from intra-instruction parallelism *)


type 
base_effect = 
   BE_aux of base_effect_aux * l


type 
id_aux =  (* Identifier *)
   Id of x
 | DeIid of x (* remove infix status *)


type 
effect_aux =  (* effect set, of kind Effects *)
   Effect_var of kid
 | Effect_set of (base_effect) list (* effect set *)


type 
order_aux =  (* vector order specifications, of kind Order *)
   Ord_var of kid (* variable *)
 | Ord_inc (* increasing (little-endian) *)
 | Ord_dec (* decreasing (big-endian) *)


type 
id = 
   Id_aux of id_aux * l


type 
effect = 
   Effect_aux of effect_aux * l


type 
order = 
   Ord_aux of order_aux * l

(** pretty printer *)
let pp_x (y5:x) : string = y5

let pp_kid_aux (kid_aux5:kid_aux) : string =
  match kid_aux5 with
  | (Var x) -> " ' " ^ (pp_x x)


let pp_kid (kid5:kid) : string =
  match kid5 with
  | (Kid_aux (kid_aux,l)) -> (pp_kid_aux kid_aux) ^ " " ^ (pp_l l)


let pp_effect_aux (effect_aux5:effect_aux) : string =
  match effect_aux5 with
  | (Effect_var kid) -> (pp_kid kid)
  | (Effect_set (base_effect_list)) -> " { " ^ (String.concat "," (List.map (fun base_effect -> pp_base_effect base_effect) base_effect_list)) ^ " } "


let pp_id_aux (id_aux5:id_aux) : string =
  match id_aux5 with
  | (Id x) -> (pp_x x)
  | (DeIid x) -> " ( " ^ " deinfix " ^ (pp_x x) ^ " ) "


let pp_typquant_aux (typquant_aux5:typquant_aux) : string =
  match typquant_aux5 with
  | (TypQ_tq (quant_item_list)) -> " forall " ^ (String.concat "," (List.map (fun quant_item -> pp_quant_item quant_item) quant_item_list)) ^ " . "
  | TypQ_no_forall -> 


let pp_effect (effect5:effect) : string =
  match effect5 with
  | (Effect_aux (effect_aux,l)) -> (pp_effect_aux effect_aux) ^ " " ^ (pp_l l)


let pp_id (id5:id) : string =
  match id5 with
  | (Id_aux (id_aux,l)) -> (pp_id_aux id_aux) ^ " " ^ (pp_l l)


let pp_typquant (typquant5:typquant) : string =
  match typquant5 with
  | (TypQ_aux (typquant_aux,l)) -> (pp_typquant_aux typquant_aux) ^ " " ^ (pp_l l)


let rec pp_typ (typ5:typ) : string =
  match typ5 with
  | (Typ_aux (typ_aux,l)) -> (pp_typ_aux typ_aux) ^ " " ^ (pp_l l)
and
pp_typ_aux (typ_aux5:typ_aux) : string =
  match typ_aux5 with
  | Typ_wild -> " _ "
  | (Typ_id id) -> (pp_id id)
  | (Typ_var kid) -> (pp_kid kid)
  | (Typ_fn (typ1,typ2,effect)) -> (pp_typ typ1) ^ " -> " ^ (pp_typ typ2) ^ " effectkw " ^ (pp_effect effect)
  | (Typ_tup (typ_list)) -> " ( " ^ (String.concat "," (List.map (fun typ -> pp_typ typ) typ_list)) ^ " ) "
  | (Typ_app (id,(typ_arg_list))) -> (pp_id id) ^ " < " ^ (String.concat "," (List.map (fun typ_arg -> pp_typ_arg typ_arg) typ_arg_list)) ^ " > "


let pp_lit_aux (lit_aux5:lit_aux) : string =
  match lit_aux5 with
  | L_unit -> " ( " ^ " ) "
  | L_zero -> " bitzero "
  | L_one -> " bitone "
  | L_true -> " true "
  | L_false -> " false "
  | (L_num num) -> (pp_num num)
  | (L_hex hex) -> (pp_hex hex)
  | (L_bin bin) -> (pp_bin bin)
  | L_undef -> " undefined "
  | (L_string string) -> (pp_string string)


let pp_fexps_aux (fexps_aux5:fexps_aux) : string =
  match fexps_aux5 with
  | (FES_Fexps ((fexp_list),semi_opt)) -> (String.concat ";" (List.map (fun fexp -> pp_'a fexp fexp) fexp_list)) ^ " " ^ (pp_semi_opt semi_opt)


let pp_typschm_aux (typschm_aux5:typschm_aux) : string =
  match typschm_aux5 with
  | (TypSchm_ts (typquant,typ)) -> (pp_typquant typquant) ^ " " ^ (pp_typ typ)


let pp_lit (lit5:lit) : string =
  match lit5 with
  | (L_aux (lit_aux,l)) -> (pp_lit_aux lit_aux) ^ " " ^ (pp_l l)


let pp_order_aux (order_aux5:order_aux) : string =
  match order_aux5 with
  | (Ord_var kid) -> (pp_kid kid)
  | Ord_inc -> " inc "
  | Ord_dec -> " dec "


let pp_fexps (fexps5:fexps) : string =
  match fexps5 with
  | (FES_aux (fexps_aux,annot)) -> (pp_fexps_aux fexps_aux) ^ " " ^ (pp_annot annot)


let pp_typschm (typschm5:typschm) : string =
  match typschm5 with
  | (TypSchm_aux (typschm_aux,l)) -> (pp_typschm_aux typschm_aux) ^ " " ^ (pp_l l)


let rec pp_pat (pat5:pat) : string =
  match pat5 with
  | (P_aux (pat_aux,annot)) -> (pp_pat_aux pat_aux) ^ " " ^ (pp_annot annot)
and
pp_pat_aux (pat_aux5:pat_aux) : string =
  match pat_aux5 with
  | (P_lit lit) -> (pp_lit lit)
  | P_wild -> " _ "
  | (P_as (pat,id)) -> " ( " ^ (pp_pat pat) ^ " as " ^ (pp_id id) ^ " ) "
  | (P_typ (typ,pat)) -> " ( " ^ (pp_typ typ) ^ " ) " ^ (pp_pat pat)
  | (P_id id) -> (pp_id id)
  | (P_app (id,(pat_list))) -> (pp_id id) ^ " ( " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ) "
  | (P_record ((fpat_list),semi_opt)) -> " { " ^ (String.concat ";" (List.map (fun fpat -> pp_'a fpat fpat) fpat_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (P_vector (pat_list)) -> " [ " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ] "
  | (P_vector_indexed (num_pat_list)) -> " [ " ^ (String.concat "," (List.map (fun num,pat -> pp_int num,pp_'a pat pat) num_pat_list)) ^ " ] "
  | (P_vector_concat (pat_list)) -> (String.concat ":" (List.map (fun pat -> pp_'a pat pat) pat_list))
  | (P_tup (pat_list)) -> " ( " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ) "
  | (P_list (pat_list)) -> " [|| " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ||] "


let pp_order (order5:order) : string =
  match order5 with
  | (Ord_aux (order_aux,l)) -> (pp_order_aux order_aux) ^ " " ^ (pp_l l)


let pp_reg_id_aux (reg_id_aux5:reg_id_aux) : string =
  match reg_id_aux5 with
  | (RI_id id) -> (pp_id id)


let pp_kind_aux (kind_aux5:kind_aux) : string =
  match kind_aux5 with
  | (K_kind (base_kind_list)) -> (String.concat "->" (List.map (fun base_kind -> pp_base_kind base_kind) base_kind_list))


let rec pp_letbind (letbind5:letbind) : string =
  match letbind5 with
  | (LB_aux (letbind_aux,annot)) -> (pp_letbind_aux letbind_aux) ^ " " ^ (pp_annot annot)
and
pp_letbind_aux (letbind_aux5:letbind_aux) : string =
  match letbind_aux5 with
  | (LB_val_explicit (typschm,pat,exp)) -> " let " ^ (pp_typschm typschm) ^ " " ^ (pp_pat pat) ^ " = " ^ (pp_exp exp)
  | (LB_val_implicit (pat,exp)) -> " let " ^ (pp_pat pat) ^ " = " ^ (pp_exp exp)
and
pp_opt_default (opt_default5:opt_default) : string =
  match opt_default5 with
  | (Def_val_aux (opt_default_aux,annot)) -> (pp_opt_default_aux opt_default_aux) ^ " " ^ (pp_annot annot)
and
pp_opt_default_aux (opt_default_aux5:opt_default_aux) : string =
  match opt_default_aux5 with
  | Def_val_empty -> 
  | (Def_val_dec exp) -> " ; " ^ " default " ^ " = " ^ (pp_exp exp)
and
pp_lexp (lexp5:lexp) : string =
  match lexp5 with
  | (LEXP_aux (lexp_aux,annot)) -> (pp_lexp_aux lexp_aux) ^ " " ^ (pp_annot annot)
and
pp_lexp_aux (lexp_aux5:lexp_aux) : string =
  match lexp_aux5 with
  | (LEXP_id id) -> (pp_id id)
  | (LEXP_memory (id,(exp_list))) -> (pp_id id) ^ " ( " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ) "
  | (LEXP_cast (typ,id)) -> " ( " ^ (pp_typ typ) ^ " ) " ^ (pp_id id)
  | (LEXP_vector (lexp,exp)) -> (pp_lexp lexp) ^ " [ " ^ (pp_exp exp) ^ " ] "
  | (LEXP_vector_range (lexp,exp1,exp2)) -> (pp_lexp lexp) ^ " [ " ^ (pp_exp exp1) ^ " .. " ^ (pp_exp exp2) ^ " ] "
  | (LEXP_field (lexp,id)) -> (pp_lexp lexp) ^ " . " ^ (pp_id id)
and
pp_exp (exp5:exp) : string =
  match exp5 with
  | (E_aux (exp_aux,annot)) -> (pp_exp_aux exp_aux) ^ " " ^ (pp_annot annot)
and
pp_exp_aux (exp_aux5:exp_aux) : string =
  match exp_aux5 with
  | (E_block (exp_list)) -> " { " ^ (String.concat ";" (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " } "
  | (E_nondet (exp_list)) -> " nondet " ^ " { " ^ (String.concat ";" (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " } "
  | (E_id id) -> (pp_id id)
  | (E_lit lit) -> (pp_lit lit)
  | (E_cast (typ,exp)) -> " ( " ^ (pp_typ typ) ^ " ) " ^ (pp_exp exp)
  | (E_app (id,(exp_list))) -> (pp_id id) ^ " ( " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ) "
  | (E_app_infix (exp1,id,exp2)) -> (pp_exp exp1) ^ " " ^ (pp_id id) ^ " " ^ (pp_exp exp2)
  | (E_tuple (exp_list)) -> " ( " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ) "
  | (E_if (exp1,exp2,exp3)) -> " if " ^ (pp_exp exp1) ^ " then " ^ (pp_exp exp2) ^ " else " ^ (pp_exp exp3)
  | (E_for (id,exp1,exp2,exp3,order,exp4)) -> " foreach " ^ " ( " ^ (pp_id id) ^ " from " ^ (pp_exp exp1) ^ " to " ^ (pp_exp exp2) ^ " by " ^ (pp_exp exp3) ^ " in " ^ (pp_order order) ^ " ) " ^ (pp_exp exp4)
  | (E_vector (exp_list)) -> " [ " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ] "
  | (E_vector_indexed ((num_exp_list),opt_default)) -> " [ " ^ (String.concat "," (List.map (fun num,exp -> pp_int num,pp_'a exp exp) num_exp_list)) ^ " " ^ (pp_opt_default opt_default) ^ " ] "
  | (E_vector_access (exp,exp')) -> (pp_exp exp) ^ " [ " ^ (pp_exp exp') ^ " ] "
  | (E_vector_subrange (exp,exp1,exp2)) -> (pp_exp exp) ^ " [ " ^ (pp_exp exp1) ^ " .. " ^ (pp_exp exp2) ^ " ] "
  | (E_vector_update (exp,exp1,exp2)) -> " [ " ^ (pp_exp exp) ^ " with " ^ (pp_exp exp1) ^ " = " ^ (pp_exp exp2) ^ " ] "
  | (E_vector_update_subrange (exp,exp1,exp2,exp3)) -> " [ " ^ (pp_exp exp) ^ " with " ^ (pp_exp exp1) ^ " : " ^ (pp_exp exp2) ^ " = " ^ (pp_exp exp3) ^ " ] "
  | (E_vector_append (exp,exp2)) -> (pp_exp exp) ^ " : " ^ (pp_exp exp2)
  | (E_list (exp_list)) -> " [|| " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ||] "
  | (E_cons (exp1,exp2)) -> (pp_exp exp1) ^ " :: " ^ (pp_exp exp2)
  | (E_record fexps) -> " { " ^ (pp_fexps fexps) ^ " } "
  | (E_record_update (exp,fexps)) -> " { " ^ (pp_exp exp) ^ " with " ^ (pp_fexps fexps) ^ " } "
  | (E_field (exp,id)) -> (pp_exp exp) ^ " . " ^ (pp_id id)
  | (E_case (exp,(pexp_list))) -> " switch " ^ (pp_exp exp) ^ " { " ^ (String.concat " " (List.map (fun pexp -> pp_'a pexp pexp) pexp_list)) ^ " } "
  | (E_let (letbind,exp)) -> (pp_letbind letbind) ^ " in " ^ (pp_exp exp)
  | (E_assign (lexp,exp)) -> (pp_lexp lexp) ^ " := " ^ (pp_exp exp)
  | (E_exit exp) -> " exit " ^ (pp_exp exp)
  | (E_internal_cast (annot,exp)) -> " ( " ^ (pp_annot annot) ^ " ) " ^ (pp_exp exp)
  | (E_internal_exp annot) -> (pp_annot annot)
  | (E_internal_exp_user (annot,annot')) -> (pp_annot annot) ^ " , " ^ (pp_annot annot')


let pp_reg_id (reg_id5:reg_id) : string =
  match reg_id5 with
  | (RI_aux (reg_id_aux,annot)) -> (pp_reg_id_aux reg_id_aux) ^ " " ^ (pp_annot annot)


let rec pp_nexp (nexp5:nexp) : string =
  match nexp5 with
  | (Nexp_aux (nexp_aux,l)) -> (pp_nexp_aux nexp_aux) ^ " " ^ (pp_l l)
and
pp_nexp_aux (nexp_aux5:nexp_aux) : string =
  match nexp_aux5 with
  | (Nexp_var kid) -> (pp_kid kid)
  | (Nexp_constant num) -> (pp_num num)
  | (Nexp_times (nexp1,nexp2)) -> (pp_nexp nexp1) ^ " * " ^ (pp_nexp nexp2)
  | (Nexp_sum (nexp1,nexp2)) -> (pp_nexp nexp1) ^ " + " ^ (pp_nexp nexp2)
  | (Nexp_minus (nexp1,nexp2)) -> (pp_nexp nexp1) ^ " - " ^ (pp_nexp nexp2)
  | (Nexp_exp nexp) -> " 2** " ^ (pp_nexp nexp)
  | (Nexp_neg nexp) -> " neg " ^ (pp_nexp nexp)


let pp_kind (kind5:kind) : string =
  match kind5 with
  | (K_aux (kind_aux,l)) -> (pp_kind_aux kind_aux) ^ " " ^ (pp_l l)


let pp_type_union_aux (type_union_aux5:type_union_aux) : string =
  match type_union_aux5 with
  | (Tu_id id) -> (pp_id id)
  | (Tu_ty_id (typ,id)) -> (pp_typ typ) ^ " " ^ (pp_id id)


let pp_effect_opt_aux (effect_opt_aux5:effect_opt_aux) : string =
  match effect_opt_aux5 with
  | Effect_opt_pure -> 
  | (Effect_opt_effect effect) -> " effectkw " ^ (pp_effect effect)


let pp_name_scm_opt_aux (name_scm_opt_aux5:name_scm_opt_aux) : string =
  match name_scm_opt_aux5 with
  | Name_sect_none -> 
  | (Name_sect_some regexp) -> " [ " ^ " name " ^ " = " ^ (pp_regexp regexp) ^ " ] "


let pp_funcl_aux (funcl_aux5:funcl_aux) : string =
  match funcl_aux5 with
  | (FCL_Funcl (id,pat,exp)) -> (pp_id id) ^ " " ^ (pp_pat pat) ^ " = " ^ (pp_exp exp)


let pp_rec_opt_aux (rec_opt_aux5:rec_opt_aux) : string =
  match rec_opt_aux5 with
  | Rec_nonrec -> 
  | Rec_rec -> " rec "


let pp_tannot_opt_aux (tannot_opt_aux5:tannot_opt_aux) : string =
  match tannot_opt_aux5 with
  | (Typ_annot_opt_some (typquant,typ)) -> (pp_typquant typquant) ^ " " ^ (pp_typ typ)


let pp_alias_spec_aux (alias_spec_aux5:alias_spec_aux) : string =
  match alias_spec_aux5 with
  | (AL_subreg (reg_id,id)) -> (pp_reg_id reg_id) ^ " . " ^ (pp_id id)
  | (AL_bit (reg_id,exp)) -> (pp_reg_id reg_id) ^ " [ " ^ (pp_exp exp) ^ " ] "
  | (AL_slice (reg_id,exp,exp')) -> (pp_reg_id reg_id) ^ " [ " ^ (pp_exp exp) ^ " .. " ^ (pp_exp exp') ^ " ] "
  | (AL_concat (reg_id,reg_id')) -> (pp_reg_id reg_id) ^ " : " ^ (pp_reg_id reg_id')


let pp_base_kind_aux (base_kind_aux5:base_kind_aux) : string =
  match base_kind_aux5 with
  | BK_type -> " Type "
  | BK_nat -> " Nat "
  | BK_order -> " Order "
  | BK_effect -> " Effect "


let pp_n_constraint_aux (n_constraint_aux5:n_constraint_aux) : string =
  match n_constraint_aux5 with
  | (NC_fixed (nexp,nexp')) -> (pp_nexp nexp) ^ " = " ^ (pp_nexp nexp')
  | (NC_bounded_ge (nexp,nexp')) -> (pp_nexp nexp) ^ " >= " ^ (pp_nexp nexp')
  | (NC_bounded_le (nexp,nexp')) -> (pp_nexp nexp) ^ " <= " ^ (pp_nexp nexp')
  | (NC_nat_set_bounded (kid,(num_list))) -> (pp_kid kid) ^ " IN " ^ " { " ^ (String.concat "," (List.map (fun num -> pp_int num) num_list)) ^ " } "


let pp_kinded_id_aux (kinded_id_aux5:kinded_id_aux) : string =
  match kinded_id_aux5 with
  | (KOpt_none kid) -> (pp_kid kid)
  | (KOpt_kind (kind,kid)) -> (pp_kind kind) ^ " " ^ (pp_kid kid)


let pp_type_union (type_union5:type_union) : string =
  match type_union5 with
  | (Tu_aux (type_union_aux,l)) -> (pp_type_union_aux type_union_aux) ^ " " ^ (pp_l l)


let pp_effect_opt (effect_opt5:effect_opt) : string =
  match effect_opt5 with
  | (Effect_opt_aux (effect_opt_aux,l)) -> (pp_effect_opt_aux effect_opt_aux) ^ " " ^ (pp_l l)


let pp_name_scm_opt (name_scm_opt5:name_scm_opt) : string =
  match name_scm_opt5 with
  | (Name_sect_aux (name_scm_opt_aux,l)) -> (pp_name_scm_opt_aux name_scm_opt_aux) ^ " " ^ (pp_l l)


let pp_funcl (funcl5:funcl) : string =
  match funcl5 with
  | (FCL_aux (funcl_aux,annot)) -> (pp_funcl_aux funcl_aux) ^ " " ^ (pp_annot annot)


let pp_rec_opt (rec_opt5:rec_opt) : string =
  match rec_opt5 with
  | (Rec_aux (rec_opt_aux,l)) -> (pp_rec_opt_aux rec_opt_aux) ^ " " ^ (pp_l l)


let pp_tannot_opt (tannot_opt5:tannot_opt) : string =
  match tannot_opt5 with
  | (Typ_annot_opt_aux (tannot_opt_aux,l)) -> (pp_tannot_opt_aux tannot_opt_aux) ^ " " ^ (pp_l l)


let pp_alias_spec (alias_spec5:alias_spec) : string =
  match alias_spec5 with
  | (AL_aux (alias_spec_aux,annot)) -> (pp_alias_spec_aux alias_spec_aux) ^ " " ^ (pp_annot annot)


let pp_base_kind (base_kind5:base_kind) : string =
  match base_kind5 with
  | (BK_aux (base_kind_aux,l)) -> (pp_base_kind_aux base_kind_aux) ^ " " ^ (pp_l l)


let pp_n_constraint (n_constraint5:n_constraint) : string =
  match n_constraint5 with
  | (NC_aux (n_constraint_aux,l)) -> (pp_n_constraint_aux n_constraint_aux) ^ " " ^ (pp_l l)


let pp_kinded_id (kinded_id5:kinded_id) : string =
  match kinded_id5 with
  | (KOpt_aux (kinded_id_aux,l)) -> (pp_kinded_id_aux kinded_id_aux) ^ " " ^ (pp_l l)


let pp_scattered_def_aux (scattered_def_aux5:scattered_def_aux) : string =
  match scattered_def_aux5 with
  | (SD_scattered_function (rec_opt,tannot_opt,effect_opt,id)) -> " scattered " ^ " function " ^ (pp_rec_opt rec_opt) ^ " " ^ (pp_tannot_opt tannot_opt) ^ " " ^ (pp_effect_opt effect_opt) ^ " " ^ (pp_id id)
  | (SD_scattered_funcl funcl) -> " function " ^ " clause " ^ (pp_funcl funcl)
  | (SD_scattered_variant (id,name_scm_opt,typquant)) -> " scattered " ^ " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " const " ^ " union " ^ (pp_typquant typquant)
  | (SD_scattered_unioncl (id,type_union)) -> " union " ^ (pp_id id) ^ " member " ^ (pp_type_union type_union)
  | (SD_scattered_end id) -> " end " ^ (pp_id id)


let pp_type_def_aux (type_def_aux5:type_def_aux) : string =
  match type_def_aux5 with
  | (TD_abbrev (id,name_scm_opt,typschm)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ (pp_typschm typschm)
  | (TD_record (id,name_scm_opt,typquant,(typ_id_list),semi_opt)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " const " ^ " struct " ^ (pp_typquant typquant) ^ " { " ^ (String.concat ";" (List.map (fun typ,id -> pp_typ typ;pp_id id) typ_id_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (TD_variant (id,name_scm_opt,typquant,(type_union_list),semi_opt)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " const " ^ " union " ^ (pp_typquant typquant) ^ " { " ^ (String.concat ";" (List.map (fun type_union -> pp_type_union type_union) type_union_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (TD_enum (id,name_scm_opt,(id_list),semi_opt)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " enumerate " ^ " { " ^ (String.concat ";" (List.map (fun id -> pp_id id) id_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (TD_register (id,nexp,nexp',(index_range_id_list))) -> " typedef " ^ (pp_id id) ^ " = " ^ " register " ^ " bits " ^ " [ " ^ (pp_nexp nexp) ^ " : " ^ (pp_nexp nexp') ^ " ] " ^ " { " ^ (String.concat ";" (List.map (fun index_range,id -> pp_index_range index_range;pp_id id) index_range_id_list)) ^ " } "


let pp_fundef_aux (fundef_aux5:fundef_aux) : string =
  match fundef_aux5 with
  | (FD_function (rec_opt,tannot_opt,effect_opt,(funcl_list))) -> " function " ^ (pp_rec_opt rec_opt) ^ " " ^ (pp_tannot_opt tannot_opt) ^ " " ^ (pp_effect_opt effect_opt) ^ (String.concat "and" (List.map (fun funcl -> pp_'a funcl funcl) funcl_list))


let pp_val_spec_aux (val_spec_aux5:val_spec_aux) : string =
  match val_spec_aux5 with
  | (VS_val_spec (typschm,id)) -> " val " ^ (pp_typschm typschm) ^ " " ^ (pp_id id)
  | (VS_extern_no_rename (typschm,id)) -> " val " ^ " extern " ^ (pp_typschm typschm) ^ " " ^ (pp_id id)
  | (VS_extern_spec (typschm,id,string)) -> " val " ^ " extern " ^ (pp_typschm typschm) ^ " " ^ (pp_id id) ^ " = " ^ (pp_string string)


let pp_dec_spec_aux (dec_spec_aux5:dec_spec_aux) : string =
  match dec_spec_aux5 with
  | (DEC_reg (typ,id)) -> " register " ^ (pp_typ typ) ^ " " ^ (pp_id id)
  | (DEC_alias (id,alias_spec)) -> " register " ^ " alias " ^ (pp_id id) ^ " = " ^ (pp_alias_spec alias_spec)
  | (DEC_typ_alias (typ,id,alias_spec)) -> " register " ^ " alias " ^ (pp_typ typ) ^ " " ^ (pp_id id) ^ " = " ^ (pp_alias_spec alias_spec)


let pp_default_spec_aux (default_spec_aux5:default_spec_aux) : string =
  match default_spec_aux5 with
  | (DT_kind (base_kind,kid)) -> " default " ^ (pp_base_kind base_kind) ^ " " ^ (pp_kid kid)
  | (DT_order order) -> " default " ^ " Order " ^ (pp_order order)
  | (DT_typ (typschm,id)) -> " default " ^ (pp_typschm typschm) ^ " " ^ (pp_id id)


let pp_base_effect_aux (base_effect_aux5:base_effect_aux) : string =
  match base_effect_aux5 with
  | BE_rreg -> " rreg "
  | BE_wreg -> " wreg "
  | BE_rmem -> " rmem "
  | BE_wmem -> " wmem "
  | BE_barr -> " barr "
  | BE_undef -> " undef "
  | BE_unspec -> " unspec "
  | BE_nondet -> " nondet "


let pp_quant_item_aux (quant_item_aux5:quant_item_aux) : string =
  match quant_item_aux5 with
  | (QI_id kinded_id) -> (pp_kinded_id kinded_id)
  | (QI_const n_constraint) -> (pp_n_constraint n_constraint)


let pp_fexp_aux (fexp_aux5:fexp_aux) : string =
  match fexp_aux5 with
  | (FE_Fexp (id,exp)) -> (pp_id id) ^ " = " ^ (pp_exp exp)


let pp_fpat_aux (fpat_aux5:fpat_aux) : string =
  match fpat_aux5 with
  | (FP_Fpat (id,pat)) -> (pp_id id) ^ " = " ^ (pp_pat pat)


let pp_scattered_def (scattered_def5:scattered_def) : string =
  match scattered_def5 with
  | (SD_aux (scattered_def_aux,annot)) -> (pp_scattered_def_aux scattered_def_aux) ^ " " ^ (pp_annot annot)


let pp_type_def (type_def5:type_def) : string =
  match type_def5 with
  | (TD_aux (type_def_aux,annot)) -> (pp_type_def_aux type_def_aux) ^ " " ^ (pp_annot annot)


let pp_fundef (fundef5:fundef) : string =
  match fundef5 with
  | (FD_aux (fundef_aux,annot)) -> (pp_fundef_aux fundef_aux) ^ " " ^ (pp_annot annot)


let pp_val_spec (val_spec5:val_spec) : string =
  match val_spec5 with
  | (VS_aux (val_spec_aux,annot)) -> (pp_val_spec_aux val_spec_aux) ^ " " ^ (pp_annot annot)


let pp_dec_spec (dec_spec5:dec_spec) : string =
  match dec_spec5 with
  | (DEC_aux (dec_spec_aux,annot)) -> (pp_dec_spec_aux dec_spec_aux) ^ " " ^ (pp_annot annot)


let pp_default_spec (default_spec5:default_spec) : string =
  match default_spec5 with
  | (DT_aux (default_spec_aux,l)) -> (pp_default_spec_aux default_spec_aux) ^ " " ^ (pp_l l)


let pp_pexp_aux (pexp_aux5:pexp_aux) : string =
  match pexp_aux5 with
  | (Pat_exp (pat,exp)) -> (pp_pat pat) ^ " -> " ^ (pp_exp exp)


let pp_typ_arg_aux (typ_arg_aux5:typ_arg_aux) : string =
  match typ_arg_aux5 with
  | (Typ_arg_nexp nexp) -> (pp_nexp nexp)
  | (Typ_arg_typ typ) -> (pp_typ typ)
  | (Typ_arg_order order) -> (pp_order order)
  | (Typ_arg_effect effect) -> (pp_effect effect)


let pp_ix (ix5:ix) : string = ix5

let pp_base_effect (base_effect5:base_effect) : string =
  match base_effect5 with
  | (BE_aux (base_effect_aux,l)) -> (pp_base_effect_aux base_effect_aux) ^ " " ^ (pp_l l)


let pp_quant_item (quant_item5:quant_item) : string =
  match quant_item5 with
  | (QI_aux (quant_item_aux,l)) -> (pp_quant_item_aux quant_item_aux) ^ " " ^ (pp_l l)


let pp_fexp (fexp5:fexp) : string =
  match fexp5 with
  | (FE_aux (fexp_aux,annot)) -> (pp_fexp_aux fexp_aux) ^ " " ^ (pp_annot annot)


let pp_fpat (fpat5:fpat) : string =
  match fpat5 with
  | (FP_aux (fpat_aux,annot)) -> (pp_fpat_aux fpat_aux) ^ " " ^ (pp_annot annot)


let pp_defs (defs5:defs) : string =
  match defs5 with
  | (Defs (def_list)) -> (String.concat " " (List.map (fun def -> pp_'a def def) def_list))


let pp_def (def5:def) : string =
  match def5 with
  | (DEF_type type_def) -> (pp_type_def type_def)
  | (DEF_fundef fundef) -> (pp_fundef fundef)
  | (DEF_val letbind) -> (pp_letbind letbind)
  | (DEF_spec val_spec) -> (pp_val_spec val_spec)
  | (DEF_default default_spec) -> (pp_default_spec default_spec)
  | (DEF_scattered scattered_def) -> (pp_scattered_def scattered_def)
  | (DEF_reg_dec dec_spec) -> (pp_dec_spec dec_spec)


let pp_pexp (pexp5:pexp) : string =
  match pexp5 with
  | (Pat_aux (pexp_aux,annot)) -> (pp_pexp_aux pexp_aux) ^ " " ^ (pp_annot annot)


let pp_typ_arg (typ_arg5:typ_arg) : string =
  match typ_arg5 with
  | (Typ_arg_aux (typ_arg_aux,l)) -> (pp_typ_arg_aux typ_arg_aux) ^ " " ^ (pp_l l)


let rec pp_index_range (index_range5:index_range) : string =
  match index_range5 with
  | (BF_aux (index_range_aux,l)) -> (pp_index_range_aux index_range_aux) ^ " " ^ (pp_l l)
and
pp_index_range_aux (index_range_aux5:index_range_aux) : string =
  match index_range_aux5 with
  | (BF_single num) -> (pp_num num)
  | (BF_range (num1,num2)) -> (pp_num num1) ^ " .. " ^ (pp_num num2)
  | (BF_concat (index_range1,index_range2)) -> (pp_index_range index_range1) ^ " , " ^ (pp_index_range index_range2)



type 
n_constraint_aux =  (* constraint over kind $_$ *)
   NC_fixed of nexp * nexp
 | NC_bounded_ge of nexp * nexp
 | NC_bounded_le of nexp * nexp
 | NC_nat_set_bounded of kid * (int) list


type 
kinded_id_aux =  (* optionally kind-annotated identifier *)
   KOpt_none of kid (* identifier *)
 | KOpt_kind of kind * kid (* kind-annotated variable *)


type 
n_constraint = 
   NC_aux of n_constraint_aux * l


type 
kinded_id = 
   KOpt_aux of kinded_id_aux * l


type 
quant_item_aux =  (* Either a kinded identifier or a nexp constraint for a typquant *)
   QI_id of kinded_id (* An optionally kinded identifier *)
 | QI_const of n_constraint (* A constraint for this type *)


type 
quant_item = 
   QI_aux of quant_item_aux * l


type 
typquant_aux =  (* type quantifiers and constraints *)
   TypQ_tq of (quant_item) list
 | TypQ_no_forall (* sugar, omitting quantifier and constraints *)


type 
lit_aux =  (* Literal constant *)
   L_unit (* $() : _$ *)
 | L_zero (* $_ : _$ *)
 | L_one (* $_ : _$ *)
 | L_true (* $_ : _$ *)
 | L_false (* $_ : _$ *)
 | L_num of int (* natural number constant *)
 | L_hex of string (* bit vector constant, C-style *)
 | L_bin of string (* bit vector constant, C-style *)
 | L_undef (* constant representing undefined values *)
 | L_string of string (* string constant *)


type 
typquant = 
   TypQ_aux of typquant_aux * l


type 
typ_aux =  (* Type expressions, of kind $_$ *)
   Typ_wild (* Unspecified type *)
 | Typ_id of id (* Defined type *)
 | Typ_var of kid (* Type variable *)
 | Typ_fn of typ * typ * effect (* Function type (first-order only in user code) *)
 | Typ_tup of (typ) list (* Tuple type *)
 | Typ_app of id * (typ_arg) list (* type constructor application *)

and typ = 
   Typ_aux of typ_aux * l

and typ_arg_aux =  (* Type constructor arguments of all kinds *)
   Typ_arg_nexp of nexp
 | Typ_arg_typ of typ
 | Typ_arg_order of order
 | Typ_arg_effect of effect

and typ_arg = 
   Typ_arg_aux of typ_arg_aux * l


type 
lit = 
   L_aux of lit_aux * l


type 
typschm_aux =  (* type scheme *)
   TypSchm_ts of typquant * typ


type 
'a pat_aux =  (* Pattern *)
   P_lit of lit (* literal constant pattern *)
 | P_wild (* wildcard *)
 | P_as of 'a pat * id (* named pattern *)
 | P_typ of typ * 'a pat (* typed pattern *)
 | P_id of id (* identifier *)
 | P_app of id * ('a pat) list (* union constructor pattern *)
 | P_record of ('a fpat) list * bool (* struct pattern *)
 | P_vector of ('a pat) list (* vector pattern *)
 | P_vector_indexed of ((int * 'a pat)) list (* vector pattern (with explicit indices) *)
 | P_vector_concat of ('a pat) list (* concatenated vector pattern *)
 | P_tup of ('a pat) list (* tuple pattern *)
 | P_list of ('a pat) list (* list pattern *)

and 'a pat = 
   P_aux of 'a pat_aux * 'a annot

and 'a fpat_aux =  (* Field pattern *)
   FP_Fpat of id * 'a pat

and 'a fpat = 
   FP_aux of 'a fpat_aux * 'a annot


type 
typschm = 
   TypSchm_aux of typschm_aux * l


type 
'a reg_id_aux = 
   RI_id of id


type 
'a exp_aux =  (* Expression *)
   E_block of ('a exp) list (* block *)
 | E_nondet of ('a exp) list (* nondeterminisitic block, expressions evaluate in an unspecified order, or concurrently *)
 | E_id of id (* identifier *)
 | E_lit of lit (* literal constant *)
 | E_cast of typ * 'a exp (* cast *)
 | E_app of id * ('a exp) list (* function application *)
 | E_app_infix of 'a exp * id * 'a exp (* infix function application *)
 | E_tuple of ('a exp) list (* tuple *)
 | E_if of 'a exp * 'a exp * 'a exp (* conditional *)
 | E_for of id * 'a exp * 'a exp * 'a exp * order * 'a exp (* loop *)
 | E_vector of ('a exp) list (* vector (indexed from 0) *)
 | E_vector_indexed of ((int * 'a exp)) list * 'a opt_default (* vector (indexed consecutively) *)
 | E_vector_access of 'a exp * 'a exp (* vector access *)
 | E_vector_subrange of 'a exp * 'a exp * 'a exp (* subvector extraction *)
 | E_vector_update of 'a exp * 'a exp * 'a exp (* vector functional update *)
 | E_vector_update_subrange of 'a exp * 'a exp * 'a exp * 'a exp (* vector subrange update (with vector) *)
 | E_vector_append of 'a exp * 'a exp (* vector concatenation *)
 | E_list of ('a exp) list (* list *)
 | E_cons of 'a exp * 'a exp (* cons *)
 | E_record of 'a fexps (* struct *)
 | E_record_update of 'a exp * 'a fexps (* functional update of struct *)
 | E_field of 'a exp * id (* field projection from struct *)
 | E_case of 'a exp * ('a pexp) list (* pattern matching *)
 | E_let of 'a letbind * 'a exp (* let expression *)
 | E_assign of 'a lexp * 'a exp (* imperative assignment *)
 | E_exit of 'a exp (* expression to halt all current execution, potentially calling a system, trap, or interrupt handler with exp *)
 | E_internal_cast of 'a annot * 'a exp (* This is an internal cast, generated during type checking that will resolve into a syntactic cast after *)
 | E_internal_exp of 'a annot (* This is an internal use for passing nexp information  to library functions, postponed for constraint solving *)
 | E_internal_exp_user of 'a annot * 'a annot (* This is like the above but the user has specified an implicit parameter for the current function *)

and 'a exp = 
   E_aux of 'a exp_aux * 'a annot

and 'a lexp_aux =  (* lvalue expression *)
   LEXP_id of id (* identifier *)
 | LEXP_memory of id * ('a exp) list (* memory write via function call *)
 | LEXP_cast of typ * id
 | LEXP_vector of 'a lexp * 'a exp (* vector element *)
 | LEXP_vector_range of 'a lexp * 'a exp * 'a exp (* subvector *)
 | LEXP_field of 'a lexp * id (* struct field *)

and 'a lexp = 
   LEXP_aux of 'a lexp_aux * 'a annot

and 'a fexp_aux =  (* Field-expression *)
   FE_Fexp of id * 'a exp

and 'a fexp = 
   FE_aux of 'a fexp_aux * 'a annot

and 'a fexps_aux =  (* Field-expression list *)
   FES_Fexps of ('a fexp) list * bool

and 'a fexps = 
   FES_aux of 'a fexps_aux * 'a annot

and 'a opt_default_aux =  (* Optional default value for indexed vectors, to define a defualt value for any unspecified positions in a sparse map *)
   Def_val_empty
 | Def_val_dec of 'a exp

and 'a opt_default = 
   Def_val_aux of 'a opt_default_aux * 'a annot

and 'a pexp_aux =  (* Pattern match *)
   Pat_exp of 'a pat * 'a exp

and 'a pexp = 
   Pat_aux of 'a pexp_aux * 'a annot

and 'a letbind_aux =  (* Let binding *)
   LB_val_explicit of typschm * 'a pat * 'a exp (* value binding, explicit type ('a pat must be total) *)
 | LB_val_implicit of 'a pat * 'a exp (* value binding, implicit type ('a pat must be total) *)

and 'a letbind = 
   LB_aux of 'a letbind_aux * 'a annot


type 
'a reg_id = 
   RI_aux of 'a reg_id_aux * 'a annot


type 
type_union_aux =  (* Type union constructors *)
   Tu_id of id
 | Tu_ty_id of typ * id


type 
tannot_opt_aux =  (* Optional type annotation for functions *)
   Typ_annot_opt_some of typquant * typ


type 
'a funcl_aux =  (* Function clause *)
   FCL_Funcl of id * 'a pat * 'a exp


type 
effect_opt_aux =  (* Optional effect annotation for functions *)
   Effect_opt_pure (* sugar for empty effect set *)
 | Effect_opt_effect of effect


type 
name_scm_opt_aux =  (* Optional variable-naming-scheme specification for variables of defined type *)
   Name_sect_none
 | Name_sect_some of string


type 
rec_opt_aux =  (* Optional recursive annotation for functions *)
   Rec_nonrec (* non-recursive *)
 | Rec_rec (* recursive *)


type 
'a alias_spec_aux =  (* Register alias expression forms. Other than where noted, each id must refer to an unaliased register of type vector *)
   AL_subreg of 'a reg_id * id
 | AL_bit of 'a reg_id * 'a exp
 | AL_slice of 'a reg_id * 'a exp * 'a exp
 | AL_concat of 'a reg_id * 'a reg_id


type 
type_union = 
   Tu_aux of type_union_aux * l


type 
tannot_opt = 
   Typ_annot_opt_aux of tannot_opt_aux * l


type 
'a funcl = 
   FCL_aux of 'a funcl_aux * 'a annot


type 
effect_opt = 
   Effect_opt_aux of effect_opt_aux * l


type 
name_scm_opt = 
   Name_sect_aux of name_scm_opt_aux * l


type 
rec_opt = 
   Rec_aux of rec_opt_aux * l


type 
index_range_aux =  (* index specification, for bitfields in register types *)
   BF_single of int (* single index *)
 | BF_range of int * int (* index range *)
 | BF_concat of index_range * index_range (* concatenation of index ranges *)

and index_range = 
   BF_aux of index_range_aux * l


type 
'a alias_spec = 
   AL_aux of 'a alias_spec_aux * 'a annot


type 
'a scattered_def_aux =  (* Function and type union definitions that can be spread across
         a file. Each one must end in $_$ *)
   SD_scattered_function of rec_opt * tannot_opt * effect_opt * id (* scattered function definition header *)
 | SD_scattered_funcl of 'a funcl (* scattered function definition clause *)
 | SD_scattered_variant of id * name_scm_opt * typquant (* scattered union definition header *)
 | SD_scattered_unioncl of id * type_union (* scattered union definition member *)
 | SD_scattered_end of id (* scattered definition end *)


type 
'a type_def_aux =  (* Type definition body *)
   TD_abbrev of id * name_scm_opt * typschm (* type abbreviation *)
 | TD_record of id * name_scm_opt * typquant * ((typ * id)) list * bool (* struct type definition *)
 | TD_variant of id * name_scm_opt * typquant * (type_union) list * bool (* union type definition *)
 | TD_enum of id * name_scm_opt * (id) list * bool (* enumeration type definition *)
 | TD_register of id * nexp * nexp * ((index_range * id)) list (* register mutable bitfield type definition *)


type 
'a default_spec_aux =  (* Default kinding or typing assumption *)
   DT_kind of base_kind * kid
 | DT_order of order
 | DT_typ of typschm * id


type 
'a fundef_aux =  (* Function definition *)
   FD_function of rec_opt * tannot_opt * effect_opt * ('a funcl) list


type 
'a dec_spec_aux =  (* Register declarations *)
   DEC_reg of typ * id
 | DEC_alias of id * 'a alias_spec
 | DEC_typ_alias of typ * id * 'a alias_spec


type 
'a val_spec_aux =  (* Value type specification *)
   VS_val_spec of typschm * id
 | VS_extern_no_rename of typschm * id
 | VS_extern_spec of typschm * id * string (* Specify the type and id of a function from Lem, where the string must provide an explicit path to the required function but will not be checked *)


type 
'a scattered_def = 
   SD_aux of 'a scattered_def_aux * 'a annot


type 
'a type_def = 
   TD_aux of 'a type_def_aux * 'a annot


type 
'a default_spec = 
   DT_aux of 'a default_spec_aux * l


type 
'a fundef = 
   FD_aux of 'a fundef_aux * 'a annot


type 
'a dec_spec = 
   DEC_aux of 'a dec_spec_aux * 'a annot


type 
'a val_spec = 
   VS_aux of 'a val_spec_aux * 'a annot


type 
'a def =  (* Top-level definition *)
   DEF_type of 'a type_def (* type definition *)
 | DEF_fundef of 'a fundef (* function definition *)
 | DEF_val of 'a letbind (* value definition *)
 | DEF_spec of 'a val_spec (* top-level type constraint *)
 | DEF_default of 'a default_spec (* default kind and type assumptions *)
 | DEF_scattered of 'a scattered_def (* scattered function and type definition *)
 | DEF_reg_dec of 'a dec_spec (* register declaration *)


type 
'a defs =  (* Definition sequence *)
   Defs of ('a def) list

(** pretty printer *)
let pp_x (y5:x) : string = y5

let pp_kid_aux (kid_aux5:kid_aux) : string =
  match kid_aux5 with
  | (Var x) -> " ' " ^ (pp_x x)


let pp_kid (kid5:kid) : string =
  match kid5 with
  | (Kid_aux (kid_aux,l)) -> (pp_kid_aux kid_aux) ^ " " ^ (pp_l l)


let pp_id_aux (id_aux5:id_aux) : string =
  match id_aux5 with
  | (Id x) -> (pp_x x)
  | (DeIid x) -> " ( " ^ " deinfix " ^ (pp_x x) ^ " ) "


let pp_effect_aux (effect_aux5:effect_aux) : string =
  match effect_aux5 with
  | (Effect_var kid) -> (pp_kid kid)
  | (Effect_set (base_effect_list)) -> " { " ^ (String.concat "," (List.map (fun base_effect -> pp_base_effect base_effect) base_effect_list)) ^ " } "


let pp_typquant_aux (typquant_aux5:typquant_aux) : string =
  match typquant_aux5 with
  | (TypQ_tq (quant_item_list)) -> " forall " ^ (String.concat "," (List.map (fun quant_item -> pp_quant_item quant_item) quant_item_list)) ^ " . "
  | TypQ_no_forall -> 


let pp_id (id5:id) : string =
  match id5 with
  | (Id_aux (id_aux,l)) -> (pp_id_aux id_aux) ^ " " ^ (pp_l l)


let pp_effect (effect5:effect) : string =
  match effect5 with
  | (Effect_aux (effect_aux,l)) -> (pp_effect_aux effect_aux) ^ " " ^ (pp_l l)


let pp_typquant (typquant5:typquant) : string =
  match typquant5 with
  | (TypQ_aux (typquant_aux,l)) -> (pp_typquant_aux typquant_aux) ^ " " ^ (pp_l l)


let rec pp_typ (typ5:typ) : string =
  match typ5 with
  | (Typ_aux (typ_aux,l)) -> (pp_typ_aux typ_aux) ^ " " ^ (pp_l l)
and
pp_typ_aux (typ_aux5:typ_aux) : string =
  match typ_aux5 with
  | Typ_wild -> " _ "
  | (Typ_id id) -> (pp_id id)
  | (Typ_var kid) -> (pp_kid kid)
  | (Typ_fn (typ1,typ2,effect)) -> (pp_typ typ1) ^ " -> " ^ (pp_typ typ2) ^ " effectkw " ^ (pp_effect effect)
  | (Typ_tup (typ_list)) -> " ( " ^ (String.concat "," (List.map (fun typ -> pp_typ typ) typ_list)) ^ " ) "
  | (Typ_app (id,(typ_arg_list))) -> (pp_id id) ^ " < " ^ (String.concat "," (List.map (fun typ_arg -> pp_typ_arg typ_arg) typ_arg_list)) ^ " > "


let pp_lit_aux (lit_aux5:lit_aux) : string =
  match lit_aux5 with
  | L_unit -> " ( " ^ " ) "
  | L_zero -> " bitzero "
  | L_one -> " bitone "
  | L_true -> " true "
  | L_false -> " false "
  | (L_num num) -> (pp_num num)
  | (L_hex hex) -> (pp_hex hex)
  | (L_bin bin) -> (pp_bin bin)
  | L_undef -> " undefined "
  | (L_string string) -> (pp_string string)


let pp_fexps_aux (fexps_aux5:fexps_aux) : string =
  match fexps_aux5 with
  | (FES_Fexps ((fexp_list),semi_opt)) -> (String.concat ";" (List.map (fun fexp -> pp_'a fexp fexp) fexp_list)) ^ " " ^ (pp_semi_opt semi_opt)


let pp_order_aux (order_aux5:order_aux) : string =
  match order_aux5 with
  | (Ord_var kid) -> (pp_kid kid)
  | Ord_inc -> " inc "
  | Ord_dec -> " dec "


let pp_typschm_aux (typschm_aux5:typschm_aux) : string =
  match typschm_aux5 with
  | (TypSchm_ts (typquant,typ)) -> (pp_typquant typquant) ^ " " ^ (pp_typ typ)


let pp_lit (lit5:lit) : string =
  match lit5 with
  | (L_aux (lit_aux,l)) -> (pp_lit_aux lit_aux) ^ " " ^ (pp_l l)


let pp_reg_id_aux (reg_id_aux5:reg_id_aux) : string =
  match reg_id_aux5 with
  | (RI_id id) -> (pp_id id)


let pp_fexps (fexps5:fexps) : string =
  match fexps5 with
  | (FES_aux (fexps_aux,annot)) -> (pp_fexps_aux fexps_aux) ^ " " ^ (pp_annot annot)


let pp_order (order5:order) : string =
  match order5 with
  | (Ord_aux (order_aux,l)) -> (pp_order_aux order_aux) ^ " " ^ (pp_l l)


let pp_typschm (typschm5:typschm) : string =
  match typschm5 with
  | (TypSchm_aux (typschm_aux,l)) -> (pp_typschm_aux typschm_aux) ^ " " ^ (pp_l l)


let rec pp_pat (pat5:pat) : string =
  match pat5 with
  | (P_aux (pat_aux,annot)) -> (pp_pat_aux pat_aux) ^ " " ^ (pp_annot annot)
and
pp_pat_aux (pat_aux5:pat_aux) : string =
  match pat_aux5 with
  | (P_lit lit) -> (pp_lit lit)
  | P_wild -> " _ "
  | (P_as (pat,id)) -> " ( " ^ (pp_pat pat) ^ " as " ^ (pp_id id) ^ " ) "
  | (P_typ (typ,pat)) -> " ( " ^ (pp_typ typ) ^ " ) " ^ (pp_pat pat)
  | (P_id id) -> (pp_id id)
  | (P_app (id,(pat_list))) -> (pp_id id) ^ " ( " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ) "
  | (P_record ((fpat_list),semi_opt)) -> " { " ^ (String.concat ";" (List.map (fun fpat -> pp_'a fpat fpat) fpat_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (P_vector (pat_list)) -> " [ " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ] "
  | (P_vector_indexed (num_pat_list)) -> " [ " ^ (String.concat "," (List.map (fun num,pat -> pp_int num,pp_'a pat pat) num_pat_list)) ^ " ] "
  | (P_vector_concat (pat_list)) -> (String.concat ":" (List.map (fun pat -> pp_'a pat pat) pat_list))
  | (P_tup (pat_list)) -> " ( " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ) "
  | (P_list (pat_list)) -> " [|| " ^ (String.concat "," (List.map (fun pat -> pp_'a pat pat) pat_list)) ^ " ||] "


let pp_kind_aux (kind_aux5:kind_aux) : string =
  match kind_aux5 with
  | (K_kind (base_kind_list)) -> (String.concat "->" (List.map (fun base_kind -> pp_base_kind base_kind) base_kind_list))


let pp_reg_id (reg_id5:reg_id) : string =
  match reg_id5 with
  | (RI_aux (reg_id_aux,annot)) -> (pp_reg_id_aux reg_id_aux) ^ " " ^ (pp_annot annot)


let rec pp_letbind (letbind5:letbind) : string =
  match letbind5 with
  | (LB_aux (letbind_aux,annot)) -> (pp_letbind_aux letbind_aux) ^ " " ^ (pp_annot annot)
and
pp_letbind_aux (letbind_aux5:letbind_aux) : string =
  match letbind_aux5 with
  | (LB_val_explicit (typschm,pat,exp)) -> " let " ^ (pp_typschm typschm) ^ " " ^ (pp_pat pat) ^ " = " ^ (pp_exp exp)
  | (LB_val_implicit (pat,exp)) -> " let " ^ (pp_pat pat) ^ " = " ^ (pp_exp exp)
and
pp_opt_default (opt_default5:opt_default) : string =
  match opt_default5 with
  | (Def_val_aux (opt_default_aux,annot)) -> (pp_opt_default_aux opt_default_aux) ^ " " ^ (pp_annot annot)
and
pp_opt_default_aux (opt_default_aux5:opt_default_aux) : string =
  match opt_default_aux5 with
  | Def_val_empty -> 
  | (Def_val_dec exp) -> " ; " ^ " default " ^ " = " ^ (pp_exp exp)
and
pp_lexp (lexp5:lexp) : string =
  match lexp5 with
  | (LEXP_aux (lexp_aux,annot)) -> (pp_lexp_aux lexp_aux) ^ " " ^ (pp_annot annot)
and
pp_lexp_aux (lexp_aux5:lexp_aux) : string =
  match lexp_aux5 with
  | (LEXP_id id) -> (pp_id id)
  | (LEXP_memory (id,(exp_list))) -> (pp_id id) ^ " ( " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ) "
  | (LEXP_cast (typ,id)) -> " ( " ^ (pp_typ typ) ^ " ) " ^ (pp_id id)
  | (LEXP_vector (lexp,exp)) -> (pp_lexp lexp) ^ " [ " ^ (pp_exp exp) ^ " ] "
  | (LEXP_vector_range (lexp,exp1,exp2)) -> (pp_lexp lexp) ^ " [ " ^ (pp_exp exp1) ^ " .. " ^ (pp_exp exp2) ^ " ] "
  | (LEXP_field (lexp,id)) -> (pp_lexp lexp) ^ " . " ^ (pp_id id)
and
pp_exp (exp5:exp) : string =
  match exp5 with
  | (E_aux (exp_aux,annot)) -> (pp_exp_aux exp_aux) ^ " " ^ (pp_annot annot)
and
pp_exp_aux (exp_aux5:exp_aux) : string =
  match exp_aux5 with
  | (E_block (exp_list)) -> " { " ^ (String.concat ";" (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " } "
  | (E_nondet (exp_list)) -> " nondet " ^ " { " ^ (String.concat ";" (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " } "
  | (E_id id) -> (pp_id id)
  | (E_lit lit) -> (pp_lit lit)
  | (E_cast (typ,exp)) -> " ( " ^ (pp_typ typ) ^ " ) " ^ (pp_exp exp)
  | (E_app (id,(exp_list))) -> (pp_id id) ^ " ( " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ) "
  | (E_app_infix (exp1,id,exp2)) -> (pp_exp exp1) ^ " " ^ (pp_id id) ^ " " ^ (pp_exp exp2)
  | (E_tuple (exp_list)) -> " ( " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ) "
  | (E_if (exp1,exp2,exp3)) -> " if " ^ (pp_exp exp1) ^ " then " ^ (pp_exp exp2) ^ " else " ^ (pp_exp exp3)
  | (E_for (id,exp1,exp2,exp3,order,exp4)) -> " foreach " ^ " ( " ^ (pp_id id) ^ " from " ^ (pp_exp exp1) ^ " to " ^ (pp_exp exp2) ^ " by " ^ (pp_exp exp3) ^ " in " ^ (pp_order order) ^ " ) " ^ (pp_exp exp4)
  | (E_vector (exp_list)) -> " [ " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ] "
  | (E_vector_indexed ((num_exp_list),opt_default)) -> " [ " ^ (String.concat "," (List.map (fun num,exp -> pp_int num,pp_'a exp exp) num_exp_list)) ^ " " ^ (pp_opt_default opt_default) ^ " ] "
  | (E_vector_access (exp,exp')) -> (pp_exp exp) ^ " [ " ^ (pp_exp exp') ^ " ] "
  | (E_vector_subrange (exp,exp1,exp2)) -> (pp_exp exp) ^ " [ " ^ (pp_exp exp1) ^ " .. " ^ (pp_exp exp2) ^ " ] "
  | (E_vector_update (exp,exp1,exp2)) -> " [ " ^ (pp_exp exp) ^ " with " ^ (pp_exp exp1) ^ " = " ^ (pp_exp exp2) ^ " ] "
  | (E_vector_update_subrange (exp,exp1,exp2,exp3)) -> " [ " ^ (pp_exp exp) ^ " with " ^ (pp_exp exp1) ^ " : " ^ (pp_exp exp2) ^ " = " ^ (pp_exp exp3) ^ " ] "
  | (E_vector_append (exp,exp2)) -> (pp_exp exp) ^ " : " ^ (pp_exp exp2)
  | (E_list (exp_list)) -> " [|| " ^ (String.concat "," (List.map (fun exp -> pp_'a exp exp) exp_list)) ^ " ||] "
  | (E_cons (exp1,exp2)) -> (pp_exp exp1) ^ " :: " ^ (pp_exp exp2)
  | (E_record fexps) -> " { " ^ (pp_fexps fexps) ^ " } "
  | (E_record_update (exp,fexps)) -> " { " ^ (pp_exp exp) ^ " with " ^ (pp_fexps fexps) ^ " } "
  | (E_field (exp,id)) -> (pp_exp exp) ^ " . " ^ (pp_id id)
  | (E_case (exp,(pexp_list))) -> " switch " ^ (pp_exp exp) ^ " { " ^ (String.concat " " (List.map (fun pexp -> pp_'a pexp pexp) pexp_list)) ^ " } "
  | (E_let (letbind,exp)) -> (pp_letbind letbind) ^ " in " ^ (pp_exp exp)
  | (E_assign (lexp,exp)) -> (pp_lexp lexp) ^ " := " ^ (pp_exp exp)
  | (E_exit exp) -> " exit " ^ (pp_exp exp)
  | (E_internal_cast (annot,exp)) -> " ( " ^ (pp_annot annot) ^ " ) " ^ (pp_exp exp)
  | (E_internal_exp annot) -> (pp_annot annot)
  | (E_internal_exp_user (annot,annot')) -> (pp_annot annot) ^ " , " ^ (pp_annot annot')


let rec pp_nexp (nexp5:nexp) : string =
  match nexp5 with
  | (Nexp_aux (nexp_aux,l)) -> (pp_nexp_aux nexp_aux) ^ " " ^ (pp_l l)
and
pp_nexp_aux (nexp_aux5:nexp_aux) : string =
  match nexp_aux5 with
  | (Nexp_var kid) -> (pp_kid kid)
  | (Nexp_constant num) -> (pp_num num)
  | (Nexp_times (nexp1,nexp2)) -> (pp_nexp nexp1) ^ " * " ^ (pp_nexp nexp2)
  | (Nexp_sum (nexp1,nexp2)) -> (pp_nexp nexp1) ^ " + " ^ (pp_nexp nexp2)
  | (Nexp_minus (nexp1,nexp2)) -> (pp_nexp nexp1) ^ " - " ^ (pp_nexp nexp2)
  | (Nexp_exp nexp) -> " 2** " ^ (pp_nexp nexp)
  | (Nexp_neg nexp) -> " neg " ^ (pp_nexp nexp)


let pp_kind (kind5:kind) : string =
  match kind5 with
  | (K_aux (kind_aux,l)) -> (pp_kind_aux kind_aux) ^ " " ^ (pp_l l)


let pp_alias_spec_aux (alias_spec_aux5:alias_spec_aux) : string =
  match alias_spec_aux5 with
  | (AL_subreg (reg_id,id)) -> (pp_reg_id reg_id) ^ " . " ^ (pp_id id)
  | (AL_bit (reg_id,exp)) -> (pp_reg_id reg_id) ^ " [ " ^ (pp_exp exp) ^ " ] "
  | (AL_slice (reg_id,exp,exp')) -> (pp_reg_id reg_id) ^ " [ " ^ (pp_exp exp) ^ " .. " ^ (pp_exp exp') ^ " ] "
  | (AL_concat (reg_id,reg_id')) -> (pp_reg_id reg_id) ^ " : " ^ (pp_reg_id reg_id')


let pp_name_scm_opt_aux (name_scm_opt_aux5:name_scm_opt_aux) : string =
  match name_scm_opt_aux5 with
  | Name_sect_none -> 
  | (Name_sect_some regexp) -> " [ " ^ " name " ^ " = " ^ (pp_regexp regexp) ^ " ] "


let pp_funcl_aux (funcl_aux5:funcl_aux) : string =
  match funcl_aux5 with
  | (FCL_Funcl (id,pat,exp)) -> (pp_id id) ^ " " ^ (pp_pat pat) ^ " = " ^ (pp_exp exp)


let pp_effect_opt_aux (effect_opt_aux5:effect_opt_aux) : string =
  match effect_opt_aux5 with
  | Effect_opt_pure -> 
  | (Effect_opt_effect effect) -> " effectkw " ^ (pp_effect effect)


let pp_type_union_aux (type_union_aux5:type_union_aux) : string =
  match type_union_aux5 with
  | (Tu_id id) -> (pp_id id)
  | (Tu_ty_id (typ,id)) -> (pp_typ typ) ^ " " ^ (pp_id id)


let pp_tannot_opt_aux (tannot_opt_aux5:tannot_opt_aux) : string =
  match tannot_opt_aux5 with
  | (Typ_annot_opt_some (typquant,typ)) -> (pp_typquant typquant) ^ " " ^ (pp_typ typ)


let pp_rec_opt_aux (rec_opt_aux5:rec_opt_aux) : string =
  match rec_opt_aux5 with
  | Rec_nonrec -> 
  | Rec_rec -> " rec "


let pp_base_kind_aux (base_kind_aux5:base_kind_aux) : string =
  match base_kind_aux5 with
  | BK_type -> " Type "
  | BK_nat -> " Nat "
  | BK_order -> " Order "
  | BK_effect -> " Effect "


let pp_n_constraint_aux (n_constraint_aux5:n_constraint_aux) : string =
  match n_constraint_aux5 with
  | (NC_fixed (nexp,nexp')) -> (pp_nexp nexp) ^ " = " ^ (pp_nexp nexp')
  | (NC_bounded_ge (nexp,nexp')) -> (pp_nexp nexp) ^ " >= " ^ (pp_nexp nexp')
  | (NC_bounded_le (nexp,nexp')) -> (pp_nexp nexp) ^ " <= " ^ (pp_nexp nexp')
  | (NC_nat_set_bounded (kid,(num_list))) -> (pp_kid kid) ^ " IN " ^ " { " ^ (String.concat "," (List.map (fun num -> pp_int num) num_list)) ^ " } "


let pp_kinded_id_aux (kinded_id_aux5:kinded_id_aux) : string =
  match kinded_id_aux5 with
  | (KOpt_none kid) -> (pp_kid kid)
  | (KOpt_kind (kind,kid)) -> (pp_kind kind) ^ " " ^ (pp_kid kid)


let pp_alias_spec (alias_spec5:alias_spec) : string =
  match alias_spec5 with
  | (AL_aux (alias_spec_aux,annot)) -> (pp_alias_spec_aux alias_spec_aux) ^ " " ^ (pp_annot annot)


let pp_name_scm_opt (name_scm_opt5:name_scm_opt) : string =
  match name_scm_opt5 with
  | (Name_sect_aux (name_scm_opt_aux,l)) -> (pp_name_scm_opt_aux name_scm_opt_aux) ^ " " ^ (pp_l l)


let pp_funcl (funcl5:funcl) : string =
  match funcl5 with
  | (FCL_aux (funcl_aux,annot)) -> (pp_funcl_aux funcl_aux) ^ " " ^ (pp_annot annot)


let pp_effect_opt (effect_opt5:effect_opt) : string =
  match effect_opt5 with
  | (Effect_opt_aux (effect_opt_aux,l)) -> (pp_effect_opt_aux effect_opt_aux) ^ " " ^ (pp_l l)


let pp_type_union (type_union5:type_union) : string =
  match type_union5 with
  | (Tu_aux (type_union_aux,l)) -> (pp_type_union_aux type_union_aux) ^ " " ^ (pp_l l)


let pp_tannot_opt (tannot_opt5:tannot_opt) : string =
  match tannot_opt5 with
  | (Typ_annot_opt_aux (tannot_opt_aux,l)) -> (pp_tannot_opt_aux tannot_opt_aux) ^ " " ^ (pp_l l)


let pp_rec_opt (rec_opt5:rec_opt) : string =
  match rec_opt5 with
  | (Rec_aux (rec_opt_aux,l)) -> (pp_rec_opt_aux rec_opt_aux) ^ " " ^ (pp_l l)


let pp_base_kind (base_kind5:base_kind) : string =
  match base_kind5 with
  | (BK_aux (base_kind_aux,l)) -> (pp_base_kind_aux base_kind_aux) ^ " " ^ (pp_l l)


let pp_n_constraint (n_constraint5:n_constraint) : string =
  match n_constraint5 with
  | (NC_aux (n_constraint_aux,l)) -> (pp_n_constraint_aux n_constraint_aux) ^ " " ^ (pp_l l)


let pp_kinded_id (kinded_id5:kinded_id) : string =
  match kinded_id5 with
  | (KOpt_aux (kinded_id_aux,l)) -> (pp_kinded_id_aux kinded_id_aux) ^ " " ^ (pp_l l)


let pp_dec_spec_aux (dec_spec_aux5:dec_spec_aux) : string =
  match dec_spec_aux5 with
  | (DEC_reg (typ,id)) -> " register " ^ (pp_typ typ) ^ " " ^ (pp_id id)
  | (DEC_alias (id,alias_spec)) -> " register " ^ " alias " ^ (pp_id id) ^ " = " ^ (pp_alias_spec alias_spec)
  | (DEC_typ_alias (typ,id,alias_spec)) -> " register " ^ " alias " ^ (pp_typ typ) ^ " " ^ (pp_id id) ^ " = " ^ (pp_alias_spec alias_spec)


let pp_type_def_aux (type_def_aux5:type_def_aux) : string =
  match type_def_aux5 with
  | (TD_abbrev (id,name_scm_opt,typschm)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ (pp_typschm typschm)
  | (TD_record (id,name_scm_opt,typquant,(typ_id_list),semi_opt)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " const " ^ " struct " ^ (pp_typquant typquant) ^ " { " ^ (String.concat ";" (List.map (fun typ,id -> pp_typ typ;pp_id id) typ_id_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (TD_variant (id,name_scm_opt,typquant,(type_union_list),semi_opt)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " const " ^ " union " ^ (pp_typquant typquant) ^ " { " ^ (String.concat ";" (List.map (fun type_union -> pp_type_union type_union) type_union_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (TD_enum (id,name_scm_opt,(id_list),semi_opt)) -> " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " enumerate " ^ " { " ^ (String.concat ";" (List.map (fun id -> pp_id id) id_list)) ^ " " ^ (pp_semi_opt semi_opt) ^ " } "
  | (TD_register (id,nexp,nexp',(index_range_id_list))) -> " typedef " ^ (pp_id id) ^ " = " ^ " register " ^ " bits " ^ " [ " ^ (pp_nexp nexp) ^ " : " ^ (pp_nexp nexp') ^ " ] " ^ " { " ^ (String.concat ";" (List.map (fun index_range,id -> pp_index_range index_range;pp_id id) index_range_id_list)) ^ " } "


let pp_scattered_def_aux (scattered_def_aux5:scattered_def_aux) : string =
  match scattered_def_aux5 with
  | (SD_scattered_function (rec_opt,tannot_opt,effect_opt,id)) -> " scattered " ^ " function " ^ (pp_rec_opt rec_opt) ^ " " ^ (pp_tannot_opt tannot_opt) ^ " " ^ (pp_effect_opt effect_opt) ^ " " ^ (pp_id id)
  | (SD_scattered_funcl funcl) -> " function " ^ " clause " ^ (pp_funcl funcl)
  | (SD_scattered_variant (id,name_scm_opt,typquant)) -> " scattered " ^ " typedef " ^ (pp_id id) ^ " " ^ (pp_name_scm_opt name_scm_opt) ^ " = " ^ " const " ^ " union " ^ (pp_typquant typquant)
  | (SD_scattered_unioncl (id,type_union)) -> " union " ^ (pp_id id) ^ " member " ^ (pp_type_union type_union)
  | (SD_scattered_end id) -> " end " ^ (pp_id id)


let pp_fundef_aux (fundef_aux5:fundef_aux) : string =
  match fundef_aux5 with
  | (FD_function (rec_opt,tannot_opt,effect_opt,(funcl_list))) -> " function " ^ (pp_rec_opt rec_opt) ^ " " ^ (pp_tannot_opt tannot_opt) ^ " " ^ (pp_effect_opt effect_opt) ^ (String.concat "and" (List.map (fun funcl -> pp_'a funcl funcl) funcl_list))


let pp_default_spec_aux (default_spec_aux5:default_spec_aux) : string =
  match default_spec_aux5 with
  | (DT_kind (base_kind,kid)) -> " default " ^ (pp_base_kind base_kind) ^ " " ^ (pp_kid kid)
  | (DT_order order) -> " default " ^ " Order " ^ (pp_order order)
  | (DT_typ (typschm,id)) -> " default " ^ (pp_typschm typschm) ^ " " ^ (pp_id id)


let pp_val_spec_aux (val_spec_aux5:val_spec_aux) : string =
  match val_spec_aux5 with
  | (VS_val_spec (typschm,id)) -> " val " ^ (pp_typschm typschm) ^ " " ^ (pp_id id)
  | (VS_extern_no_rename (typschm,id)) -> " val " ^ " extern " ^ (pp_typschm typschm) ^ " " ^ (pp_id id)
  | (VS_extern_spec (typschm,id,string)) -> " val " ^ " extern " ^ (pp_typschm typschm) ^ " " ^ (pp_id id) ^ " = " ^ (pp_string string)


let pp_pexp_aux (pexp_aux5:pexp_aux) : string =
  match pexp_aux5 with
  | (Pat_exp (pat,exp)) -> (pp_pat pat) ^ " -> " ^ (pp_exp exp)


let pp_quant_item_aux (quant_item_aux5:quant_item_aux) : string =
  match quant_item_aux5 with
  | (QI_id kinded_id) -> (pp_kinded_id kinded_id)
  | (QI_const n_constraint) -> (pp_n_constraint n_constraint)


let pp_typ_arg_aux (typ_arg_aux5:typ_arg_aux) : string =
  match typ_arg_aux5 with
  | (Typ_arg_nexp nexp) -> (pp_nexp nexp)
  | (Typ_arg_typ typ) -> (pp_typ typ)
  | (Typ_arg_order order) -> (pp_order order)
  | (Typ_arg_effect effect) -> (pp_effect effect)


let pp_dec_spec (dec_spec5:dec_spec) : string =
  match dec_spec5 with
  | (DEC_aux (dec_spec_aux,annot)) -> (pp_dec_spec_aux dec_spec_aux) ^ " " ^ (pp_annot annot)


let pp_type_def (type_def5:type_def) : string =
  match type_def5 with
  | (TD_aux (type_def_aux,annot)) -> (pp_type_def_aux type_def_aux) ^ " " ^ (pp_annot annot)


let pp_scattered_def (scattered_def5:scattered_def) : string =
  match scattered_def5 with
  | (SD_aux (scattered_def_aux,annot)) -> (pp_scattered_def_aux scattered_def_aux) ^ " " ^ (pp_annot annot)


let pp_fundef (fundef5:fundef) : string =
  match fundef5 with
  | (FD_aux (fundef_aux,annot)) -> (pp_fundef_aux fundef_aux) ^ " " ^ (pp_annot annot)


let pp_default_spec (default_spec5:default_spec) : string =
  match default_spec5 with
  | (DT_aux (default_spec_aux,l)) -> (pp_default_spec_aux default_spec_aux) ^ " " ^ (pp_l l)


let pp_val_spec (val_spec5:val_spec) : string =
  match val_spec5 with
  | (VS_aux (val_spec_aux,annot)) -> (pp_val_spec_aux val_spec_aux) ^ " " ^ (pp_annot annot)


let pp_fpat_aux (fpat_aux5:fpat_aux) : string =
  match fpat_aux5 with
  | (FP_Fpat (id,pat)) -> (pp_id id) ^ " = " ^ (pp_pat pat)


let pp_base_effect_aux (base_effect_aux5:base_effect_aux) : string =
  match base_effect_aux5 with
  | BE_rreg -> " rreg "
  | BE_wreg -> " wreg "
  | BE_rmem -> " rmem "
  | BE_wmem -> " wmem "
  | BE_barr -> " barr "
  | BE_undef -> " undef "
  | BE_unspec -> " unspec "
  | BE_nondet -> " nondet "


let pp_fexp_aux (fexp_aux5:fexp_aux) : string =
  match fexp_aux5 with
  | (FE_Fexp (id,exp)) -> (pp_id id) ^ " = " ^ (pp_exp exp)


let rec pp_index_range (index_range5:index_range) : string =
  match index_range5 with
  | (BF_aux (index_range_aux,l)) -> (pp_index_range_aux index_range_aux) ^ " " ^ (pp_l l)
and
pp_index_range_aux (index_range_aux5:index_range_aux) : string =
  match index_range_aux5 with
  | (BF_single num) -> (pp_num num)
  | (BF_range (num1,num2)) -> (pp_num num1) ^ " .. " ^ (pp_num num2)
  | (BF_concat (index_range1,index_range2)) -> (pp_index_range index_range1) ^ " , " ^ (pp_index_range index_range2)


let pp_pexp (pexp5:pexp) : string =
  match pexp5 with
  | (Pat_aux (pexp_aux,annot)) -> (pp_pexp_aux pexp_aux) ^ " " ^ (pp_annot annot)


let pp_quant_item (quant_item5:quant_item) : string =
  match quant_item5 with
  | (QI_aux (quant_item_aux,l)) -> (pp_quant_item_aux quant_item_aux) ^ " " ^ (pp_l l)


let pp_ix (ix5:ix) : string = ix5

let pp_typ_arg (typ_arg5:typ_arg) : string =
  match typ_arg5 with
  | (Typ_arg_aux (typ_arg_aux,l)) -> (pp_typ_arg_aux typ_arg_aux) ^ " " ^ (pp_l l)


let pp_def (def5:def) : string =
  match def5 with
  | (DEF_type type_def) -> (pp_type_def type_def)
  | (DEF_fundef fundef) -> (pp_fundef fundef)
  | (DEF_val letbind) -> (pp_letbind letbind)
  | (DEF_spec val_spec) -> (pp_val_spec val_spec)
  | (DEF_default default_spec) -> (pp_default_spec default_spec)
  | (DEF_scattered scattered_def) -> (pp_scattered_def scattered_def)
  | (DEF_reg_dec dec_spec) -> (pp_dec_spec dec_spec)


let pp_fpat (fpat5:fpat) : string =
  match fpat5 with
  | (FP_aux (fpat_aux,annot)) -> (pp_fpat_aux fpat_aux) ^ " " ^ (pp_annot annot)


let pp_base_effect (base_effect5:base_effect) : string =
  match base_effect5 with
  | (BE_aux (base_effect_aux,l)) -> (pp_base_effect_aux base_effect_aux) ^ " " ^ (pp_l l)


let pp_fexp (fexp5:fexp) : string =
  match fexp5 with
  | (FE_aux (fexp_aux,annot)) -> (pp_fexp_aux fexp_aux) ^ " " ^ (pp_annot annot)


let pp_defs (defs5:defs) : string =
  match defs5 with
  | (Defs (def_list)) -> (String.concat " " (List.map (fun def -> pp_'a def def) def_list))




