(*Generated by Lem from /home/bcampbe2/local/rems/github/sail/mips/mips_extras_sequential.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory sail_instr_kindsTheory sail_valuesTheory state_monadTheory stateTheory sail_operatorsTheory;

val _ = numLib.prefer_num();



val _ = new_theory "mips_extras_sequential"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators*)
(*open import State_monad*)
(*open import State*)

(*val MEMr             : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> State_monad.monadS 'regval 'b 'e*)
(*val MEMr_reserve     : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> State_monad.monadS 'regval 'b 'e*)
(*val MEMr_tag         : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> State_monad.monadS 'regval (bool * 'b) 'e*)
(*val MEMr_tag_reserve : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> State_monad.monadS 'regval (bool * 'b) 'e*)

val _ = Define `
 ((MEMr:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int ->('regval,'b,'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=              (read_memS 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_plain addr size1))`;

val _ = Define `
 ((MEMr_reserve:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int ->('regval,'b,'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=      (read_memS 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_reserve addr size1))`;


(*val read_tag_bool : forall 'regval 'a 'e. Bitvector 'a => 'a -> State_monad.monadS 'regval bool 'e*)
val _ = Define `
 ((read_tag_bool:'a sail_values$Bitvector_class -> 'a ->('regval,(bool),'e)state_monad$monadS)dict_Sail_values_Bitvector_a addr=  (bindS  
(read_tagS dict_Sail_values_Bitvector_a addr) (\ t . 
  maybe_failS "read_tag_bool" (bool_of_bitU t))))`;


(*val write_tag_bool : forall 'regval 'a 'e. Bitvector 'a => 'a -> bool -> State_monad.monadS 'regval unit 'e*)
val _ = Define `
 ((write_tag_bool:'a sail_values$Bitvector_class -> 'a -> bool ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a addr t=  (bindS (write_tagS 
  dict_Sail_values_Bitvector_a addr (bitU_of_bool t)) 
  (\b .  (case (b ) of ( _ ) => returnS ()  ))))`;


val _ = Define `
 ((MEMr_tag:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int ->('regval,(bool#'b),'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=  (bindS  
(read_memS dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_plain addr size1) (\ v .  bindS  
(read_tag_bool dict_Sail_values_Bitvector_a addr) (\ t . 
  returnS (t, v)))))`;


val _ = Define `
 ((MEMr_tag_reserve:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int ->('regval,(bool#'b),'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=  (bindS  
(read_memS dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_plain addr size1) (\ v .  bindS  
(read_tag_bool dict_Sail_values_Bitvector_a addr) (\ t . 
  returnS (t, v)))))`;



(*val MEMea                 : forall 'regval 'a 'e. Bitvector 'a => 'a -> Num.integer -> State_monad.monadS 'regval unit 'e*)
(*val MEMea_conditional     : forall 'regval 'a 'e. Bitvector 'a => 'a -> Num.integer -> State_monad.monadS 'regval unit 'e*)
(*val MEMea_tag             : forall 'regval 'a 'e. Bitvector 'a => 'a -> Num.integer -> State_monad.monadS 'regval unit 'e*)
(*val MEMea_tag_conditional : forall 'regval 'a 'e. Bitvector 'a => 'a -> Num.integer -> State_monad.monadS 'regval unit 'e*)

val _ = Define `
 ((MEMea:'a sail_values$Bitvector_class -> 'a -> int ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a addr size1=                  (write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_plain addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_conditional:'a sail_values$Bitvector_class -> 'a -> int ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a addr size1=      (write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_conditional addr (nat_of_int size1)))`;


val _ = Define `
 ((MEMea_tag:'a sail_values$Bitvector_class -> 'a -> int ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a addr size1=              (write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_plain addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_tag_conditional:'a sail_values$Bitvector_class -> 'a -> int ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a addr size1=  (write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_conditional addr (nat_of_int size1)))`;



(*val MEMval                 : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> 'b -> State_monad.monadS 'regval unit 'e*)
(*val MEMval_conditional     : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> 'b -> State_monad.monadS 'regval bool 'e*)
(*val MEMval_tag             : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> bool -> 'b -> State_monad.monadS 'regval unit 'e*)
(*val MEMval_tag_conditional : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> Num.integer -> bool -> 'b -> State_monad.monadS 'regval bool 'e*)

val _ = Define `
 ((MEMval:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int -> 'b ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b _ size1 v=                       (bindS (write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\b .  (case (b ) of ( _ ) => returnS ()  ))))`;

val _ = Define `
 ((MEMval_conditional:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int -> 'b ->('regval,(bool),'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b _ size1 v=           (bindS (write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\ b .  returnS (if b then T else F))))`;

val _ = Define `
 ((MEMval_tag:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int -> bool -> 'b ->('regval,(unit),'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1 t v=              (bindS (write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\b .  (case (b ) of
            ( _ ) => bindS
                       (write_tag_bool dict_Sail_values_Bitvector_a addr t)
                       (\u .  (case (u ) of ( _ ) => returnS ()  ))
        ))))`;

val _ = Define `
 ((MEMval_tag_conditional:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int -> bool -> 'b ->('regval,(bool),'e)state_monad$monadS)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1 t v=  (bindS (write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\ b .  bindS (write_tag_bool 
  dict_Sail_values_Bitvector_a addr t) (\u .  (case (u ) of ( _ ) => returnS (if b then T else F) )))))`;


(*val MEM_sync  : forall 'regval 'e. unit -> State_monad.monadS 'regval unit 'e*)

val _ = Define `
 ((MEM_sync:unit -> 'regval state_monad$sequential_state ->(((unit),'e)state_monad$result#'regval state_monad$sequential_state)set) () =  (returnS () ))`;
  (*barrier Barrier_MIPS_SYNC*)

(* Some wrappers copied from aarch64_extras *)
(* TODO: Harmonise into a common library *)

val _ = Define `
 ((get_slice_int_bl:int -> int -> int ->(bool)list) len n lo=  
( 
  (* TODO: Is this the intended behaviour? *)let hi = ((lo + len) -( 1 : int)) in
  let bs = (bools_of_int (hi +( 1 : int)) n) in
  subrange_list F bs hi lo))`;


(*val get_slice_int : forall 'a. Bitvector 'a => Num.integer -> Num.integer -> Num.integer -> 'a*)
val _ = Define `
 ((get_slice_int:'a sail_values$Bitvector_class -> int -> int -> int -> 'a)dict_Sail_values_Bitvector_a len n lo=  (
  dict_Sail_values_Bitvector_a.of_bools_method (get_slice_int_bl len n lo)))`;


val _ = Define `
 ((write_ram:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'e -> int -> 'f -> 'b -> 'a -> 'd state_monad$sequential_state ->(((unit),'c)state_monad$result#'d state_monad$sequential_state)set)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b _ size1 _ addr data=  (seqS  
(MEMea dict_Sail_values_Bitvector_b addr size1)  
(MEMval dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_a addr size1 data)))`;


val _ = Define `
 ((read_ram:'a sail_values$Bitvector_class -> 'c sail_values$Bitvector_class -> 'e -> int -> 'f -> 'a -> 'd state_monad$sequential_state ->(('c,'b)state_monad$result#'d state_monad$sequential_state)set)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_c _ size1 _ addr=  (MEMr 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_c addr size1))`;


val _ = Define `
 ((string_of_bits:'a sail_values$Bitvector_class -> 'a -> string)dict_Sail_values_Bitvector_a bs=  (string_of_bv 
  (instance_Sail_values_Bitvector_list_dict
     instance_Sail_values_BitU_Sail_values_bitU_dict) (dict_Sail_values_Bitvector_a.bits_of_method bs)))`;

val _ = Define `
 ((string_of_int:'a lem_show$Show_class -> 'a -> string)dict_Show_Show_a= 
  (dict_Show_Show_a.show_method))`;


val _ = Define `
 ((sign_extend0:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int -> 'b)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b bits len=  (maybe_failwith (
  dict_Sail_values_Bitvector_b.of_bits_method (exts_bv dict_Sail_values_Bitvector_a len bits))))`;

val _ = Define `
 ((zero_extend0:'a sail_values$Bitvector_class -> 'b sail_values$Bitvector_class -> 'a -> int -> 'b)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b bits len=  (maybe_failwith (
  dict_Sail_values_Bitvector_b.of_bits_method (extz_bv dict_Sail_values_Bitvector_a len bits))))`;


val _ = Define `
 ((shift_bits_left:'b sail_values$Bitvector_class -> 'd sail_values$Bitvector_class -> 'e sail_values$Bitvector_class -> 'd -> 'e -> 'c state_monad$sequential_state ->(('b,'a)state_monad$result#'c state_monad$sequential_state)set)dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_d dict_Sail_values_Bitvector_e v n=  
 (let r = (OPTION_BIND (
  dict_Sail_values_Bitvector_e.unsigned_method n) (\ n .  dict_Sail_values_Bitvector_b.of_bits_method (shiftl_bv dict_Sail_values_Bitvector_d v n))) in
  maybe_failS "shift_bits_left" r))`;

val _ = Define `
 ((shift_bits_right:'b sail_values$Bitvector_class -> 'd sail_values$Bitvector_class -> 'e sail_values$Bitvector_class -> 'd -> 'e -> 'c state_monad$sequential_state ->(('b,'a)state_monad$result#'c state_monad$sequential_state)set)dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_d dict_Sail_values_Bitvector_e v n=  
 (let r = (OPTION_BIND (
  dict_Sail_values_Bitvector_e.unsigned_method n) (\ n .  dict_Sail_values_Bitvector_b.of_bits_method (shiftr_bv dict_Sail_values_Bitvector_d v n))) in
  maybe_failS "shift_bits_right" r))`;

val _ = Define `
 ((shift_bits_right_arith:'b sail_values$Bitvector_class -> 'd sail_values$Bitvector_class -> 'e sail_values$Bitvector_class -> 'd -> 'e -> 'c state_monad$sequential_state ->(('b,'a)state_monad$result#'c state_monad$sequential_state)set)dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_d dict_Sail_values_Bitvector_e v n=  
 (let r = (OPTION_BIND (
  dict_Sail_values_Bitvector_e.unsigned_method n) (\ n .  dict_Sail_values_Bitvector_b.of_bits_method (arith_shiftr_bv dict_Sail_values_Bitvector_d v n))) in
  maybe_failS "shift_bits_right_arith" r))`;


(* Use constants for undefined values for now *)
val _ = Define `
 ((internal_pick:'a list -> 'c state_monad$sequential_state ->(('a,'b)state_monad$result#'c state_monad$sequential_state)set) vs=  (returnS (HD vs)))`;

val _ = Define `
 ((undefined_bool0:unit ->('c,(bool),'a)state_monad$monadS)=  undefined_boolS)`;

val _ = Define `
 ((undefined_string:unit -> 'b state_monad$sequential_state ->(((string),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS ""))`;

val _ = Define `
 ((undefined_unit:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS () ))`;

val _ = Define `
 ((undefined_int:unit -> 'b state_monad$sequential_state ->(((int),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS (( 0 : int):sail_values$ii)))`;

(*val undefined_vector : forall 'rv 'a 'e. Num.integer -> 'a -> State_monad.monadS 'rv (list 'a) 'e*)
val _ = Define `
 ((undefined_vector:int -> 'a -> 'rv state_monad$sequential_state ->((('a list),'e)state_monad$result#'rv state_monad$sequential_state)set) len u=  (returnS (repeat [u] len)))`;

(*val undefined_bitvector : forall 'rv 'a 'e. Bitvector 'a => Num.integer -> State_monad.monadS 'rv 'a 'e*)
val _ = Define `
 ((undefined_bitvector:'a sail_values$Bitvector_class -> int ->('rv,'a,'e)state_monad$monadS)dict_Sail_values_Bitvector_a len=  (returnS (
  dict_Sail_values_Bitvector_a.of_bools_method (repeat [F] len))))`;

(*val undefined_bits : forall 'rv 'a 'e. Bitvector 'a => Num.integer -> State_monad.monadS 'rv 'a 'e*)
val _ = Define `
 ((undefined_bits:'a sail_values$Bitvector_class -> int ->('rv,'a,'e)state_monad$monadS)dict_Sail_values_Bitvector_a= 
  (undefined_bitvector dict_Sail_values_Bitvector_a))`;

val _ = Define `
 ((undefined_bit:unit -> 'b state_monad$sequential_state ->(((sail_values$bitU),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS B0))`;

val _ = Define `
 ((undefined_real:unit -> 'b state_monad$sequential_state ->(((real),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS (realFromFrac(( 0 : int))(( 1 : int)))))`;

val _ = Define `
 ((undefined_range:'a -> 'd -> 'c state_monad$sequential_state ->(('a,'b)state_monad$result#'c state_monad$sequential_state)set) i j=  (returnS i))`;

val _ = Define `
 ((undefined_atom:'a -> 'c state_monad$sequential_state ->(('a,'b)state_monad$result#'c state_monad$sequential_state)set) i=  (returnS i))`;

val _ = Define `
 ((undefined_nat:unit -> 'b state_monad$sequential_state ->(((int),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS (( 0 : int):sail_values$ii)))`;


val _ = Define `
 ((skip:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (returnS () ))`;

val _ = export_theory()

