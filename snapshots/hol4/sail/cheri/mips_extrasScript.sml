(*Generated by Lem from /usr/local/google/home/ramanakumar/cheri/sail/mips/mips_extras.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory sail_instr_kindsTheory sail_valuesTheory prompt_monadTheory promptTheory sail_operatorsTheory;

val _ = numLib.prefer_num();



val _ = new_theory "mips_extras"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators*)
(*open import Prompt_monad*)
(*open import Prompt*)

(*val MEMr             : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> monad 'regval 'b 'e*)
(*val MEMr_reserve     : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> monad 'regval 'b 'e*)
(*val MEMr_tag         : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> monad 'regval (bool * 'b) 'e*)
(*val MEMr_tag_reserve : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> monad 'regval (bool * 'b) 'e*)

val _ = Define `
 ((MEMr:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int ->('regval,'b,'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=              (state_monad$read_memS 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_plain addr size1))`;

val _ = Define `
 ((MEMr_reserve:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int ->('regval,'b,'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=      (state_monad$read_memS 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_reserve addr size1))`;


(*val read_tag_bool : forall 'regval 'a 'e. Bitvector 'a => 'a -> monad 'regval bool 'e*)
val _ = Define `
 ((read_tag_bool:'a Bitvector_class -> 'a ->('regval,(bool),'e)monad)dict_Sail_values_Bitvector_a addr=  (state_monad$bindS
  (state_monad$read_tagS 
  dict_Sail_values_Bitvector_a addr) (\ t . 
  state_monad$maybe_failS "read_tag_bool" (bool_of_bitU t))))`;


(*val write_tag_bool : forall 'regval 'a 'e. Bitvector 'a => 'a -> bool -> monad 'regval unit 'e*)
val _ = Define `
 ((write_tag_bool:'a Bitvector_class -> 'a -> bool ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a addr t=  (state_monad$bindS (state_monad$write_tagS 
  dict_Sail_values_Bitvector_a addr (bitU_of_bool t)) 
  (\b .  (case (b ) of ( _ ) => state_monad$returnS ()  ))))`;


val _ = Define `
 ((MEMr_tag:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int ->('regval,(bool#'b),'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=  (state_monad$bindS
  (state_monad$read_memS 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_plain addr size1) (\ v .  state_monad$bindS
  (read_tag_bool dict_Sail_values_Bitvector_a addr) (\ t . 
  state_monad$returnS (t, v)))))`;


val _ = Define `
 ((MEMr_tag_reserve:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int ->('regval,(bool#'b),'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1=  (state_monad$bindS
  (state_monad$read_memS 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b Read_plain addr size1) (\ v .  state_monad$bindS
  (read_tag_bool dict_Sail_values_Bitvector_a addr) (\ t . 
  state_monad$returnS (t, v)))))`;



(*val MEMea                 : forall 'regval 'a 'e. Bitvector 'a => 'a -> integer -> monad 'regval unit 'e*)
(*val MEMea_conditional     : forall 'regval 'a 'e. Bitvector 'a => 'a -> integer -> monad 'regval unit 'e*)
(*val MEMea_tag             : forall 'regval 'a 'e. Bitvector 'a => 'a -> integer -> monad 'regval unit 'e*)
(*val MEMea_tag_conditional : forall 'regval 'a 'e. Bitvector 'a => 'a -> integer -> monad 'regval unit 'e*)

val _ = Define `
 ((MEMea:'a Bitvector_class -> 'a -> int ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a addr size1=                  (state_monad$write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_plain addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_conditional:'a Bitvector_class -> 'a -> int ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a addr size1=      (state_monad$write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_conditional addr (nat_of_int size1)))`;


val _ = Define `
 ((MEMea_tag:'a Bitvector_class -> 'a -> int ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a addr size1=              (state_monad$write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_plain addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_tag_conditional:'a Bitvector_class -> 'a -> int ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a addr size1=  (state_monad$write_mem_eaS 
  dict_Sail_values_Bitvector_a Write_conditional addr (nat_of_int size1)))`;



(*val MEMval                 : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> 'b -> monad 'regval unit 'e*)
(*val MEMval_conditional     : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> 'b -> monad 'regval bool 'e*)
(*val MEMval_tag             : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> bool -> 'b -> monad 'regval unit 'e*)
(*val MEMval_tag_conditional : forall 'regval 'a 'b 'e. Bitvector 'a, Bitvector 'b => 'a -> integer -> bool -> 'b -> monad 'regval bool 'e*)

val _ = Define `
 ((MEMval:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int -> 'b ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b _ size1 v=                       (state_monad$bindS (state_monad$write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\b .  (case (b ) of ( _ ) => state_monad$returnS ()  ))))`;

val _ = Define `
 ((MEMval_conditional:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int -> 'b ->('regval,(bool),'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b _ size1 v=           (state_monad$bindS (state_monad$write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\ b .  state_monad$returnS (if b then T else F))))`;

val _ = Define `
 ((MEMval_tag:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int -> bool -> 'b ->('regval,(unit),'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1 t v=              (state_monad$bindS (state_monad$write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\b .  (case (b ) of
            ( _ ) => state_monad$bindS
                       (write_tag_bool dict_Sail_values_Bitvector_a addr t)
                       (\u .  (case (u ) of
                                  ( _ ) => state_monad$returnS () 
                              ))
        ))))`;

val _ = Define `
 ((MEMval_tag_conditional:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int -> bool -> 'b ->('regval,(bool),'e)monad)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b addr size1 t v=  (state_monad$bindS (state_monad$write_mem_valS 
  dict_Sail_values_Bitvector_b v) (\ b .  state_monad$bindS (write_tag_bool 
  dict_Sail_values_Bitvector_a addr t) (\u .  (case (u ) of ( _ ) => state_monad$returnS (if b then T else F) )))))`;


(*val MEM_sync  : forall 'regval 'e. unit -> monad 'regval unit 'e*)

val _ = Define `
 ((MEM_sync:unit -> 'regval state_monad$sequential_state ->(((unit),'e)state_monad$result#'regval state_monad$sequential_state)set) () =  (barrier Barrier_MIPS_SYNC))`;


(* Some wrappers copied from aarch64_extras *)
(* TODO: Harmonise into a common library *)

val _ = Define `
 ((get_slice_int_bl:int -> int -> int ->(bool)list) len n lo=
   (
  (* TODO: Is this the intended behaviour? *)let hi = ((lo + len) -( 1 : int)) in
  let bs = (bools_of_int (hi +( 1 : int)) n) in
  subrange_list F bs hi lo))`;


(*val get_slice_int : forall 'a. Bitvector 'a => integer -> integer -> integer -> 'a*)
val _ = Define `
 ((get_slice_int0:'a Bitvector_class -> int -> int -> int -> 'a)dict_Sail_values_Bitvector_a len n lo=  (
  dict_Sail_values_Bitvector_a.of_bools_method (get_slice_int_bl len n lo)))`;


val _ = Define `
 ((write_ram:'a Bitvector_class -> 'b Bitvector_class -> 'e -> int -> 'f -> 'b -> 'a -> 'd state_monad$sequential_state ->(((unit),'c)state_monad$result#'d state_monad$sequential_state)set)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b _ size1 _ addr data=  (state_monad$seqS
  (MEMea dict_Sail_values_Bitvector_b addr size1)
  (MEMval dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_a addr size1 data)))`;


val _ = Define `
 ((read_ram:'a Bitvector_class -> 'c Bitvector_class -> 'e -> int -> 'f -> 'a -> 'd state_monad$sequential_state ->(('c,'b)state_monad$result#'d state_monad$sequential_state)set)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_c _ size1 _ addr=  (MEMr 
  dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_c addr size1))`;


val _ = Define `
 ((string_of_bits:'a Bitvector_class -> 'a -> string)dict_Sail_values_Bitvector_a bs=  (string_of_bv 
  (instance_Sail_values_Bitvector_list_dict
     instance_Sail_values_BitU_Sail_values_bitU_dict) (dict_Sail_values_Bitvector_a.bits_of_method bs)))`;

val _ = Define `
 ((string_of_int:'a Show_class -> 'a -> string)dict_Show_Show_a= 
  (dict_Show_Show_a.show_method))`;


val _ = Define `
 ((sign_extend0:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int -> 'b)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b bits len=  (maybe_failwith (
  dict_Sail_values_Bitvector_b.of_bits_method (exts_bv dict_Sail_values_Bitvector_a len bits))))`;

val _ = Define `
 ((zero_extend0:'a Bitvector_class -> 'b Bitvector_class -> 'a -> int -> 'b)dict_Sail_values_Bitvector_a dict_Sail_values_Bitvector_b bits len=  (maybe_failwith (
  dict_Sail_values_Bitvector_b.of_bits_method (extz_bv dict_Sail_values_Bitvector_a len bits))))`;


val _ = Define `
 ((shift_bits_left:'b Bitvector_class -> 'd Bitvector_class -> 'e Bitvector_class -> 'd -> 'e -> 'a state_monad$sequential_state ->(('b,'c)state_monad$result#'a state_monad$sequential_state)set)dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_d dict_Sail_values_Bitvector_e v n=
   (let r = (OPTION_BIND (
  dict_Sail_values_Bitvector_e.unsigned_method n) (\ n .  dict_Sail_values_Bitvector_b.of_bits_method (shiftl_bv dict_Sail_values_Bitvector_d v n))) in
  state_monad$maybe_failS "shift_bits_left" r))`;

val _ = Define `
 ((shift_bits_right:'b Bitvector_class -> 'd Bitvector_class -> 'e Bitvector_class -> 'd -> 'e -> 'a state_monad$sequential_state ->(('b,'c)state_monad$result#'a state_monad$sequential_state)set)dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_d dict_Sail_values_Bitvector_e v n=
   (let r = (OPTION_BIND (
  dict_Sail_values_Bitvector_e.unsigned_method n) (\ n .  dict_Sail_values_Bitvector_b.of_bits_method (shiftr_bv dict_Sail_values_Bitvector_d v n))) in
  state_monad$maybe_failS "shift_bits_right" r))`;

val _ = Define `
 ((shift_bits_right_arith:'b Bitvector_class -> 'd Bitvector_class -> 'e Bitvector_class -> 'd -> 'e -> 'a state_monad$sequential_state ->(('b,'c)state_monad$result#'a state_monad$sequential_state)set)dict_Sail_values_Bitvector_b dict_Sail_values_Bitvector_d dict_Sail_values_Bitvector_e v n=
   (let r = (OPTION_BIND (
  dict_Sail_values_Bitvector_e.unsigned_method n) (\ n .  dict_Sail_values_Bitvector_b.of_bits_method (arith_shiftr_bv dict_Sail_values_Bitvector_d v n))) in
  state_monad$maybe_failS "shift_bits_right_arith" r))`;


(* Use constants for undefined values for now *)
val _ = Define `
 ((internal_pick:'a list -> 'b state_monad$sequential_state ->(('a,'c)state_monad$result#'b state_monad$sequential_state)set) vs=  (state_monad$returnS (HD vs)))`;

val _ = Define `
 ((undefined_string:unit -> 'a state_monad$sequential_state ->(((string),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS ""))`;

val _ = Define `
 ((undefined_unit:unit -> 'a state_monad$sequential_state ->(((unit),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS () ))`;

val _ = Define `
 ((undefined_int:unit -> 'a state_monad$sequential_state ->(((int),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS (( 0 : int):ii)))`;

(*val undefined_vector : forall 'rv 'a 'e. integer -> 'a -> monad 'rv (list 'a) 'e*)
val _ = Define `
 ((undefined_vector:int -> 'a -> 'rv state_monad$sequential_state ->((('a list),'e)state_monad$result#'rv state_monad$sequential_state)set) len u=  (state_monad$returnS (repeat [u] len)))`;

(*val undefined_bitvector : forall 'rv 'a 'e. Bitvector 'a => integer -> monad 'rv 'a 'e*)
val _ = Define `
 ((undefined_bitvector:'a Bitvector_class -> int ->('rv,'a,'e)monad)dict_Sail_values_Bitvector_a len=  (state_monad$returnS (
  dict_Sail_values_Bitvector_a.of_bools_method (repeat [F] len))))`;

(*val undefined_bits : forall 'rv 'a 'e. Bitvector 'a => integer -> monad 'rv 'a 'e*)
val _ = Define `
 ((undefined_bits:'a Bitvector_class -> int ->('rv,'a,'e)monad)dict_Sail_values_Bitvector_a= 
  (undefined_bitvector dict_Sail_values_Bitvector_a))`;

val _ = Define `
 ((undefined_bit:unit -> 'a state_monad$sequential_state ->(((bitU),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS B0))`;

val _ = Define `
 ((undefined_real:unit -> 'a state_monad$sequential_state ->(((real),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS (realFromFrac(( 0 : int))(( 1 : int)))))`;

val _ = Define `
 ((undefined_range:'a -> 'd -> 'b state_monad$sequential_state ->(('a,'c)state_monad$result#'b state_monad$sequential_state)set) i j=  (state_monad$returnS i))`;

val _ = Define `
 ((undefined_atom:'a -> 'b state_monad$sequential_state ->(('a,'c)state_monad$result#'b state_monad$sequential_state)set) i=  (state_monad$returnS i))`;

val _ = Define `
 ((undefined_nat:unit -> 'a state_monad$sequential_state ->(((int),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS (( 0 : int):ii)))`;


val _ = Define `
 ((skip:unit -> 'a state_monad$sequential_state ->(((unit),'b)state_monad$result#'a state_monad$sequential_state)set) () =  (state_monad$returnS () ))`;


(*val elf_entry : unit -> integer*)
val _ = Define `
 ((elf_entry:unit -> int) () = (( 0 : int)))`;


val _ = Define `
 ((print_bits:'a Bitvector_class -> string -> 'a -> unit)dict_Sail_values_Bitvector_a msg bs=  (prerr_endline ( STRCAT msg (string_of_bits 
  dict_Sail_values_Bitvector_a bs))))`;


(*val get_time_ns : unit -> integer*)
val _ = Define `
 ((get_time_ns:unit -> int) () = (( 0 : int)))`;

val _ = export_theory()

