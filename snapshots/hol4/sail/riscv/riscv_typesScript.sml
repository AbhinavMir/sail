(*Generated by Lem from riscv_types.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory sail_instr_kindsTheory sail_valuesTheory sail_operators_mwordsTheory prompt_monadTheory promptTheory;

val _ = numLib.prefer_num();



val _ = new_theory "riscv_types"

(*Generated by Sail from riscv.*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators_mwords*)
(*open import Prompt_monad*)
(*open import Prompt*)
val _ = type_abbrev((*  'n *) "bits" , ``:  'n words$word``);



val _ = type_abbrev( "xlenbits"  , ``: 64 bits``);

val _ = type_abbrev( "half"  , ``: 16 bits``);

val _ = type_abbrev( "word"  , ``: 32 bits``);

val _ = type_abbrev((*  'n *) "regno"  , ``: int``);

val _ = type_abbrev( "regbits"  , ``: 5 bits``);

val _ = type_abbrev( "cregbits"  , ``: 3 bits``);

val _ = type_abbrev( "csreg"  , ``: 12 bits``);

val _ = type_abbrev( "opcode"  , ``: 7 bits``);

val _ = type_abbrev( "imm12"  , ``: 12 bits``);

val _ = type_abbrev( "imm20"  , ``: 20 bits``);

val _ = type_abbrev( "amo"  , ``: 1 bits``);

val _ = Hol_datatype `
 Architecture = RV32 | RV64 | RV128`;




val _ = type_abbrev( "arch_xlen"  , ``: 2 bits``);

val _ = type_abbrev( "priv_level"  , ``: 2 bits``);

val _ = Hol_datatype `
 Privilege = User | Supervisor | Machine`;




val _ = Hol_datatype `
 AccessType = Read | Write | ReadWrite | Execute`;




val _ = Hol_datatype `
 ReadType = Instruction | Data`;




val _ = type_abbrev( "exc_code"  , ``: 4 bits``);

val _ = Hol_datatype `
 ExceptionType =
  E_Fetch_Addr_Align
  | E_Fetch_Access_Fault
  | E_Illegal_Instr
  | E_Breakpoint
  | E_Load_Addr_Align
  | E_Load_Access_Fault
  | E_SAMO_Addr_Align
  | E_SAMO_Access_Fault
  | E_U_EnvCall
  | E_S_EnvCall
  | E_Reserved_10
  | E_M_EnvCall
  | E_Fetch_Page_Fault
  | E_Load_Page_Fault
  | E_Reserved_14
  | E_SAMO_Page_Fault`;




val _ = Hol_datatype `
 InterruptType =
  I_U_Software
  | I_S_Software
  | I_M_Software
  | I_U_Timer
  | I_S_Timer
  | I_M_Timer
  | I_U_External
  | I_S_External
  | I_M_External`;




val _ = type_abbrev( "tv_mode"  , ``: 2 bits``);

val _ = Hol_datatype `
 TrapVectorMode = TV_Direct | TV_Vector | TV_Reserved`;




val _ = Hol_datatype `
 exception  =   Error_not_implemented of (string) | Error_internal_error of (unit)`;




val _ = type_abbrev( "ext_status"  , ``: 2 bits``);

val _ = Hol_datatype `
 ExtStatus = Off | Initial | Clean | Dirty`;




val _ = type_abbrev( "satp_mode"  , ``: 4 bits``);

val _ = Hol_datatype `
 SATPMode = Sbare | Sv32 | Sv39`;




val _ = type_abbrev( "csrRW"  , ``: 2 bits``);

val _ = Hol_datatype `
 uop = RISCV_LUI | RISCV_AUIPC`;




val _ = Hol_datatype `
 bop = RISCV_BEQ | RISCV_BNE | RISCV_BLT | RISCV_BGE | RISCV_BLTU | RISCV_BGEU`;




val _ = Hol_datatype `
 iop = RISCV_ADDI | RISCV_SLTI | RISCV_SLTIU | RISCV_XORI | RISCV_ORI | RISCV_ANDI`;




val _ = Hol_datatype `
 sop = RISCV_SLLI | RISCV_SRLI | RISCV_SRAI`;




val _ = Hol_datatype `
 rop =
  RISCV_ADD
  | RISCV_SUB
  | RISCV_SLL
  | RISCV_SLT
  | RISCV_SLTU
  | RISCV_XOR
  | RISCV_SRL
  | RISCV_SRA
  | RISCV_OR
  | RISCV_AND`;




val _ = Hol_datatype `
 ropw = RISCV_ADDW | RISCV_SUBW | RISCV_SLLW | RISCV_SRLW | RISCV_SRAW`;




val _ = Hol_datatype `
 amoop = AMOSWAP | AMOADD | AMOXOR | AMOAND | AMOOR | AMOMIN | AMOMAX | AMOMINU | AMOMAXU`;




val _ = Hol_datatype `
 csrop = CSRRW | CSRRS | CSRRC`;




val _ = Hol_datatype `
 word_width = BYTE | HALF | WORD | DOUBLE`;




val _ = Hol_datatype `
 MemoryOpResult =   MemValue of ('a) | MemException of (ExceptionType)`;




val _ = Hol_datatype `
 Misa  =   Mk_Misa of ( 64 words$word)`;




val _ = Hol_datatype `
 SV39_PTE  =   Mk_SV39_PTE of ( 64 words$word)`;




val _ = Hol_datatype `
 PTE_Bits  =   Mk_PTE_Bits of ( 8 words$word)`;




val _ = Hol_datatype `
 Mstatus  =   Mk_Mstatus of ( 64 words$word)`;




val _ = Hol_datatype `
 Sstatus  =   Mk_Sstatus of ( 64 words$word)`;




val _ = Hol_datatype `
 Minterrupts  =   Mk_Minterrupts of ( 64 words$word)`;




val _ = Hol_datatype `
 Sinterrupts  =   Mk_Sinterrupts of ( 64 words$word)`;




val _ = Hol_datatype `
 Medeleg  =   Mk_Medeleg of ( 64 words$word)`;




val _ = Hol_datatype `
 Sedeleg  =   Mk_Sedeleg of ( 64 words$word)`;




val _ = Hol_datatype `
 Mtvec  =   Mk_Mtvec of ( 64 words$word)`;




val _ = Hol_datatype `
 Satp64  =   Mk_Satp64 of ( 64 words$word)`;




val _ = Hol_datatype `
 Mcause  =   Mk_Mcause of ( 64 words$word)`;




val _ = Hol_datatype `
 sync_exception  =
  <| sync_exception_trap : ExceptionType; sync_exception_excinfo :  xlenbits option  |>`;



val _ = Hol_datatype `
 ctl_result  =   CTL_TRAP of (sync_exception) | CTL_SRET of (unit) | CTL_MRET of (unit)`;




val _ = type_abbrev( "pteAttribs"  , ``: 8 bits``);

val _ = Hol_datatype `
 PTW_Error = PTW_Access | PTW_Invalid_PTE | PTW_No_Permission | PTW_Misaligned | PTW_PTE_Update`;




val _ = type_abbrev( "vaddr39"  , ``: 39 bits``);

val _ = type_abbrev( "paddr39"  , ``: 56 bits``);

val _ = type_abbrev( "pte39"  , ``: xlenbits``);

val _ = Hol_datatype `
 SV39_Vaddr  =   Mk_SV39_Vaddr of ( 39 words$word)`;




val _ = Hol_datatype `
 SV39_Paddr  =   Mk_SV39_Paddr of ( 56 words$word)`;




val _ = type_abbrev( "asid64"  , ``: 16 bits``);

val _ = Hol_datatype `
 PTW_Result  =
    PTW_Success of ((paddr39 # SV39_PTE # paddr39 # ii # bool)) | PTW_Failure of (PTW_Error)`;




val _ = Hol_datatype `
 TLB39_Entry  =
  <| TLB39_Entry_asid : asid64;
     TLB39_Entry_global : bool;
     TLB39_Entry_vAddr : vaddr39;
     TLB39_Entry_pAddr : paddr39;
     TLB39_Entry_vMatchMask : vaddr39;
     TLB39_Entry_vAddrMask : vaddr39;
     TLB39_Entry_pte : SV39_PTE;
     TLB39_Entry_pteAddr : paddr39;
     TLB39_Entry_age : xlenbits  |>`;



val _ = Hol_datatype `
 TR39_Result  =   TR39_Address of (paddr39) | TR39_Failure of (PTW_Error)`;




val _ = Hol_datatype `
 TR_Result  =   TR_Address of (xlenbits) | TR_Failure of (ExceptionType)`;




val _ = Hol_datatype `
 ast  =
    UTYPE of (( 20 bits # regbits # uop))
  | RISCV_JAL of (( 21 bits # regbits))
  | RISCV_JALR of (( 12 bits # regbits # regbits))
  | BTYPE of (( 13 bits # regbits # regbits # bop))
  | ITYPE of (( 12 bits # regbits # regbits # iop))
  | SHIFTIOP of (( 6 bits # regbits # regbits # sop))
  | RTYPE of ((regbits # regbits # regbits # rop))
  | LOAD of (( 12 bits # regbits # regbits # bool # word_width # bool # bool))
  | STORE of (( 12 bits # regbits # regbits # word_width # bool # bool))
  | ADDIW of (( 12 bits # regbits # regbits))
  | SHIFTW of (( 5 bits # regbits # regbits # sop))
  | RTYPEW of ((regbits # regbits # regbits # ropw))
  | MUL of ((regbits # regbits # regbits # bool # bool # bool))
  | DIV0 of ((regbits # regbits # regbits # bool))
  | REM of ((regbits # regbits # regbits # bool))
  | MULW of ((regbits # regbits # regbits))
  | DIVW of ((regbits # regbits # regbits # bool))
  | REMW of ((regbits # regbits # regbits # bool))
  | FENCE of (( 4 bits # 4 bits))
  | FENCEI of (unit)
  | ECALL of (unit)
  | MRET of (unit)
  | SRET of (unit)
  | EBREAK of (unit)
  | WFI of (unit)
  | SFENCE_VMA of ((regbits # regbits))
  | LOADRES of ((bool # bool # regbits # word_width # regbits))
  | STORECON of ((bool # bool # regbits # regbits # word_width # regbits))
  | AMO of ((amoop # bool # bool # regbits # regbits # word_width # regbits))
  | CSR of (( 12 bits # regbits # regbits # bool # csrop))
  | NOP of (unit)
  | ILLEGAL of (unit)
  | C_ADDI4SPN of ((cregbits # 8 bits))
  | C_LW of (( 5 bits # cregbits # cregbits))
  | C_LD of (( 5 bits # cregbits # cregbits))
  | C_SW of (( 5 bits # cregbits # cregbits))
  | C_SD of (( 5 bits # cregbits # cregbits))
  | C_ADDI of (( 6 bits # regbits))
  | C_JAL of ( 11 bits)
  | C_ADDIW of (( 6 bits # regbits))
  | C_LI of (( 6 bits # regbits))
  | C_ADDI16SP of ( 6 bits)
  | C_LUI of (( 6 bits # regbits))
  | C_SRLI of (( 6 bits # cregbits))
  | C_SRAI of (( 6 bits # cregbits))
  | C_ANDI of (( 6 bits # cregbits))
  | C_SUB of ((cregbits # cregbits))
  | C_XOR of ((cregbits # cregbits))
  | C_OR of ((cregbits # cregbits))
  | C_AND of ((cregbits # cregbits))
  | C_SUBW of ((cregbits # cregbits))
  | C_ADDW of ((cregbits # cregbits))
  | C_J of ( 11 bits)
  | C_BEQZ of (( 8 bits # cregbits))
  | C_BNEZ of (( 8 bits # cregbits))
  | C_SLLI of (( 6 bits # regbits))
  | C_LWSP of (( 6 bits # regbits))
  | C_LDSP of (( 6 bits # regbits))
  | C_SWSP of (( 6 bits # regbits))
  | C_SDSP of (( 6 bits # regbits))
  | C_JR of (regbits)
  | C_JALR of (regbits)
  | C_MV of ((regbits # regbits))
  | C_ADD of ((regbits # regbits))`;




val _ = Hol_datatype `
 FetchResult  =   F_Base of (word) | F_RVC of (half) | F_Error of ((ExceptionType # xlenbits))`;




val _ = Hol_datatype `
 register_value  =
    Regval_vector of ((ii # bool # register_value list))
  | Regval_list of ( register_value list)
  | Regval_option of ( register_value option)
  | Regval_Mcause of (Mcause)
  | Regval_Medeleg of (Medeleg)
  | Regval_Minterrupts of (Minterrupts)
  | Regval_Misa of (Misa)
  | Regval_Mstatus of (Mstatus)
  | Regval_Mtvec of (Mtvec)
  | Regval_Privilege of (Privilege)
  | Regval_Sedeleg of (Sedeleg)
  | Regval_Sinterrupts of (Sinterrupts)
  | Regval_TLB39_Entry of (TLB39_Entry)
  | Regval_vector_64_dec_bit of ( 64 words$word)`;




val _ = Hol_datatype `
 regstate  =
  <| tlb39 :  TLB39_Entry option;
     tselect :  64 words$word;
     stval :  64 words$word;
     scause : Mcause;
     sepc :  64 words$word;
     sscratch :  64 words$word;
     stvec : Mtvec;
     satp :  64 words$word;
     sideleg : Sinterrupts;
     sedeleg : Sedeleg;
     pmpcfg0 :  64 words$word;
     pmpaddr0 :  64 words$word;
     mhartid :  64 words$word;
     marchid :  64 words$word;
     mimpid :  64 words$word;
     mvendorid :  64 words$word;
     minstret :  64 words$word;
     mtime :  64 words$word;
     mcycle :  64 words$word;
     mscratch :  64 words$word;
     mtval :  64 words$word;
     mepc :  64 words$word;
     mcause : Mcause;
     mtvec : Mtvec;
     medeleg : Medeleg;
     mideleg : Minterrupts;
     mie : Minterrupts;
     mip : Minterrupts;
     mstatus : Mstatus;
     misa : Misa;
     cur_inst :  64 words$word;
     cur_privilege : Privilege;
     Xs : ( 64 words$word) list;
     nextPC :  64 words$word;
     PC :  64 words$word  |>`;





(*val Mcause_of_regval : register_value -> maybe Mcause*)

val _ = Define `
 ((Mcause_of_regval:register_value ->(Mcause)option) merge_var=
    ((case merge_var of   Regval_Mcause (v) => SOME v | g__92 => NONE )))`;


(*val regval_of_Mcause : Mcause -> register_value*)

val _ = Define `
 ((regval_of_Mcause:Mcause -> register_value) v=  (Regval_Mcause v))`;


(*val Medeleg_of_regval : register_value -> maybe Medeleg*)

val _ = Define `
 ((Medeleg_of_regval:register_value ->(Medeleg)option) merge_var=
    ((case merge_var of   Regval_Medeleg (v) => SOME v | g__91 => NONE )))`;


(*val regval_of_Medeleg : Medeleg -> register_value*)

val _ = Define `
 ((regval_of_Medeleg:Medeleg -> register_value) v=  (Regval_Medeleg v))`;


(*val Minterrupts_of_regval : register_value -> maybe Minterrupts*)

val _ = Define `
 ((Minterrupts_of_regval:register_value ->(Minterrupts)option) merge_var=
    ((case merge_var of   Regval_Minterrupts (v) => SOME v | g__90 => NONE )))`;


(*val regval_of_Minterrupts : Minterrupts -> register_value*)

val _ = Define `
 ((regval_of_Minterrupts:Minterrupts -> register_value) v=  (Regval_Minterrupts v))`;


(*val Misa_of_regval : register_value -> maybe Misa*)

val _ = Define `
 ((Misa_of_regval:register_value ->(Misa)option) merge_var=
    ((case merge_var of   Regval_Misa (v) => SOME v | g__89 => NONE )))`;


(*val regval_of_Misa : Misa -> register_value*)

val _ = Define `
 ((regval_of_Misa:Misa -> register_value) v=  (Regval_Misa v))`;


(*val Mstatus_of_regval : register_value -> maybe Mstatus*)

val _ = Define `
 ((Mstatus_of_regval:register_value ->(Mstatus)option) merge_var=
    ((case merge_var of   Regval_Mstatus (v) => SOME v | g__88 => NONE )))`;


(*val regval_of_Mstatus : Mstatus -> register_value*)

val _ = Define `
 ((regval_of_Mstatus:Mstatus -> register_value) v=  (Regval_Mstatus v))`;


(*val Mtvec_of_regval : register_value -> maybe Mtvec*)

val _ = Define `
 ((Mtvec_of_regval:register_value ->(Mtvec)option) merge_var=
    ((case merge_var of   Regval_Mtvec (v) => SOME v | g__87 => NONE )))`;


(*val regval_of_Mtvec : Mtvec -> register_value*)

val _ = Define `
 ((regval_of_Mtvec:Mtvec -> register_value) v=  (Regval_Mtvec v))`;


(*val Privilege_of_regval : register_value -> maybe Privilege*)

val _ = Define `
 ((Privilege_of_regval:register_value ->(Privilege)option) merge_var=
    ((case merge_var of   Regval_Privilege (v) => SOME v | g__86 => NONE )))`;


(*val regval_of_Privilege : Privilege -> register_value*)

val _ = Define `
 ((regval_of_Privilege:Privilege -> register_value) v=  (Regval_Privilege v))`;


(*val Sedeleg_of_regval : register_value -> maybe Sedeleg*)

val _ = Define `
 ((Sedeleg_of_regval:register_value ->(Sedeleg)option) merge_var=
    ((case merge_var of   Regval_Sedeleg (v) => SOME v | g__85 => NONE )))`;


(*val regval_of_Sedeleg : Sedeleg -> register_value*)

val _ = Define `
 ((regval_of_Sedeleg:Sedeleg -> register_value) v=  (Regval_Sedeleg v))`;


(*val Sinterrupts_of_regval : register_value -> maybe Sinterrupts*)

val _ = Define `
 ((Sinterrupts_of_regval:register_value ->(Sinterrupts)option) merge_var=
    ((case merge_var of   Regval_Sinterrupts (v) => SOME v | g__84 => NONE )))`;


(*val regval_of_Sinterrupts : Sinterrupts -> register_value*)

val _ = Define `
 ((regval_of_Sinterrupts:Sinterrupts -> register_value) v=  (Regval_Sinterrupts v))`;


(*val TLB39_Entry_of_regval : register_value -> maybe TLB39_Entry*)

val _ = Define `
 ((TLB39_Entry_of_regval:register_value ->(TLB39_Entry)option) merge_var=
    ((case merge_var of   Regval_TLB39_Entry (v) => SOME v | g__83 => NONE )))`;


(*val regval_of_TLB39_Entry : TLB39_Entry -> register_value*)

val _ = Define `
 ((regval_of_TLB39_Entry:TLB39_Entry -> register_value) v=  (Regval_TLB39_Entry v))`;


(*val vector_64_dec_bit_of_regval : register_value -> maybe (mword ty64)*)

val _ = Define `
 ((vector_64_dec_bit_of_regval:register_value ->((64)words$word)option) merge_var=
    ((case merge_var of   Regval_vector_64_dec_bit (v) => SOME v | g__82 => NONE )))`;


(*val regval_of_vector_64_dec_bit : mword ty64 -> register_value*)

val _ = Define `
 ((regval_of_vector_64_dec_bit:(64)words$word -> register_value) v=  (Regval_vector_64_dec_bit v))`;




(*val vector_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)*)
val _ = Define `
 ((vector_of_regval:(register_value -> 'a option) -> register_value ->('a list)option) of_regval= 
  (\x .  (case x of
               Regval_vector (_, _, v) => just_list (MAP of_regval v)
           | _ => NONE
         )))`;


(*val regval_of_vector : forall 'a. ('a -> register_value) -> integer -> bool -> list 'a -> register_value*)
val _ = Define `
 ((regval_of_vector:('a -> register_value) -> int -> bool -> 'a list -> register_value) regval_of size1 is_inc xs=  (Regval_vector (size1, is_inc, MAP regval_of xs)))`;


(*val list_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)*)
val _ = Define `
 ((list_of_regval:(register_value -> 'a option) -> register_value ->('a list)option) of_regval= 
  (\x .  (case x of
               Regval_list v => just_list (MAP of_regval v)
           | _ => NONE
         )))`;


(*val regval_of_list : forall 'a. ('a -> register_value) -> list 'a -> register_value*)
val _ = Define `
 ((regval_of_list:('a -> register_value) -> 'a list -> register_value) regval_of xs=  (Regval_list (MAP regval_of xs)))`;


(*val option_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (maybe 'a)*)
val _ = Define `
 ((option_of_regval:(register_value -> 'a option) -> register_value ->('a option)option) of_regval= 
  (\x .  (case x of
               Regval_option v => SOME (OPTION_BIND v of_regval)
           | _ => NONE
         )))`;


(*val regval_of_option : forall 'a. ('a -> register_value) -> maybe 'a -> register_value*)
val _ = Define `
 ((regval_of_option:('a -> register_value) -> 'a option -> register_value) regval_of v=  (Regval_option (OPTION_MAP regval_of v)))`;



val _ = Define `
 ((tlb39_ref:((regstate),(register_value),((TLB39_Entry)option))register_ref)=  (<|
  name := "tlb39";
  read_from := (\ s .  s.tlb39);
  write_to := (\ v s .  (( s with<| tlb39 := v |>)));
  of_regval := (\ v .  option_of_regval (\ v .  TLB39_Entry_of_regval v) v);
  regval_of := (\ v .  regval_of_option (\ v .  regval_of_TLB39_Entry v) v) |>))`;


val _ = Define `
 ((tselect_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "tselect";
  read_from := (\ s .  s.tselect);
  write_to := (\ v s .  (( s with<| tselect := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((stval_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "stval";
  read_from := (\ s .  s.stval);
  write_to := (\ v s .  (( s with<| stval := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((scause_ref:((regstate),(register_value),(Mcause))register_ref)=  (<|
  name := "scause";
  read_from := (\ s .  s.scause);
  write_to := (\ v s .  (( s with<| scause := v |>)));
  of_regval := (\ v .  Mcause_of_regval v);
  regval_of := (\ v .  regval_of_Mcause v) |>))`;


val _ = Define `
 ((sepc_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "sepc";
  read_from := (\ s .  s.sepc);
  write_to := (\ v s .  (( s with<| sepc := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((sscratch_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "sscratch";
  read_from := (\ s .  s.sscratch);
  write_to := (\ v s .  (( s with<| sscratch := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((stvec_ref:((regstate),(register_value),(Mtvec))register_ref)=  (<|
  name := "stvec";
  read_from := (\ s .  s.stvec);
  write_to := (\ v s .  (( s with<| stvec := v |>)));
  of_regval := (\ v .  Mtvec_of_regval v);
  regval_of := (\ v .  regval_of_Mtvec v) |>))`;


val _ = Define `
 ((satp_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "satp";
  read_from := (\ s .  s.satp);
  write_to := (\ v s .  (( s with<| satp := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((sideleg_ref:((regstate),(register_value),(Sinterrupts))register_ref)=  (<|
  name := "sideleg";
  read_from := (\ s .  s.sideleg);
  write_to := (\ v s .  (( s with<| sideleg := v |>)));
  of_regval := (\ v .  Sinterrupts_of_regval v);
  regval_of := (\ v .  regval_of_Sinterrupts v) |>))`;


val _ = Define `
 ((sedeleg_ref:((regstate),(register_value),(Sedeleg))register_ref)=  (<|
  name := "sedeleg";
  read_from := (\ s .  s.sedeleg);
  write_to := (\ v s .  (( s with<| sedeleg := v |>)));
  of_regval := (\ v .  Sedeleg_of_regval v);
  regval_of := (\ v .  regval_of_Sedeleg v) |>))`;


val _ = Define `
 ((pmpcfg0_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "pmpcfg0";
  read_from := (\ s .  s.pmpcfg0);
  write_to := (\ v s .  (( s with<| pmpcfg0 := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((pmpaddr0_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "pmpaddr0";
  read_from := (\ s .  s.pmpaddr0);
  write_to := (\ v s .  (( s with<| pmpaddr0 := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mhartid_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mhartid";
  read_from := (\ s .  s.mhartid);
  write_to := (\ v s .  (( s with<| mhartid := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((marchid_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "marchid";
  read_from := (\ s .  s.marchid);
  write_to := (\ v s .  (( s with<| marchid := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mimpid_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mimpid";
  read_from := (\ s .  s.mimpid);
  write_to := (\ v s .  (( s with<| mimpid := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mvendorid_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mvendorid";
  read_from := (\ s .  s.mvendorid);
  write_to := (\ v s .  (( s with<| mvendorid := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((minstret_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "minstret";
  read_from := (\ s .  s.minstret);
  write_to := (\ v s .  (( s with<| minstret := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mtime_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mtime";
  read_from := (\ s .  s.mtime);
  write_to := (\ v s .  (( s with<| mtime := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mcycle_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mcycle";
  read_from := (\ s .  s.mcycle);
  write_to := (\ v s .  (( s with<| mcycle := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mscratch_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mscratch";
  read_from := (\ s .  s.mscratch);
  write_to := (\ v s .  (( s with<| mscratch := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mtval_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mtval";
  read_from := (\ s .  s.mtval);
  write_to := (\ v s .  (( s with<| mtval := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mepc_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "mepc";
  read_from := (\ s .  s.mepc);
  write_to := (\ v s .  (( s with<| mepc := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((mcause_ref:((regstate),(register_value),(Mcause))register_ref)=  (<|
  name := "mcause";
  read_from := (\ s .  s.mcause);
  write_to := (\ v s .  (( s with<| mcause := v |>)));
  of_regval := (\ v .  Mcause_of_regval v);
  regval_of := (\ v .  regval_of_Mcause v) |>))`;


val _ = Define `
 ((mtvec_ref:((regstate),(register_value),(Mtvec))register_ref)=  (<|
  name := "mtvec";
  read_from := (\ s .  s.mtvec);
  write_to := (\ v s .  (( s with<| mtvec := v |>)));
  of_regval := (\ v .  Mtvec_of_regval v);
  regval_of := (\ v .  regval_of_Mtvec v) |>))`;


val _ = Define `
 ((medeleg_ref:((regstate),(register_value),(Medeleg))register_ref)=  (<|
  name := "medeleg";
  read_from := (\ s .  s.medeleg);
  write_to := (\ v s .  (( s with<| medeleg := v |>)));
  of_regval := (\ v .  Medeleg_of_regval v);
  regval_of := (\ v .  regval_of_Medeleg v) |>))`;


val _ = Define `
 ((mideleg_ref:((regstate),(register_value),(Minterrupts))register_ref)=  (<|
  name := "mideleg";
  read_from := (\ s .  s.mideleg);
  write_to := (\ v s .  (( s with<| mideleg := v |>)));
  of_regval := (\ v .  Minterrupts_of_regval v);
  regval_of := (\ v .  regval_of_Minterrupts v) |>))`;


val _ = Define `
 ((mie_ref:((regstate),(register_value),(Minterrupts))register_ref)=  (<|
  name := "mie";
  read_from := (\ s .  s.mie);
  write_to := (\ v s .  (( s with<| mie := v |>)));
  of_regval := (\ v .  Minterrupts_of_regval v);
  regval_of := (\ v .  regval_of_Minterrupts v) |>))`;


val _ = Define `
 ((mip_ref:((regstate),(register_value),(Minterrupts))register_ref)=  (<|
  name := "mip";
  read_from := (\ s .  s.mip);
  write_to := (\ v s .  (( s with<| mip := v |>)));
  of_regval := (\ v .  Minterrupts_of_regval v);
  regval_of := (\ v .  regval_of_Minterrupts v) |>))`;


val _ = Define `
 ((mstatus_ref:((regstate),(register_value),(Mstatus))register_ref)=  (<|
  name := "mstatus";
  read_from := (\ s .  s.mstatus);
  write_to := (\ v s .  (( s with<| mstatus := v |>)));
  of_regval := (\ v .  Mstatus_of_regval v);
  regval_of := (\ v .  regval_of_Mstatus v) |>))`;


val _ = Define `
 ((misa_ref:((regstate),(register_value),(Misa))register_ref)=  (<|
  name := "misa";
  read_from := (\ s .  s.misa);
  write_to := (\ v s .  (( s with<| misa := v |>)));
  of_regval := (\ v .  Misa_of_regval v);
  regval_of := (\ v .  regval_of_Misa v) |>))`;


val _ = Define `
 ((cur_inst_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "cur_inst";
  read_from := (\ s .  s.cur_inst);
  write_to := (\ v s .  (( s with<| cur_inst := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((cur_privilege_ref:((regstate),(register_value),(Privilege))register_ref)=  (<|
  name := "cur_privilege";
  read_from := (\ s .  s.cur_privilege);
  write_to := (\ v s .  (( s with<| cur_privilege := v |>)));
  of_regval := (\ v .  Privilege_of_regval v);
  regval_of := (\ v .  regval_of_Privilege v) |>))`;


val _ = Define `
 ((Xs_ref:((regstate),(register_value),(((64)words$word)list))register_ref)=  (<|
  name := "Xs";
  read_from := (\ s .  s.Xs);
  write_to := (\ v s .  (( s with<| Xs := v |>)));
  of_regval := (\ v .  vector_of_regval (\ v .  vector_64_dec_bit_of_regval v) v);
  regval_of := (\ v .  regval_of_vector (\ v .  regval_of_vector_64_dec_bit v)(( 32 : int)) F v) |>))`;


val _ = Define `
 ((nextPC_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "nextPC";
  read_from := (\ s .  s.nextPC);
  write_to := (\ v s .  (( s with<| nextPC := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


val _ = Define `
 ((PC_ref:((regstate),(register_value),((64)words$word))register_ref)=  (<|
  name := "PC";
  read_from := (\ s .  s.PC);
  write_to := (\ v s .  (( s with<| PC := v |>)));
  of_regval := (\ v .  vector_64_dec_bit_of_regval v);
  regval_of := (\ v .  regval_of_vector_64_dec_bit v) |>))`;


(*val get_regval : string -> regstate -> maybe register_value*)
val _ = Define `
 ((get_regval:string -> regstate ->(register_value)option) reg_name s=
   (if reg_name = "tlb39" then SOME (tlb39_ref.regval_of (tlb39_ref.read_from s)) else
  if reg_name = "tselect" then SOME (tselect_ref.regval_of (tselect_ref.read_from s)) else
  if reg_name = "stval" then SOME (stval_ref.regval_of (stval_ref.read_from s)) else
  if reg_name = "scause" then SOME (scause_ref.regval_of (scause_ref.read_from s)) else
  if reg_name = "sepc" then SOME (sepc_ref.regval_of (sepc_ref.read_from s)) else
  if reg_name = "sscratch" then SOME (sscratch_ref.regval_of (sscratch_ref.read_from s)) else
  if reg_name = "stvec" then SOME (stvec_ref.regval_of (stvec_ref.read_from s)) else
  if reg_name = "satp" then SOME (satp_ref.regval_of (satp_ref.read_from s)) else
  if reg_name = "sideleg" then SOME (sideleg_ref.regval_of (sideleg_ref.read_from s)) else
  if reg_name = "sedeleg" then SOME (sedeleg_ref.regval_of (sedeleg_ref.read_from s)) else
  if reg_name = "pmpcfg0" then SOME (pmpcfg0_ref.regval_of (pmpcfg0_ref.read_from s)) else
  if reg_name = "pmpaddr0" then SOME (pmpaddr0_ref.regval_of (pmpaddr0_ref.read_from s)) else
  if reg_name = "mhartid" then SOME (mhartid_ref.regval_of (mhartid_ref.read_from s)) else
  if reg_name = "marchid" then SOME (marchid_ref.regval_of (marchid_ref.read_from s)) else
  if reg_name = "mimpid" then SOME (mimpid_ref.regval_of (mimpid_ref.read_from s)) else
  if reg_name = "mvendorid" then SOME (mvendorid_ref.regval_of (mvendorid_ref.read_from s)) else
  if reg_name = "minstret" then SOME (minstret_ref.regval_of (minstret_ref.read_from s)) else
  if reg_name = "mtime" then SOME (mtime_ref.regval_of (mtime_ref.read_from s)) else
  if reg_name = "mcycle" then SOME (mcycle_ref.regval_of (mcycle_ref.read_from s)) else
  if reg_name = "mscratch" then SOME (mscratch_ref.regval_of (mscratch_ref.read_from s)) else
  if reg_name = "mtval" then SOME (mtval_ref.regval_of (mtval_ref.read_from s)) else
  if reg_name = "mepc" then SOME (mepc_ref.regval_of (mepc_ref.read_from s)) else
  if reg_name = "mcause" then SOME (mcause_ref.regval_of (mcause_ref.read_from s)) else
  if reg_name = "mtvec" then SOME (mtvec_ref.regval_of (mtvec_ref.read_from s)) else
  if reg_name = "medeleg" then SOME (medeleg_ref.regval_of (medeleg_ref.read_from s)) else
  if reg_name = "mideleg" then SOME (mideleg_ref.regval_of (mideleg_ref.read_from s)) else
  if reg_name = "mie" then SOME (mie_ref.regval_of (mie_ref.read_from s)) else
  if reg_name = "mip" then SOME (mip_ref.regval_of (mip_ref.read_from s)) else
  if reg_name = "mstatus" then SOME (mstatus_ref.regval_of (mstatus_ref.read_from s)) else
  if reg_name = "misa" then SOME (misa_ref.regval_of (misa_ref.read_from s)) else
  if reg_name = "cur_inst" then SOME (cur_inst_ref.regval_of (cur_inst_ref.read_from s)) else
  if reg_name = "cur_privilege" then SOME (cur_privilege_ref.regval_of (cur_privilege_ref.read_from s)) else
  if reg_name = "Xs" then SOME (Xs_ref.regval_of (Xs_ref.read_from s)) else
  if reg_name = "nextPC" then SOME (nextPC_ref.regval_of (nextPC_ref.read_from s)) else
  if reg_name = "PC" then SOME (PC_ref.regval_of (PC_ref.read_from s)) else
  NONE))`;


(*val set_regval : string -> register_value -> regstate -> maybe regstate*)
val _ = Define `
 ((set_regval:string -> register_value -> regstate ->(regstate)option) reg_name v s=
   (if reg_name = "tlb39" then OPTION_MAP (\ v .  tlb39_ref.write_to v s) (tlb39_ref.of_regval v) else
  if reg_name = "tselect" then OPTION_MAP (\ v .  tselect_ref.write_to v s) (tselect_ref.of_regval v) else
  if reg_name = "stval" then OPTION_MAP (\ v .  stval_ref.write_to v s) (stval_ref.of_regval v) else
  if reg_name = "scause" then OPTION_MAP (\ v .  scause_ref.write_to v s) (scause_ref.of_regval v) else
  if reg_name = "sepc" then OPTION_MAP (\ v .  sepc_ref.write_to v s) (sepc_ref.of_regval v) else
  if reg_name = "sscratch" then OPTION_MAP (\ v .  sscratch_ref.write_to v s) (sscratch_ref.of_regval v) else
  if reg_name = "stvec" then OPTION_MAP (\ v .  stvec_ref.write_to v s) (stvec_ref.of_regval v) else
  if reg_name = "satp" then OPTION_MAP (\ v .  satp_ref.write_to v s) (satp_ref.of_regval v) else
  if reg_name = "sideleg" then OPTION_MAP (\ v .  sideleg_ref.write_to v s) (sideleg_ref.of_regval v) else
  if reg_name = "sedeleg" then OPTION_MAP (\ v .  sedeleg_ref.write_to v s) (sedeleg_ref.of_regval v) else
  if reg_name = "pmpcfg0" then OPTION_MAP (\ v .  pmpcfg0_ref.write_to v s) (pmpcfg0_ref.of_regval v) else
  if reg_name = "pmpaddr0" then OPTION_MAP (\ v .  pmpaddr0_ref.write_to v s) (pmpaddr0_ref.of_regval v) else
  if reg_name = "mhartid" then OPTION_MAP (\ v .  mhartid_ref.write_to v s) (mhartid_ref.of_regval v) else
  if reg_name = "marchid" then OPTION_MAP (\ v .  marchid_ref.write_to v s) (marchid_ref.of_regval v) else
  if reg_name = "mimpid" then OPTION_MAP (\ v .  mimpid_ref.write_to v s) (mimpid_ref.of_regval v) else
  if reg_name = "mvendorid" then OPTION_MAP (\ v .  mvendorid_ref.write_to v s) (mvendorid_ref.of_regval v) else
  if reg_name = "minstret" then OPTION_MAP (\ v .  minstret_ref.write_to v s) (minstret_ref.of_regval v) else
  if reg_name = "mtime" then OPTION_MAP (\ v .  mtime_ref.write_to v s) (mtime_ref.of_regval v) else
  if reg_name = "mcycle" then OPTION_MAP (\ v .  mcycle_ref.write_to v s) (mcycle_ref.of_regval v) else
  if reg_name = "mscratch" then OPTION_MAP (\ v .  mscratch_ref.write_to v s) (mscratch_ref.of_regval v) else
  if reg_name = "mtval" then OPTION_MAP (\ v .  mtval_ref.write_to v s) (mtval_ref.of_regval v) else
  if reg_name = "mepc" then OPTION_MAP (\ v .  mepc_ref.write_to v s) (mepc_ref.of_regval v) else
  if reg_name = "mcause" then OPTION_MAP (\ v .  mcause_ref.write_to v s) (mcause_ref.of_regval v) else
  if reg_name = "mtvec" then OPTION_MAP (\ v .  mtvec_ref.write_to v s) (mtvec_ref.of_regval v) else
  if reg_name = "medeleg" then OPTION_MAP (\ v .  medeleg_ref.write_to v s) (medeleg_ref.of_regval v) else
  if reg_name = "mideleg" then OPTION_MAP (\ v .  mideleg_ref.write_to v s) (mideleg_ref.of_regval v) else
  if reg_name = "mie" then OPTION_MAP (\ v .  mie_ref.write_to v s) (mie_ref.of_regval v) else
  if reg_name = "mip" then OPTION_MAP (\ v .  mip_ref.write_to v s) (mip_ref.of_regval v) else
  if reg_name = "mstatus" then OPTION_MAP (\ v .  mstatus_ref.write_to v s) (mstatus_ref.of_regval v) else
  if reg_name = "misa" then OPTION_MAP (\ v .  misa_ref.write_to v s) (misa_ref.of_regval v) else
  if reg_name = "cur_inst" then OPTION_MAP (\ v .  cur_inst_ref.write_to v s) (cur_inst_ref.of_regval v) else
  if reg_name = "cur_privilege" then OPTION_MAP (\ v .  cur_privilege_ref.write_to v s) (cur_privilege_ref.of_regval v) else
  if reg_name = "Xs" then OPTION_MAP (\ v .  Xs_ref.write_to v s) (Xs_ref.of_regval v) else
  if reg_name = "nextPC" then OPTION_MAP (\ v .  nextPC_ref.write_to v s) (nextPC_ref.of_regval v) else
  if reg_name = "PC" then OPTION_MAP (\ v .  PC_ref.write_to v s) (PC_ref.of_regval v) else
  NONE))`;


val _ = Define `
 ((register_accessors:(string -> regstate ->(register_value)option)#(string -> register_value -> regstate ->(regstate)option))=  (get_regval, set_regval))`;



val _ = type_abbrev((* ( 'a, 'r) *) "MR" , ``:  (regstate, 'a, 'r, exception)monadR``);
val _ = type_abbrev((*  'a *) "M" , ``:  (regstate, 'a, exception)monad``);
val _ = export_theory()

