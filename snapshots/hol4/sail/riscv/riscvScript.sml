(*Generated by Lem from riscv.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory sail_instr_kindsTheory sail_valuesTheory sail_operators_mwordsTheory prompt_monadTheory promptTheory riscv_typesTheory riscv_extrasTheory;

val _ = numLib.prefer_num();



val _ = new_theory "riscv"

(*Generated by Sail from riscv.*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators_mwords*)
(*open import Prompt_monad*)
(*open import Prompt*)
(*open import Riscv_types*)
(*open import Riscv_extras*)









(*val builtin_and_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val builtin_or_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val __raw_SetSlice_int : forall 'w. integer -> ii -> ii -> bits 'w -> ii*)

(*val __GetSlice_int : forall 'n. Size 'n => integer -> ii -> ii -> mword 'n*)

val _ = Define `
 ((GetSlice_int:int -> int -> int -> 'n words$word) n m o1=  ((get_slice_int0 n m o1  :  'n words$word)))`;


(*val __raw_SetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w -> bits 'n*)

(*val __raw_GetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w*)

(*val cast_unit_vec : bitU -> mword ty1*)

val _ = Define `
 ((cast_unit_vec0:bitU ->(1)words$word) b=
    ((case b of   B0 => (vec_of_bits [B0]  :  1 words$word) | B1 => (vec_of_bits [B1]  :  1 words$word) )))`;


(*val DecStr : ii -> string*)

(*val HexStr : ii -> string*)

(*val __RISCV_write : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M bool*)

val _ = Define `
 ((RISCV_write:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (state_monad$seqS
   (write_ram (( 64 : int):ii) width
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
       :  64 words$word) addr data)
   (state_monad$returnS T)))`;


(*val __TraceMemoryWrite : forall 'int8_times_n 'm. integer -> bits 'm -> bits 'int8_times_n -> unit*)

(*val __RISCV_read : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (maybe (mword 'int8_times_n))*)

val _ = Define `
 ((RISCV_read:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)option),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=  (state_monad$bindS
   (read_ram (( 64 : int):ii) width
      (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
        :  64 words$word) addr
     : ( 'int8_times_n words$word) M) (\ (w__0 :  'int8_times_n words$word) . 
   state_monad$returnS (SOME w__0))))`;


(*val __TraceMemoryRead : forall 'int8_times_n 'm. integer -> bits 'm -> bits 'int8_times_n -> unit*)

(*val ex_nat : ii -> integer*)

val _ = Define `
 ((ex_nat:int -> int) n=  n)`;


(*val ex_int : ii -> integer*)

val _ = Define `
 ((ex_int:int -> int) n=  n)`;


(*val coerce_int_nat : ii -> M ii*)

val _ = Define `
 ((coerce_int_nat:int ->(regstate)state_monad$sequential_state ->(((int),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) x=  (state_monad$seqS (state_monad$assert_expS T "") (state_monad$returnS x)))`;


(*val EXTS : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

(*val EXTZ : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

val _ = Define `
 ((EXTS:int -> 'n words$word -> 'm words$word) (m__tv : int) v=  ((sign_extend v m__tv  :  'm words$word)))`;


val _ = Define `
 ((EXTZ:int -> 'n words$word -> 'm words$word) (m__tv : int) v=  ((zero_extend v m__tv  :  'm words$word)))`;


(*val zopz0zI_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zKzJ_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zI_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zKzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zIzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

val _ = Define `
 ((zopz0zI_s:'n words$word -> 'n words$word -> bool) x y=  (((integer_word$w2i x)) < ((integer_word$w2i y))))`;


val _ = Define `
 ((zopz0zKzJ_s:'n words$word -> 'n words$word -> bool) x y=  (((integer_word$w2i x)) >= ((integer_word$w2i y))))`;


val _ = Define `
 ((zopz0zI_u:'n words$word -> 'n words$word -> bool) x y=  (((lem$w2ui x)) < ((lem$w2ui y))))`;


val _ = Define `
 ((zopz0zKzJ_u:'n words$word -> 'n words$word -> bool) x y=  (((lem$w2ui x)) >= ((lem$w2ui y))))`;


val _ = Define `
 ((zopz0zIzJ_u:'n words$word -> 'n words$word -> bool) x y=  (((lem$w2ui x)) <= ((lem$w2ui y))))`;


(*val bool_to_bits : bool -> mword ty1*)

val _ = Define `
 ((bool_to_bits:bool ->(1)words$word) x=  (if x then (vec_of_bits [B1]  :  1 words$word) else (vec_of_bits [B0]  :  1 words$word)))`;


(*val bit_to_bool : bitU -> bool*)

val _ = Define `
 ((bit_to_bool:bitU -> bool) b=  ((case b of   B1 => T | B0 => F )))`;


(*val vector64 : ii -> mword ty64*)

val _ = Define `
 ((vector64:int ->(64)words$word) n=  ((get_slice_int0 (( 64 : int):ii) n (( 0 : int):ii)  :  64 words$word)))`;


(*val to_bits : forall 'l. Size 'l => integer -> ii -> mword 'l*)

val _ = Define `
 ((to_bits:int -> int -> 'l words$word) l n=  ((get_slice_int0 l n (( 0 : int):ii)  :  'l words$word)))`;


(*val shift_right_arith64 : mword ty64 -> mword ty6 -> mword ty64*)

val _ = Define `
 ((shift_right_arith64:(64)words$word ->(6)words$word ->(64)words$word) (v : 64 bits) (shift : 6 bits)=
    (let (v128 : 128 bits) = ((EXTS (( 128 : int):ii) v  :  128 words$word)) in
   (subrange_vec_dec ((shift_bits_right v128 shift  :  128 words$word)) (( 63 : int):ii) (( 0 : int):ii)  :  64 words$word)))`;


(*val shift_right_arith32 : mword ty32 -> mword ty5 -> mword ty32*)

val _ = Define `
 ((shift_right_arith32:(32)words$word ->(5)words$word ->(32)words$word) (v : 32 bits) (shift : 5 bits)=
    (let (v64 : 64 bits) = ((EXTS (( 64 : int):ii) v  :  64 words$word)) in
   (subrange_vec_dec ((shift_bits_right v64 shift  :  64 words$word)) (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)))`;


val _ = Define `
 ((xlen:int)=  ((( 64 : int):ii)))`;


val _ = Define `
 ((xlen_max_unsigned:int)=  (((pow2 xlen)) - (( 1 : int):ii)))`;


val _ = Define `
 ((xlen_max_signed:int)=  (((pow2 ((xlen - (( 1 : int):ii))))) - (( 1 : int):ii)))`;


val _ = Define `
 ((xlen_min_signed:int)=  ((( 0 : int):ii) - ((pow2 ((xlen - (( 1 : int):ii)))))))`;


(*val regbits_to_regno : mword ty5 -> integer*)

val _ = Define `
 ((regbits_to_regno:(5)words$word -> int) b=
    (let r = (lem$w2ui b) in
   r))`;


(*val creg2reg_bits : mword ty3 -> mword ty5*)

val _ = Define `
 ((creg2reg_bits:(3)words$word ->(5)words$word) creg=  ((concat_vec (vec_of_bits [B0;B1]  :  2 words$word) creg  :  5 words$word)))`;


val _ = Define `
((zreg:(5)words$word)=  ((vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))`;


val _ = Define `
((ra:(5)words$word)=  ((vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))`;


val _ = Define `
((sp:(5)words$word)=  ((vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))`;


(*val rX : integer -> M (mword ty64)*)

val _ = Define `
 ((rX:int ->(regstate)state_monad$sequential_state ->((((64)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) l__81=
    (if (((l__81 = (( 0 : int):ii)))) then
     state_monad$returnS (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                          B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                          B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
              :  64 words$word)
   else state_monad$bindS
     (state_monad$read_regS Xs_ref) (\ (w__0 : xlenbits list) . 
     state_monad$returnS ((access_list_dec w__0 l__81  :  64 words$word)))))`;


(*val wX : integer -> mword ty64 -> M unit*)

val _ = Define `
 ((wX:int ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r v=
    (if (((r <> (( 0 : int):ii)))) then state_monad$bindS
     (state_monad$read_regS Xs_ref) (\ (w__0 : ( 64 words$word) list) .  state_monad$seqS
     (state_monad$write_regS Xs_ref ((update_list_dec w__0 r v  : ( 64 words$word) list)))
     (state_monad$returnS ((prerr_endline
                ((STRCAT "x"
                    ((STRCAT ((stringFromInteger r))
                        ((STRCAT " <- " ((string_of_vec v))))))))))))
   else state_monad$returnS () ))`;


(*val reg_name_abi : mword ty5 -> string*)

val _ = Define `
 ((reg_name_abi:(5)words$word -> string) r=
    (let b__0 = r in
   if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) then
     "zero"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))))) then
     "ra"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) then
     "sp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word)))))) then
     "gp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  :  5 words$word)))))) then
     "tp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B1]  :  5 words$word)))))) then
     "t0"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B0]  :  5 words$word)))))) then
     "t1"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B1]  :  5 words$word)))))) then
     "t2"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  :  5 words$word)))))) then
     "fp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B1]  :  5 words$word)))))) then
     "s1"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B0]  :  5 words$word)))))) then
     "a0"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B1]  :  5 words$word)))))) then
     "a1"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))))) then
     "a2"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B1]  :  5 words$word)))))) then
     "a3"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B0]  :  5 words$word)))))) then
     "a4"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B1]  :  5 words$word)))))) then
     "a5"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))) then
     "a6"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B1]  :  5 words$word)))))) then
     "a7"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B0]  :  5 words$word)))))) then
     "s2"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B1]  :  5 words$word)))))) then
     "s3"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))))) then
     "s4"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B1]  :  5 words$word)))))) then
     "s5"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B0]  :  5 words$word)))))) then
     "s6"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B1]  :  5 words$word)))))) then
     "s7"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  :  5 words$word)))))) then
     "s8"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B1]  :  5 words$word)))))) then
     "s9"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B0]  :  5 words$word)))))) then
     "s10"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B1]  :  5 words$word)))))) then
     "s11"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))))) then
     "t3"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B1]  :  5 words$word)))))) then
     "t4"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B1;B0]  :  5 words$word)))))) then
     "t5"
   else "t6"))`;


(*val Architecture_of_num : integer -> Architecture*)

val _ = Define `
 ((Architecture_of_num:int -> Architecture) arg_=
    (let l__79 = arg_ in
   if (((l__79 = (( 0 : int):ii)))) then RV32
   else if (((l__79 = (( 1 : int):ii)))) then RV64
   else RV128))`;


(*val num_of_Architecture : Architecture -> integer*)

val _ = Define `
 ((num_of_Architecture:Architecture -> int) arg_=
    ((case arg_ of   RV32 => (( 0 : int):ii) | RV64 => (( 1 : int):ii) | RV128 => (( 2 : int):ii) )))`;


(*val architecture : mword ty2 -> maybe Architecture*)

val _ = Define `
 ((architecture:(2)words$word ->(Architecture)option) a=
    (let b__0 = a in
   if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then SOME RV32
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then SOME RV64
   else if (((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) then SOME RV128
   else NONE))`;


(*val arch_to_bits : Architecture -> mword ty2*)

val _ = Define `
 ((arch_to_bits:Architecture ->(2)words$word) a=
    ((case a of
     RV32 => (vec_of_bits [B0;B1]  :  2 words$word)
   | RV64 => (vec_of_bits [B1;B0]  :  2 words$word)
   | RV128 => (vec_of_bits [B1;B1]  :  2 words$word)
   )))`;


(*val Privilege_of_num : integer -> Privilege*)

val _ = Define `
 ((Privilege_of_num:int -> Privilege) arg_=
    (let l__77 = arg_ in
   if (((l__77 = (( 0 : int):ii)))) then User
   else if (((l__77 = (( 1 : int):ii)))) then Supervisor
   else Machine))`;


(*val num_of_Privilege : Privilege -> integer*)

val _ = Define `
 ((num_of_Privilege:Privilege -> int) arg_=
    ((case arg_ of   User => (( 0 : int):ii) | Supervisor => (( 1 : int):ii) | Machine => (( 2 : int):ii) )))`;


(*val privLevel_to_bits : Privilege -> mword ty2*)

val _ = Define `
 ((privLevel_to_bits:Privilege ->(2)words$word) p=
    ((case p of
     User => (vec_of_bits [B0;B0]  :  2 words$word)
   | Supervisor => (vec_of_bits [B0;B1]  :  2 words$word)
   | Machine => (vec_of_bits [B1;B1]  :  2 words$word)
   )))`;


(*val privLevel_of_bits : mword ty2 -> Privilege*)

val _ = Define `
 ((privLevel_of_bits:(2)words$word -> Privilege) p=
    (let b__0 = p in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then User
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then Supervisor
   else Machine))`;


(*val privLevel_to_str : Privilege -> string*)

val _ = Define `
 ((privLevel_to_str:Privilege -> string) p=  ((case p of   User => "U" | Supervisor => "S" | Machine => "M" )))`;


(*val AccessType_of_num : integer -> AccessType*)

val _ = Define `
 ((AccessType_of_num:int -> AccessType) arg_=
    (let l__74 = arg_ in
   if (((l__74 = (( 0 : int):ii)))) then Read
   else if (((l__74 = (( 1 : int):ii)))) then Write
   else if (((l__74 = (( 2 : int):ii)))) then ReadWrite
   else Execute))`;


(*val num_of_AccessType : AccessType -> integer*)

val _ = Define `
 ((num_of_AccessType:AccessType -> int) arg_=
    ((case arg_ of   Read => (( 0 : int):ii) | Write => (( 1 : int):ii) | ReadWrite => (( 2 : int):ii) | Execute => (( 3 : int):ii) )))`;


(*val ReadType_of_num : integer -> ReadType*)

val _ = Define `
 ((ReadType_of_num:int -> ReadType) arg_=
    (let l__73 = arg_ in
   if (((l__73 = (( 0 : int):ii)))) then Instruction
   else Data))`;


(*val num_of_ReadType : ReadType -> integer*)

val _ = Define `
 ((num_of_ReadType:ReadType -> int) arg_=  ((case arg_ of   Instruction => (( 0 : int):ii) | Data => (( 1 : int):ii) )))`;


(*val ExceptionType_of_num : integer -> ExceptionType*)

val _ = Define `
 ((ExceptionType_of_num:int -> ExceptionType) arg_=
    (let l__58 = arg_ in
   if (((l__58 = (( 0 : int):ii)))) then E_Fetch_Addr_Align
   else if (((l__58 = (( 1 : int):ii)))) then E_Fetch_Access_Fault
   else if (((l__58 = (( 2 : int):ii)))) then E_Illegal_Instr
   else if (((l__58 = (( 3 : int):ii)))) then E_Breakpoint
   else if (((l__58 = (( 4 : int):ii)))) then E_Load_Addr_Align
   else if (((l__58 = (( 5 : int):ii)))) then E_Load_Access_Fault
   else if (((l__58 = (( 6 : int):ii)))) then E_SAMO_Addr_Align
   else if (((l__58 = (( 7 : int):ii)))) then E_SAMO_Access_Fault
   else if (((l__58 = (( 8 : int):ii)))) then E_U_EnvCall
   else if (((l__58 = (( 9 : int):ii)))) then E_S_EnvCall
   else if (((l__58 = (( 10 : int):ii)))) then E_Reserved_10
   else if (((l__58 = (( 11 : int):ii)))) then E_M_EnvCall
   else if (((l__58 = (( 12 : int):ii)))) then E_Fetch_Page_Fault
   else if (((l__58 = (( 13 : int):ii)))) then E_Load_Page_Fault
   else if (((l__58 = (( 14 : int):ii)))) then E_Reserved_14
   else E_SAMO_Page_Fault))`;


(*val num_of_ExceptionType : ExceptionType -> integer*)

val _ = Define `
 ((num_of_ExceptionType:ExceptionType -> int) arg_=
    ((case arg_ of
     E_Fetch_Addr_Align => (( 0 : int):ii)
   | E_Fetch_Access_Fault => (( 1 : int):ii)
   | E_Illegal_Instr => (( 2 : int):ii)
   | E_Breakpoint => (( 3 : int):ii)
   | E_Load_Addr_Align => (( 4 : int):ii)
   | E_Load_Access_Fault => (( 5 : int):ii)
   | E_SAMO_Addr_Align => (( 6 : int):ii)
   | E_SAMO_Access_Fault => (( 7 : int):ii)
   | E_U_EnvCall => (( 8 : int):ii)
   | E_S_EnvCall => (( 9 : int):ii)
   | E_Reserved_10 => (( 10 : int):ii)
   | E_M_EnvCall => (( 11 : int):ii)
   | E_Fetch_Page_Fault => (( 12 : int):ii)
   | E_Load_Page_Fault => (( 13 : int):ii)
   | E_Reserved_14 => (( 14 : int):ii)
   | E_SAMO_Page_Fault => (( 15 : int):ii)
   )))`;


(*val exceptionType_to_bits : ExceptionType -> mword ty4*)

val _ = Define `
 ((exceptionType_to_bits:ExceptionType ->(4)words$word) e=
    ((case e of
     E_Fetch_Addr_Align => (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
   | E_Fetch_Access_Fault => (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
   | E_Illegal_Instr => (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)
   | E_Breakpoint => (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
   | E_Load_Addr_Align => (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)
   | E_Load_Access_Fault => (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
   | E_SAMO_Addr_Align => (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)
   | E_SAMO_Access_Fault => (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
   | E_U_EnvCall => (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
   | E_S_EnvCall => (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)
   | E_Reserved_10 => (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)
   | E_M_EnvCall => (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
   | E_Fetch_Page_Fault => (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)
   | E_Load_Page_Fault => (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)
   | E_Reserved_14 => (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
   | E_SAMO_Page_Fault => (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)
   )))`;


(*val exceptionType_to_str : ExceptionType -> string*)

val _ = Define `
 ((exceptionType_to_str:ExceptionType -> string) e=
    ((case e of
     E_Fetch_Addr_Align => "fisaligned-fetch"
   | E_Fetch_Access_Fault => "fetch-access-fault"
   | E_Illegal_Instr => "illegal-instruction"
   | E_Breakpoint => "breakpoint"
   | E_Load_Addr_Align => "misaligned-load"
   | E_Load_Access_Fault => "load-access-fault"
   | E_SAMO_Addr_Align => "misaliged-store/amo"
   | E_SAMO_Access_Fault => "store/amo-access-fault"
   | E_U_EnvCall => "u-call"
   | E_S_EnvCall => "s-call"
   | E_Reserved_10 => "reserved-0"
   | E_M_EnvCall => "m-call"
   | E_Fetch_Page_Fault => "fetch-page-fault"
   | E_Load_Page_Fault => "load-page-fault"
   | E_Reserved_14 => "reserved-1"
   | E_SAMO_Page_Fault => "store/amo-page-fault"
   )))`;


(*val InterruptType_of_num : integer -> InterruptType*)

val _ = Define `
 ((InterruptType_of_num:int -> InterruptType) arg_=
    (let l__50 = arg_ in
   if (((l__50 = (( 0 : int):ii)))) then I_U_Software
   else if (((l__50 = (( 1 : int):ii)))) then I_S_Software
   else if (((l__50 = (( 2 : int):ii)))) then I_M_Software
   else if (((l__50 = (( 3 : int):ii)))) then I_U_Timer
   else if (((l__50 = (( 4 : int):ii)))) then I_S_Timer
   else if (((l__50 = (( 5 : int):ii)))) then I_M_Timer
   else if (((l__50 = (( 6 : int):ii)))) then I_U_External
   else if (((l__50 = (( 7 : int):ii)))) then I_S_External
   else I_M_External))`;


(*val num_of_InterruptType : InterruptType -> integer*)

val _ = Define `
 ((num_of_InterruptType:InterruptType -> int) arg_=
    ((case arg_ of
     I_U_Software => (( 0 : int):ii)
   | I_S_Software => (( 1 : int):ii)
   | I_M_Software => (( 2 : int):ii)
   | I_U_Timer => (( 3 : int):ii)
   | I_S_Timer => (( 4 : int):ii)
   | I_M_Timer => (( 5 : int):ii)
   | I_U_External => (( 6 : int):ii)
   | I_S_External => (( 7 : int):ii)
   | I_M_External => (( 8 : int):ii)
   )))`;


(*val interruptType_to_bits : InterruptType -> mword ty4*)

val _ = Define `
 ((interruptType_to_bits:InterruptType ->(4)words$word) i=
    ((case i of
     I_U_Software => (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
   | I_S_Software => (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
   | I_M_Software => (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
   | I_U_Timer => (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)
   | I_S_Timer => (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
   | I_M_Timer => (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
   | I_U_External => (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
   | I_S_External => (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)
   | I_M_External => (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
   )))`;


(*val TrapVectorMode_of_num : integer -> TrapVectorMode*)

val _ = Define `
 ((TrapVectorMode_of_num:int -> TrapVectorMode) arg_=
    (let l__48 = arg_ in
   if (((l__48 = (( 0 : int):ii)))) then TV_Direct
   else if (((l__48 = (( 1 : int):ii)))) then TV_Vector
   else TV_Reserved))`;


(*val num_of_TrapVectorMode : TrapVectorMode -> integer*)

val _ = Define `
 ((num_of_TrapVectorMode:TrapVectorMode -> int) arg_=
    ((case arg_ of   TV_Direct => (( 0 : int):ii) | TV_Vector => (( 1 : int):ii) | TV_Reserved => (( 2 : int):ii) )))`;


(*val trapVectorMode_of_bits : mword ty2 -> TrapVectorMode*)

val _ = Define `
 ((trapVectorMode_of_bits:(2)words$word -> TrapVectorMode) m=
    (let b__0 = m in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then TV_Direct
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then TV_Vector
   else TV_Reserved))`;


(*val not_implemented : forall 'a. string -> M 'a*)

val _ = Define `
 ((not_implemented:string ->(regstate)state_monad$sequential_state ->(('a,(exception))state_monad$result#(regstate)state_monad$sequential_state)set) message=  (state_monad$throwS (Error_not_implemented message)))`;


(*val internal_error : forall 'a. string -> M 'a*)

val _ = Define `
 ((internal_error:string ->(regstate)state_monad$sequential_state ->(('a,(exception))state_monad$result#(regstate)state_monad$sequential_state)set) s=  (state_monad$seqS (state_monad$assert_expS F s) (state_monad$throwS (Error_internal_error () ))))`;


(*val ExtStatus_of_num : integer -> ExtStatus*)

val _ = Define `
 ((ExtStatus_of_num:int -> ExtStatus) arg_=
    (let l__45 = arg_ in
   if (((l__45 = (( 0 : int):ii)))) then Off
   else if (((l__45 = (( 1 : int):ii)))) then Initial
   else if (((l__45 = (( 2 : int):ii)))) then Clean
   else Dirty))`;


(*val num_of_ExtStatus : ExtStatus -> integer*)

val _ = Define `
 ((num_of_ExtStatus:ExtStatus -> int) arg_=
    ((case arg_ of   Off => (( 0 : int):ii) | Initial => (( 1 : int):ii) | Clean => (( 2 : int):ii) | Dirty => (( 3 : int):ii) )))`;


(*val extStatus_to_bits : ExtStatus -> mword ty2*)

val _ = Define `
 ((extStatus_to_bits:ExtStatus ->(2)words$word) e=
    ((case e of
     Off => (vec_of_bits [B0;B0]  :  2 words$word)
   | Initial => (vec_of_bits [B0;B1]  :  2 words$word)
   | Clean => (vec_of_bits [B1;B0]  :  2 words$word)
   | Dirty => (vec_of_bits [B1;B1]  :  2 words$word)
   )))`;


(*val extStatus_of_bits : mword ty2 -> ExtStatus*)

val _ = Define `
 ((extStatus_of_bits:(2)words$word -> ExtStatus) e=
    (let b__0 = e in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then Off
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then Initial
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then Clean
   else Dirty))`;


(*val SATPMode_of_num : integer -> SATPMode*)

val _ = Define `
 ((SATPMode_of_num:int -> SATPMode) arg_=
    (let l__43 = arg_ in
   if (((l__43 = (( 0 : int):ii)))) then Sbare
   else if (((l__43 = (( 1 : int):ii)))) then Sv32
   else Sv39))`;


(*val num_of_SATPMode : SATPMode -> integer*)

val _ = Define `
 ((num_of_SATPMode:SATPMode -> int) arg_=  ((case arg_ of   Sbare => (( 0 : int):ii) | Sv32 => (( 1 : int):ii) | Sv39 => (( 2 : int):ii) )))`;


(*val satpMode_of_bits : Architecture -> mword ty4 -> maybe SATPMode*)

val _ = Define `
 ((satpMode_of_bits:Architecture ->(4)words$word ->(SATPMode)option) (a : Architecture) (m : satp_mode)= 
  ((case (a, m) of   (g__113, b__0) => SOME Sbare )))`;


(*val uop_of_num : integer -> uop*)

val _ = Define `
 ((uop_of_num:int -> uop) arg_=
    (let l__42 = arg_ in
   if (((l__42 = (( 0 : int):ii)))) then RISCV_LUI
   else RISCV_AUIPC))`;


(*val num_of_uop : uop -> integer*)

val _ = Define `
 ((num_of_uop:uop -> int) arg_=  ((case arg_ of   RISCV_LUI => (( 0 : int):ii) | RISCV_AUIPC => (( 1 : int):ii) )))`;


(*val bop_of_num : integer -> bop*)

val _ = Define `
 ((bop_of_num:int -> bop) arg_=
    (let l__37 = arg_ in
   if (((l__37 = (( 0 : int):ii)))) then RISCV_BEQ
   else if (((l__37 = (( 1 : int):ii)))) then RISCV_BNE
   else if (((l__37 = (( 2 : int):ii)))) then RISCV_BLT
   else if (((l__37 = (( 3 : int):ii)))) then RISCV_BGE
   else if (((l__37 = (( 4 : int):ii)))) then RISCV_BLTU
   else RISCV_BGEU))`;


(*val num_of_bop : bop -> integer*)

val _ = Define `
 ((num_of_bop:bop -> int) arg_=
    ((case arg_ of
     RISCV_BEQ => (( 0 : int):ii)
   | RISCV_BNE => (( 1 : int):ii)
   | RISCV_BLT => (( 2 : int):ii)
   | RISCV_BGE => (( 3 : int):ii)
   | RISCV_BLTU => (( 4 : int):ii)
   | RISCV_BGEU => (( 5 : int):ii)
   )))`;


(*val iop_of_num : integer -> iop*)

val _ = Define `
 ((iop_of_num:int -> iop) arg_=
    (let l__32 = arg_ in
   if (((l__32 = (( 0 : int):ii)))) then RISCV_ADDI
   else if (((l__32 = (( 1 : int):ii)))) then RISCV_SLTI
   else if (((l__32 = (( 2 : int):ii)))) then RISCV_SLTIU
   else if (((l__32 = (( 3 : int):ii)))) then RISCV_XORI
   else if (((l__32 = (( 4 : int):ii)))) then RISCV_ORI
   else RISCV_ANDI))`;


(*val num_of_iop : iop -> integer*)

val _ = Define `
 ((num_of_iop:iop -> int) arg_=
    ((case arg_ of
     RISCV_ADDI => (( 0 : int):ii)
   | RISCV_SLTI => (( 1 : int):ii)
   | RISCV_SLTIU => (( 2 : int):ii)
   | RISCV_XORI => (( 3 : int):ii)
   | RISCV_ORI => (( 4 : int):ii)
   | RISCV_ANDI => (( 5 : int):ii)
   )))`;


(*val sop_of_num : integer -> sop*)

val _ = Define `
 ((sop_of_num:int -> sop) arg_=
    (let l__30 = arg_ in
   if (((l__30 = (( 0 : int):ii)))) then RISCV_SLLI
   else if (((l__30 = (( 1 : int):ii)))) then RISCV_SRLI
   else RISCV_SRAI))`;


(*val num_of_sop : sop -> integer*)

val _ = Define `
 ((num_of_sop:sop -> int) arg_=
    ((case arg_ of   RISCV_SLLI => (( 0 : int):ii) | RISCV_SRLI => (( 1 : int):ii) | RISCV_SRAI => (( 2 : int):ii) )))`;


(*val rop_of_num : integer -> rop*)

val _ = Define `
 ((rop_of_num:int -> rop) arg_=
    (let l__21 = arg_ in
   if (((l__21 = (( 0 : int):ii)))) then RISCV_ADD
   else if (((l__21 = (( 1 : int):ii)))) then RISCV_SUB
   else if (((l__21 = (( 2 : int):ii)))) then RISCV_SLL
   else if (((l__21 = (( 3 : int):ii)))) then RISCV_SLT
   else if (((l__21 = (( 4 : int):ii)))) then RISCV_SLTU
   else if (((l__21 = (( 5 : int):ii)))) then RISCV_XOR
   else if (((l__21 = (( 6 : int):ii)))) then RISCV_SRL
   else if (((l__21 = (( 7 : int):ii)))) then RISCV_SRA
   else if (((l__21 = (( 8 : int):ii)))) then RISCV_OR
   else RISCV_AND))`;


(*val num_of_rop : rop -> integer*)

val _ = Define `
 ((num_of_rop:rop -> int) arg_=
    ((case arg_ of
     RISCV_ADD => (( 0 : int):ii)
   | RISCV_SUB => (( 1 : int):ii)
   | RISCV_SLL => (( 2 : int):ii)
   | RISCV_SLT => (( 3 : int):ii)
   | RISCV_SLTU => (( 4 : int):ii)
   | RISCV_XOR => (( 5 : int):ii)
   | RISCV_SRL => (( 6 : int):ii)
   | RISCV_SRA => (( 7 : int):ii)
   | RISCV_OR => (( 8 : int):ii)
   | RISCV_AND => (( 9 : int):ii)
   )))`;


(*val ropw_of_num : integer -> ropw*)

val _ = Define `
 ((ropw_of_num:int -> ropw) arg_=
    (let l__17 = arg_ in
   if (((l__17 = (( 0 : int):ii)))) then RISCV_ADDW
   else if (((l__17 = (( 1 : int):ii)))) then RISCV_SUBW
   else if (((l__17 = (( 2 : int):ii)))) then RISCV_SLLW
   else if (((l__17 = (( 3 : int):ii)))) then RISCV_SRLW
   else RISCV_SRAW))`;


(*val num_of_ropw : ropw -> integer*)

val _ = Define `
 ((num_of_ropw:ropw -> int) arg_=
    ((case arg_ of
     RISCV_ADDW => (( 0 : int):ii)
   | RISCV_SUBW => (( 1 : int):ii)
   | RISCV_SLLW => (( 2 : int):ii)
   | RISCV_SRLW => (( 3 : int):ii)
   | RISCV_SRAW => (( 4 : int):ii)
   )))`;


(*val amoop_of_num : integer -> amoop*)

val _ = Define `
 ((amoop_of_num:int -> amoop) arg_=
    (let l__9 = arg_ in
   if (((l__9 = (( 0 : int):ii)))) then AMOSWAP
   else if (((l__9 = (( 1 : int):ii)))) then AMOADD
   else if (((l__9 = (( 2 : int):ii)))) then AMOXOR
   else if (((l__9 = (( 3 : int):ii)))) then AMOAND
   else if (((l__9 = (( 4 : int):ii)))) then AMOOR
   else if (((l__9 = (( 5 : int):ii)))) then AMOMIN
   else if (((l__9 = (( 6 : int):ii)))) then AMOMAX
   else if (((l__9 = (( 7 : int):ii)))) then AMOMINU
   else AMOMAXU))`;


(*val num_of_amoop : amoop -> integer*)

val _ = Define `
 ((num_of_amoop:amoop -> int) arg_=
    ((case arg_ of
     AMOSWAP => (( 0 : int):ii)
   | AMOADD => (( 1 : int):ii)
   | AMOXOR => (( 2 : int):ii)
   | AMOAND => (( 3 : int):ii)
   | AMOOR => (( 4 : int):ii)
   | AMOMIN => (( 5 : int):ii)
   | AMOMAX => (( 6 : int):ii)
   | AMOMINU => (( 7 : int):ii)
   | AMOMAXU => (( 8 : int):ii)
   )))`;


(*val csrop_of_num : integer -> csrop*)

val _ = Define `
 ((csrop_of_num:int -> csrop) arg_=
    (let l__7 = arg_ in
   if (((l__7 = (( 0 : int):ii)))) then CSRRW
   else if (((l__7 = (( 1 : int):ii)))) then CSRRS
   else CSRRC))`;


(*val num_of_csrop : csrop -> integer*)

val _ = Define `
 ((num_of_csrop:csrop -> int) arg_=  ((case arg_ of   CSRRW => (( 0 : int):ii) | CSRRS => (( 1 : int):ii) | CSRRC => (( 2 : int):ii) )))`;


(*val word_width_of_num : integer -> word_width*)

val _ = Define `
 ((word_width_of_num:int -> word_width) arg_=
    (let l__4 = arg_ in
   if (((l__4 = (( 0 : int):ii)))) then BYTE
   else if (((l__4 = (( 1 : int):ii)))) then HALF
   else if (((l__4 = (( 2 : int):ii)))) then WORD
   else DOUBLE))`;


(*val num_of_word_width : word_width -> integer*)

val _ = Define `
 ((num_of_word_width:word_width -> int) arg_=
    ((case arg_ of   BYTE => (( 0 : int):ii) | HALF => (( 1 : int):ii) | WORD => (( 2 : int):ii) | DOUBLE => (( 3 : int):ii) )))`;


(*val is_aligned_addr : mword ty64 -> integer -> bool*)

val _ = Define `
 ((is_aligned_addr:(64)words$word -> int -> bool) (addr : xlenbits) (width : int)=
    (((ex_int ((hardware_mod ((lem$w2ui addr)) width)))) = (( 0 : int):ii)))`;


(*val checked_mem_read : forall 'int8_times_n. Size 'int8_times_n => ReadType -> mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

val _ = Define `
 ((checked_mem_read:ReadType ->(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (t : ReadType) (addr : xlenbits) (width : int)=  (state_monad$bindS
   (RISCV_read addr width  : ( ( 'int8_times_n words$word)option) M) (\ (w__0 :
      ( 'int8_times_n words$word)option) . 
   state_monad$returnS ((case (t, w__0) of
     (Instruction, NONE) => MemException E_Fetch_Access_Fault
   | (Data, NONE) => MemException E_Load_Access_Fault
   | (_, SOME (v)) => MemValue v
   )))))`;


(*val MEMr : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_strong_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_reserved : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_reserved_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_reserved_strong_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

val _ = Define `
 ((MEMr:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=  ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)))`;


val _ = Define `
 ((MEMr_acquire:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=
    ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)))`;


val _ = Define `
 ((MEMr_strong_acquire:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=
    ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)))`;


val _ = Define `
 ((MEMr_reserved:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=
    ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)))`;


val _ = Define `
 ((MEMr_reserved_acquire:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=
    ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)))`;


val _ = Define `
 ((MEMr_reserved_strong_acquire:(64)words$word -> int ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width=
    ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)))`;


(*val mem_read : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))*)

val _ = Define `
 ((mem_read:(64)words$word -> int -> bool -> bool -> bool ->(regstate)state_monad$sequential_state ->(((('int8_times_n words$word)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width aq rl res=
    (if ((((((aq \/ res))) /\ ((~ ((is_aligned_addr addr width))))))) then
     state_monad$returnS (MemException E_Load_Addr_Align)
   else
     (case (aq, rl, res) of
       (F, F, F) => (MEMr addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)
     | (T, F, F) => (MEMr_acquire addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)
     | (F, F, T) =>
        (MEMr_reserved addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)
     | (T, F, T) =>
        (MEMr_reserved_acquire addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)
     | (F, T, F) => state_monad$throwS (Error_not_implemented "load.rl")
     | (T, T, F) =>
        (MEMr_strong_acquire addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)
     | (F, T, T) => state_monad$throwS (Error_not_implemented "lr.rl")
     | (T, T, T) =>
        (MEMr_reserved_strong_acquire addr width  : ( ( 'int8_times_n words$word)MemoryOpResult) M)
     )))`;


(*val mem_write_ea : mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult unit)*)

val _ = Define `
 ((mem_write_ea:(64)words$word -> int -> bool -> bool -> bool ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width aq rl con=
    (if ((((((rl \/ con))) /\ ((~ ((is_aligned_addr addr width))))))) then
     state_monad$returnS (MemException E_SAMO_Addr_Align)
   else
     (case (aq, rl, con) of
       (F, F, F) => state_monad$seqS (MEMea addr width) (state_monad$returnS (MemValue () ))
     | (F, T, F) => state_monad$seqS (MEMea_release addr width) (state_monad$returnS (MemValue () ))
     | (F, F, T) => state_monad$seqS (MEMea_conditional addr width) (state_monad$returnS (MemValue () ))
     | (F, T, T) => state_monad$seqS (MEMea_conditional_release addr width) (state_monad$returnS (MemValue () ))
     | (T, F, F) => state_monad$throwS (Error_not_implemented "store.aq")
     | (T, T, F) => state_monad$seqS (MEMea_strong_release addr width) (state_monad$returnS (MemValue () ))
     | (T, F, T) => state_monad$throwS (Error_not_implemented "sc.aq")
     | (T, T, T) => state_monad$seqS (MEMea_conditional_strong_release addr width) (state_monad$returnS (MemValue () ))
     )))`;


(*val checked_mem_write : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

val _ = Define `
 ((checked_mem_write:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (addr : xlenbits) (width : int) (data : 'int8_times_n bits)=  (state_monad$bindS
   (RISCV_write addr width data) (\ (w__0 : bool) . 
   state_monad$returnS (if w__0 then MemValue () 
           else MemException E_SAMO_Access_Fault))))`;


(*val MEMval : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_strong_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_conditional : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_conditional_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_conditional_strong_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

val _ = Define `
 ((MEMval:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_release:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_strong_release:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_conditional:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_conditional_release:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_conditional_strong_release:(64)words$word -> int -> 'int8_times_n words$word ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


(*val mem_write_value : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> bool -> bool -> bool -> M (MemoryOpResult unit)*)

val _ = Define `
 ((mem_write_value:(64)words$word -> int -> 'int8_times_n words$word -> bool -> bool -> bool ->(regstate)state_monad$sequential_state ->((((unit)MemoryOpResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) addr width value aq rl con=
    (if ((((((rl \/ con))) /\ ((~ ((is_aligned_addr addr width))))))) then
     state_monad$returnS (MemException E_SAMO_Addr_Align)
   else
     (case (aq, rl, con) of
       (F, F, F) => MEMval addr width value
     | (F, T, F) => MEMval_release addr width value
     | (F, F, T) => MEMval_conditional addr width value
     | (F, T, T) => MEMval_conditional_release addr width value
     | (T, F, F) => state_monad$throwS (Error_not_implemented "store.aq")
     | (T, T, F) => MEMval_strong_release addr width value
     | (T, F, T) => state_monad$throwS (Error_not_implemented "sc.aq")
     | (T, T, T) => MEMval_conditional_strong_release addr width value
     )))`;


(*val _get_Misa : Misa -> mword ty64*)

val _ = Define `
 ((get_Misa:Misa ->(64)words$word) (Mk_Misa (v))=  v)`;


(*val _set_Misa : register_ref regstate register_value Misa -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Misa:((regstate),(register_value),(Misa))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Misa v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_SV39_PTE : SV39_PTE -> mword ty64*)

(*val _set_SV39_PTE : register_ref regstate register_value SV39_PTE -> mword ty64 -> M unit*)

(*val _get_Misa_MXL : Misa -> mword ty2*)

val _ = Define `
 ((get_Misa_MXL:Misa ->(2)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 63 : int):ii) (( 62 : int):ii)  :  2 words$word)))`;


(*val _set_Misa_MXL : register_ref regstate register_value Misa -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Misa_MXL:((regstate),(register_value),(Misa))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):ii) (( 62 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_MXL : Misa -> mword ty2 -> Misa*)

val _ = Define `
 ((update_Misa_MXL:Misa ->(2)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 63 : int):ii) (( 62 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_Z : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_Z:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 25 : int):ii) (( 25 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_Z : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_Z:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 25 : int):ii) (( 25 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_Z : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_Z:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 25 : int):ii) (( 25 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_Y : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_Y:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 24 : int):ii) (( 24 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_Y : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_Y:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 24 : int):ii) (( 24 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_Y : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_Y:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 24 : int):ii) (( 24 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_X : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_X:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 23 : int):ii) (( 23 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_X : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_X:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 23 : int):ii) (( 23 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_X : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_X:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 23 : int):ii) (( 23 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_X : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_X : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_X : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_W : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_W:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 22 : int):ii) (( 22 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_W : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_W:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 22 : int):ii) (( 22 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_W : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_W:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 22 : int):ii) (( 22 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_W : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_W : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_W : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_V : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_V:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_V : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_V:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 21 : int):ii) (( 21 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_V : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_V:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 21 : int):ii) (( 21 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_V : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_V : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_V : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_U : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_U:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 20 : int):ii) (( 20 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_U : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_U:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 20 : int):ii) (( 20 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_U : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_U:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 20 : int):ii) (( 20 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_U : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_U : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_U : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_T : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_T:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 19 : int):ii) (( 19 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_T : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_T:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 19 : int):ii) (( 19 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_T : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_T:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 19 : int):ii) (( 19 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_S : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_S:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 18 : int):ii) (( 18 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_S : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_S:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 18 : int):ii) (( 18 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_S : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_S:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 18 : int):ii) (( 18 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_R : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_R:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 17 : int):ii) (( 17 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_R : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_R:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 17 : int):ii) (( 17 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_R : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_R:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 17 : int):ii) (( 17 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_R : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_R : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_R : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_Q : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_Q:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 16 : int):ii) (( 16 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_Q : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_Q:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 16 : int):ii) (( 16 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_Q : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_Q:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 16 : int):ii) (( 16 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_P : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_P:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 15 : int):ii) (( 15 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_P : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_P:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 15 : int):ii) (( 15 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_P : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_P:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 15 : int):ii) (( 15 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_O : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_O:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 14 : int):ii) (( 14 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_O : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_O:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 14 : int):ii) (( 14 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_O : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_O:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 14 : int):ii) (( 14 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_N : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_N:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 13 : int):ii) (( 13 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_N : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_N:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 13 : int):ii) (( 13 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_N : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_N:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 13 : int):ii) (( 13 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_M : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_M:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_M : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_M:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 12 : int):ii) (( 12 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_M : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_M:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 12 : int):ii) (( 12 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_L : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_L:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 11 : int):ii) (( 11 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_L : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_L:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):ii) (( 11 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_L : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_L:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 11 : int):ii) (( 11 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_K : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_K:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 10 : int):ii) (( 10 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_K : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_K:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 10 : int):ii) (( 10 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_K : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_K:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 10 : int):ii) (( 10 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_J : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_J:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_J : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_J:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):ii) (( 9 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_J : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_J:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_I : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_I:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_I : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_I:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_I : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_I:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_H : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_H:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_H : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_H:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 7 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_H : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_H:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_G : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_G:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_G : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_G:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):ii) (( 6 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_G : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_G:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_G : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_G : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_G : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_F : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_F:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_F : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_F:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_F : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_F:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_E : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_E:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_E : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_E:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_E : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_E:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_D : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_D:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_D : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_D:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):ii) (( 3 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_D : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_D:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_D : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_D : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_D : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_C : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_C:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_C : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_C:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):ii) (( 2 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_C : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_C:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_B : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_B:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_B : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_B:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_B : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_B:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


(*val _get_Misa_A : Misa -> mword ty1*)

val _ = Define `
 ((get_Misa_A:Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


(*val _set_Misa_A : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Misa_A:((regstate),(register_value),(Misa))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_A : Misa -> mword ty1 -> Misa*)

val _ = Define `
 ((update_Misa_A:Misa ->(1)words$word -> Misa) (Mk_Misa (v)) x=
    (Mk_Misa ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_A : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_A : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_A : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val legalize_misa : Misa -> mword ty64 -> Misa*)

val _ = Define `
 ((legalize_misa:Misa ->(64)words$word -> Misa) (m : Misa) (v : xlenbits)=  m)`;


(*val _get_Mstatus : Mstatus -> mword ty64*)

val _ = Define `
 ((get_Mstatus:Mstatus ->(64)words$word) (Mk_Mstatus (v))=  v)`;


(*val _set_Mstatus : register_ref regstate register_value Mstatus -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Mstatus:((regstate),(register_value),(Mstatus))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Mstatus v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_Mstatus_SD : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_SD:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 63 : int):ii) (( 63 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_SD : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_SD:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):ii) (( 63 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SD : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_SD:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 63 : int):ii) (( 63 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SD : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SD : Sstatus -> mword ty1*)

(*val _set_Sstatus_SD : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_SXL : Mstatus -> mword ty2*)

val _ = Define `
 ((get_Mstatus_SXL:Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 35 : int):ii) (( 34 : int):ii)  :  2 words$word)))`;


(*val _set_Mstatus_SXL : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Mstatus_SXL:((regstate),(register_value),(Mstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 35 : int):ii) (( 34 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SXL : Mstatus -> mword ty2 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_SXL:Mstatus ->(2)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 35 : int):ii) (( 34 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_UXL : Mstatus -> mword ty2*)

val _ = Define `
 ((get_Mstatus_UXL:Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 33 : int):ii) (( 32 : int):ii)  :  2 words$word)))`;


(*val _set_Mstatus_UXL : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Mstatus_UXL:((regstate),(register_value),(Mstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 33 : int):ii) (( 32 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_UXL : Mstatus -> mword ty2 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_UXL:Mstatus ->(2)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 33 : int):ii) (( 32 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_UXL : Sstatus -> mword ty2 -> Sstatus*)

(*val _get_Sstatus_UXL : Sstatus -> mword ty2*)

(*val _set_Sstatus_UXL : register_ref regstate register_value Sstatus -> mword ty2 -> M unit*)

(*val _get_Mstatus_TSR : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_TSR:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 22 : int):ii) (( 22 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_TSR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_TSR:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 22 : int):ii) (( 22 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_TSR : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_TSR:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 22 : int):ii) (( 22 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_TW : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_TW:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 21 : int):ii) (( 21 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_TW : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_TW:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 21 : int):ii) (( 21 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_TW : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_TW:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 21 : int):ii) (( 21 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_TVM : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_TVM:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 20 : int):ii) (( 20 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_TVM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_TVM:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 20 : int):ii) (( 20 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_TVM : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_TVM:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 20 : int):ii) (( 20 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_MXR : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_MXR:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 19 : int):ii) (( 19 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_MXR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_MXR:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 19 : int):ii) (( 19 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MXR : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_MXR:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 19 : int):ii) (( 19 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_MXR : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_MXR : Sstatus -> mword ty1*)

(*val _set_Sstatus_MXR : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_SUM : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_SUM:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 18 : int):ii) (( 18 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_SUM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_SUM:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 18 : int):ii) (( 18 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SUM : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_SUM:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 18 : int):ii) (( 18 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SUM : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SUM : Sstatus -> mword ty1*)

(*val _set_Sstatus_SUM : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_MPRV : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_MPRV:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 17 : int):ii) (( 17 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_MPRV : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_MPRV:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 17 : int):ii) (( 17 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MPRV : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_MPRV:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 17 : int):ii) (( 17 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_XS : Mstatus -> mword ty2*)

val _ = Define `
 ((get_Mstatus_XS:Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 16 : int):ii) (( 15 : int):ii)  :  2 words$word)))`;


(*val _set_Mstatus_XS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Mstatus_XS:((regstate),(register_value),(Mstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 16 : int):ii) (( 15 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_XS : Mstatus -> mword ty2 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_XS:Mstatus ->(2)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 16 : int):ii) (( 15 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_XS : Sstatus -> mword ty2 -> Sstatus*)

(*val _get_Sstatus_XS : Sstatus -> mword ty2*)

(*val _set_Sstatus_XS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit*)

(*val _get_Mstatus_FS : Mstatus -> mword ty2*)

val _ = Define `
 ((get_Mstatus_FS:Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 14 : int):ii) (( 13 : int):ii)  :  2 words$word)))`;


(*val _set_Mstatus_FS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Mstatus_FS:((regstate),(register_value),(Mstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 14 : int):ii) (( 13 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_FS : Mstatus -> mword ty2 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_FS:Mstatus ->(2)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 14 : int):ii) (( 13 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_FS : Sstatus -> mword ty2 -> Sstatus*)

(*val _get_Sstatus_FS : Sstatus -> mword ty2*)

(*val _set_Sstatus_FS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit*)

(*val _get_Mstatus_MPP : Mstatus -> mword ty2*)

val _ = Define `
 ((get_Mstatus_MPP:Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 12 : int):ii) (( 11 : int):ii)  :  2 words$word)))`;


(*val _set_Mstatus_MPP : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Mstatus_MPP:((regstate),(register_value),(Mstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 12 : int):ii) (( 11 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MPP : Mstatus -> mword ty2 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_MPP:Mstatus ->(2)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 12 : int):ii) (( 11 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_SPP : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_SPP:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_SPP : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_SPP:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SPP : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_SPP:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SPP : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SPP : Sstatus -> mword ty1*)

(*val _set_Sstatus_SPP : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_MPIE : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_MPIE:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_MPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_MPIE:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 7 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MPIE : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_MPIE:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_SPIE : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_SPIE:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_SPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_SPIE:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SPIE : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_SPIE:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SPIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SPIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_SPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_UPIE : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_UPIE:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_UPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_UPIE:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_UPIE : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_UPIE:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_UPIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_UPIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_UPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_MIE : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_MIE:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_MIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_MIE:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):ii) (( 3 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MIE : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_MIE:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii) x  :  64 words$word))))`;


(*val _get_Mstatus_SIE : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_SIE:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_SIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_SIE:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SIE : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_SIE:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_SIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_UIE : Mstatus -> mword ty1*)

val _ = Define `
 ((get_Mstatus_UIE:Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


(*val _set_Mstatus_UIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mstatus_UIE:((regstate),(register_value),(Mstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_UIE : Mstatus -> mword ty1 -> Mstatus*)

val _ = Define `
 ((update_Mstatus_UIE:Mstatus ->(1)words$word -> Mstatus) (Mk_Mstatus (v)) x=
    (Mk_Mstatus ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val _update_Sstatus_UIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_UIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_UIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val legalize_mstatus : Mstatus -> mword ty64 -> Mstatus*)

val _ = Define `
 ((legalize_mstatus:Mstatus ->(64)words$word -> Mstatus) (o1 : Mstatus) (v : xlenbits)=
    (let (m : Mstatus) = (Mk_Mstatus v) in
   let m = (update_Mstatus_XS m ((extStatus_to_bits Off  :  2 words$word))) in
   let m =
     (update_Mstatus_SD m
       ((bool_to_bits
           ((((((((extStatus_to_bits ((extStatus_of_bits ((get_Mstatus_FS m  :  2 words$word))))
                      :  2 words$word)) = ((extStatus_to_bits Dirty  :  2 words$word))))) \/ (((((extStatus_to_bits ((extStatus_of_bits ((get_Mstatus_XS m  :  2 words$word))))
                      :  2 words$word)) = ((extStatus_to_bits Dirty  :  2 words$word))))))))
          :  1 words$word))) in
   let m = (update_Mstatus_SXL m ((get_Mstatus_SXL o1  :  2 words$word))) in
   let m = (update_Mstatus_UXL m ((get_Mstatus_UXL o1  :  2 words$word))) in
   let m = (update_Mstatus_UPIE m ((bool_to_bits F  :  1 words$word))) in
   update_Mstatus_UIE m ((bool_to_bits F  :  1 words$word))))`;


(*val cur_Architecture : unit -> M Architecture*)

val _ = Define `
 ((cur_Architecture:unit ->(regstate)state_monad$sequential_state ->(((Architecture),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) .  state_monad$bindS
   (case w__0 of
     Machine => state_monad$bindS
      (state_monad$read_regS misa_ref) (\ (w__1 : Misa) .  state_monad$returnS ((get_Misa_MXL w__1  :  2 words$word)))
   | Supervisor => state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__2 : Mstatus) .  state_monad$returnS ((get_Mstatus_SXL w__2  :  2 words$word)))
   | User => state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__3 : Mstatus) .  state_monad$returnS ((get_Mstatus_UXL w__3  :  2 words$word)))
   ) (\ (a : arch_xlen) . 
   (case ((architecture a)) of
     SOME (a) => state_monad$returnS a
   | NONE => internal_error "Invalid current architecture"
   )))))`;


(*val in32BitMode : unit -> M bool*)

val _ = Define `
 ((in32BitMode:unit ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS (cur_Architecture () ) (\ (w__0 : Architecture) .  state_monad$returnS (((w__0 = RV32))))))`;


(*val haveAtomics : unit -> M bool*)

val _ = Define `
 ((haveAtomics:unit ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS misa_ref) (\ (w__0 : Misa) . 
   state_monad$returnS (((((get_Misa_A w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))`;


(*val haveRVC : unit -> M bool*)

val _ = Define `
 ((haveRVC:unit ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS misa_ref) (\ (w__0 : Misa) . 
   state_monad$returnS (((((get_Misa_C w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))`;


(*val haveMulDiv : unit -> M bool*)

val _ = Define `
 ((haveMulDiv:unit ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS misa_ref) (\ (w__0 : Misa) . 
   state_monad$returnS (((((get_Misa_M w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))`;


(*val haveFP : unit -> M bool*)

val _ = Define `
 ((haveFP:unit ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =
    (state$or_boolS
     ( state_monad$bindS(state_monad$read_regS misa_ref) (\ (w__0 : Misa) . 
      state_monad$returnS (((((get_Misa_F w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))))
     ( state_monad$bindS(state_monad$read_regS misa_ref) (\ (w__1 : Misa) . 
      state_monad$returnS (((((get_Misa_D w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))))))`;


(*val _get_Minterrupts : Minterrupts -> mword ty64*)

val _ = Define `
 ((get_Minterrupts:Minterrupts ->(64)words$word) (Mk_Minterrupts (v))=  v)`;


(*val _set_Minterrupts : register_ref regstate register_value Minterrupts -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Minterrupts:((regstate),(register_value),(Minterrupts))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Minterrupts v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_Minterrupts_MEI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_MEI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 11 : int):ii) (( 11 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_MEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_MEI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):ii) (( 11 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_MEI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_MEI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 11 : int):ii) (( 11 : int):ii) x  :  64 words$word))))`;


(*val _get_Minterrupts_SEI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_SEI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_SEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_SEI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):ii) (( 9 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_SEI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_SEI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_SEI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_SEI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_SEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_UEI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_UEI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_UEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_UEI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_UEI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_UEI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_UEI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_UEI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_UEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_MTI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_MTI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_MTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_MTI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 7 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_MTI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_MTI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii) x  :  64 words$word))))`;


(*val _get_Minterrupts_STI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_STI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_STI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_STI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_STI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_STI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_STI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_STI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_STI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_UTI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_UTI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_UTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_UTI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_UTI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_UTI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_UTI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_UTI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_UTI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_MSI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_MSI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_MSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_MSI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):ii) (( 3 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_MSI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_MSI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii) x  :  64 words$word))))`;


(*val _get_Minterrupts_SSI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_SSI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_SSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_SSI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_SSI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_SSI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_SSI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_SSI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_SSI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_USI : Minterrupts -> mword ty1*)

val _ = Define `
 ((get_Minterrupts_USI:Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


(*val _set_Minterrupts_USI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Minterrupts_USI:((regstate),(register_value),(Minterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_USI : Minterrupts -> mword ty1 -> Minterrupts*)

val _ = Define `
 ((update_Minterrupts_USI:Minterrupts ->(1)words$word -> Minterrupts) (Mk_Minterrupts (v)) x=
    (Mk_Minterrupts ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_USI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_USI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_USI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val legalize_mip : Minterrupts -> mword ty64 -> Minterrupts*)

val _ = Define `
 ((legalize_mip:Minterrupts ->(64)words$word -> Minterrupts) (o1 : Minterrupts) (v : xlenbits)=
    (let v = (Mk_Minterrupts v) in
   let m = (update_Minterrupts_SEI o1 ((get_Minterrupts_SEI v  :  1 words$word))) in
   let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  :  1 words$word))) in
   update_Minterrupts_SSI m ((get_Minterrupts_SSI v  :  1 words$word))))`;


(*val legalize_mie : Minterrupts -> mword ty64 -> Minterrupts*)

val _ = Define `
 ((legalize_mie:Minterrupts ->(64)words$word -> Minterrupts) (o1 : Minterrupts) (v : xlenbits)=
    (let v = (Mk_Minterrupts v) in
   let m = (update_Minterrupts_MEI o1 ((get_Minterrupts_MEI v  :  1 words$word))) in
   let m = (update_Minterrupts_MTI m ((get_Minterrupts_MTI v  :  1 words$word))) in
   let m = (update_Minterrupts_MSI m ((get_Minterrupts_MSI v  :  1 words$word))) in
   let m = (update_Minterrupts_SEI m ((get_Minterrupts_SEI v  :  1 words$word))) in
   let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  :  1 words$word))) in
   update_Minterrupts_SSI m ((get_Minterrupts_SSI v  :  1 words$word))))`;


(*val legalize_mideleg : Minterrupts -> mword ty64 -> Minterrupts*)

val _ = Define `
 ((legalize_mideleg:Minterrupts ->(64)words$word -> Minterrupts) (o1 : Minterrupts) (v : xlenbits)=
    (let m = (Mk_Minterrupts v) in
   let m = (update_Minterrupts_MEI m ((bool_to_bits F  :  1 words$word))) in
   let m = (update_Minterrupts_MTI m ((bool_to_bits F  :  1 words$word))) in
   update_Minterrupts_MSI m ((bool_to_bits F  :  1 words$word))))`;


(*val _get_Medeleg : Medeleg -> mword ty64*)

val _ = Define `
 ((get_Medeleg:Medeleg ->(64)words$word) (Mk_Medeleg (v))=  v)`;


(*val _set_Medeleg : register_ref regstate register_value Medeleg -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Medeleg:((regstate),(register_value),(Medeleg))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Medeleg v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_SAMO_Page_Fault:Medeleg ->(1)words$word) (Mk_Medeleg (v))=
    ((subrange_vec_dec v (( 15 : int):ii) (( 15 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_SAMO_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_SAMO_Page_Fault:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 15 : int):ii) (( 15 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_SAMO_Page_Fault:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 15 : int):ii) (( 15 : int):ii) x  :  64 words$word))))`;


(*val _get_Medeleg_Load_Page_Fault : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Load_Page_Fault:Medeleg ->(1)words$word) (Mk_Medeleg (v))=
    ((subrange_vec_dec v (( 13 : int):ii) (( 13 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Load_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Load_Page_Fault:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 13 : int):ii) (( 13 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Load_Page_Fault : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Load_Page_Fault:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 13 : int):ii) (( 13 : int):ii) x  :  64 words$word))))`;


(*val _get_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Fetch_Page_Fault:Medeleg ->(1)words$word) (Mk_Medeleg (v))=
    ((subrange_vec_dec v (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Fetch_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Fetch_Page_Fault:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 12 : int):ii) (( 12 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Fetch_Page_Fault:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 12 : int):ii) (( 12 : int):ii) x  :  64 words$word))))`;


(*val _get_Medeleg_MEnvCall : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_MEnvCall:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 10 : int):ii) (( 10 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_MEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_MEnvCall:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 10 : int):ii) (( 10 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_MEnvCall : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_MEnvCall:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 10 : int):ii) (( 10 : int):ii) x  :  64 words$word))))`;


(*val _get_Medeleg_SEnvCall : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_SEnvCall:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_SEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_SEnvCall:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):ii) (( 9 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SEnvCall : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_SEnvCall:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii) x  :  64 words$word))))`;


(*val _get_Medeleg_UEnvCall : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_UEnvCall:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_UEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_UEnvCall:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_UEnvCall : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_UEnvCall:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_UEnvCall : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_UEnvCall : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_UEnvCall : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_SAMO_Access_Fault:Medeleg ->(1)words$word) (Mk_Medeleg (v))=
    ((subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_SAMO_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_SAMO_Access_Fault:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 7 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_SAMO_Access_Fault:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_SAMO_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_SAMO_Addr_Align:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_SAMO_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_SAMO_Addr_Align:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):ii) (( 6 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_SAMO_Addr_Align:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_SAMO_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Load_Access_Fault : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Load_Access_Fault:Medeleg ->(1)words$word) (Mk_Medeleg (v))=
    ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Load_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Load_Access_Fault:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Load_Access_Fault : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Load_Access_Fault:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Load_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Load_Addr_Align : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Load_Addr_Align:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Load_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Load_Addr_Align:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Load_Addr_Align : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Load_Addr_Align:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Load_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Breakpoint : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Breakpoint:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Breakpoint : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Breakpoint:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):ii) (( 3 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Breakpoint : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Breakpoint:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Breakpoint : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Breakpoint : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Breakpoint : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Illegal_Instr : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Illegal_Instr:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Illegal_Instr : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Illegal_Instr:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):ii) (( 2 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Illegal_Instr : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Illegal_Instr:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Illegal_Instr : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Fetch_Access_Fault:Medeleg ->(1)words$word) (Mk_Medeleg (v))=
    ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Fetch_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Fetch_Access_Fault:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Fetch_Access_Fault:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Fetch_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1*)

val _ = Define `
 ((get_Medeleg_Fetch_Addr_Align:Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


(*val _set_Medeleg_Fetch_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Medeleg_Fetch_Addr_Align:((regstate),(register_value),(Medeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1 -> Medeleg*)

val _ = Define `
 ((update_Medeleg_Fetch_Addr_Align:Medeleg ->(1)words$word -> Medeleg) (Mk_Medeleg (v)) x=
    (Mk_Medeleg ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Fetch_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val legalize_medeleg : Medeleg -> mword ty64 -> Medeleg*)

val _ = Define `
 ((legalize_medeleg:Medeleg ->(64)words$word -> Medeleg) (o1 : Medeleg) (v : xlenbits)=
    (let m = (Mk_Medeleg v) in
   update_Medeleg_MEnvCall m ((bool_to_bits F  :  1 words$word))))`;


(*val _get_Mtvec : Mtvec -> mword ty64*)

val _ = Define `
 ((get_Mtvec:Mtvec ->(64)words$word) (Mk_Mtvec (v))=  v)`;


(*val _set_Mtvec : register_ref regstate register_value Mtvec -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Mtvec:((regstate),(register_value),(Mtvec))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Mtvec v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_Mtvec_Base : Mtvec -> mword ty62*)

val _ = Define `
 ((get_Mtvec_Base:Mtvec ->(62)words$word) (Mk_Mtvec (v))=  ((subrange_vec_dec v (( 63 : int):ii) (( 2 : int):ii)  :  62 words$word)))`;


(*val _set_Mtvec_Base : register_ref regstate register_value Mtvec -> mword ty62 -> M unit*)

val _ = Define `
 ((set_Mtvec_Base:((regstate),(register_value),(Mtvec))register_ref ->(62)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mtvec) . 
   let r = ((get_Mtvec w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):ii) (( 2 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mtvec r))))`;


(*val _update_Mtvec_Base : Mtvec -> mword ty62 -> Mtvec*)

val _ = Define `
 ((update_Mtvec_Base:Mtvec ->(62)words$word -> Mtvec) (Mk_Mtvec (v)) x=
    (Mk_Mtvec ((update_subrange_vec_dec v (( 63 : int):ii) (( 2 : int):ii) x  :  64 words$word))))`;


(*val _get_Mtvec_Mode : Mtvec -> mword ty2*)

val _ = Define `
 ((get_Mtvec_Mode:Mtvec ->(2)words$word) (Mk_Mtvec (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)))`;


(*val _set_Mtvec_Mode : register_ref regstate register_value Mtvec -> mword ty2 -> M unit*)

val _ = Define `
 ((set_Mtvec_Mode:((regstate),(register_value),(Mtvec))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mtvec) . 
   let r = ((get_Mtvec w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mtvec r))))`;


(*val _update_Mtvec_Mode : Mtvec -> mword ty2 -> Mtvec*)

val _ = Define `
 ((update_Mtvec_Mode:Mtvec ->(2)words$word -> Mtvec) (Mk_Mtvec (v)) x=
    (Mk_Mtvec ((update_subrange_vec_dec v (( 1 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val _update_Satp64_Mode : Satp64 -> mword ty4 -> Satp64*)

(*val _get_Satp64_Mode : Satp64 -> mword ty4*)

(*val _set_Satp64_Mode : register_ref regstate register_value Satp64 -> mword ty4 -> M unit*)

(*val legalize_tvec : Mtvec -> mword ty64 -> Mtvec*)

val _ = Define `
 ((legalize_tvec:Mtvec ->(64)words$word -> Mtvec) (o1 : Mtvec) (v : xlenbits)=
    (let v = (Mk_Mtvec v) in
   (case ((trapVectorMode_of_bits ((get_Mtvec_Mode v  :  2 words$word)))) of
     TV_Direct => v
   | TV_Vector => v
   | _ => update_Mtvec_Mode v ((get_Mtvec_Mode o1  :  2 words$word))
   )))`;


(*val _get_Mcause : Mcause -> mword ty64*)

val _ = Define `
 ((get_Mcause:Mcause ->(64)words$word) (Mk_Mcause (v))=  v)`;


(*val _set_Mcause : register_ref regstate register_value Mcause -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Mcause:((regstate),(register_value),(Mcause))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Mcause v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_Mcause_IsInterrupt : Mcause -> mword ty1*)

val _ = Define `
 ((get_Mcause_IsInterrupt:Mcause ->(1)words$word) (Mk_Mcause (v))=  ((subrange_vec_dec v (( 63 : int):ii) (( 63 : int):ii)  :  1 words$word)))`;


(*val _set_Mcause_IsInterrupt : register_ref regstate register_value Mcause -> mword ty1 -> M unit*)

val _ = Define `
 ((set_Mcause_IsInterrupt:((regstate),(register_value),(Mcause))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mcause) . 
   let r = ((get_Mcause w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):ii) (( 63 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mcause r))))`;


(*val _update_Mcause_IsInterrupt : Mcause -> mword ty1 -> Mcause*)

val _ = Define `
 ((update_Mcause_IsInterrupt:Mcause ->(1)words$word -> Mcause) (Mk_Mcause (v)) x=
    (Mk_Mcause ((update_subrange_vec_dec v (( 63 : int):ii) (( 63 : int):ii) x  :  64 words$word))))`;


(*val _get_Mcause_Cause : Mcause -> mword ty63*)

val _ = Define `
 ((get_Mcause_Cause:Mcause ->(63)words$word) (Mk_Mcause (v))=  ((subrange_vec_dec v (( 62 : int):ii) (( 0 : int):ii)  :  63 words$word)))`;


(*val _set_Mcause_Cause : register_ref regstate register_value Mcause -> mword ty63 -> M unit*)

val _ = Define `
 ((set_Mcause_Cause:((regstate),(register_value),(Mcause))register_ref ->(63)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Mcause) . 
   let r = ((get_Mcause w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 62 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Mcause r))))`;


(*val _update_Mcause_Cause : Mcause -> mword ty63 -> Mcause*)

val _ = Define `
 ((update_Mcause_Cause:Mcause ->(63)words$word -> Mcause) (Mk_Mcause (v)) x=
    (Mk_Mcause ((update_subrange_vec_dec v (( 62 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val tvec_addr : Mtvec -> Mcause -> maybe (mword ty64)*)

val _ = Define `
 ((tvec_addr:Mtvec -> Mcause ->((64)words$word)option) (m : Mtvec) (c : Mcause)=
    (let (base : xlenbits) =
     ((concat_vec ((get_Mtvec_Base m  :  62 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
       :  64 words$word)) in
   (case ((trapVectorMode_of_bits ((get_Mtvec_Mode m  :  2 words$word)))) of
     TV_Direct => SOME base
   | TV_Vector =>
      if (((((get_Mcause_IsInterrupt c  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
      then
        SOME ((add_vec base
                 ((shift_bits_left
                     ((EXTZ (( 64 : int):ii) ((get_Mcause_Cause c  :  63 words$word))  :  64 words$word))
                     (vec_of_bits [B1;B0]  :  2 words$word)
                    :  64 words$word))
                :  64 words$word))
      else SOME base
   | TV_Reserved => NONE
   )))`;


(*val legalize_xepc : mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((legalize_xepc:(64)words$word ->(regstate)state_monad$sequential_state ->((((64)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) v=  (state_monad$bindS
   (haveRVC () ) (\ (w__0 : bool) . 
   state_monad$returnS ((and_vec v
              ((EXTS (( 64 : int):ii)
                  (if w__0 then (vec_of_bits [B1;B1;B0]  :  3 words$word)
                   else (vec_of_bits [B1;B0;B0]  :  3 words$word))
                 :  64 words$word))
             :  64 words$word)))))`;


(*val _get_Sstatus : Sstatus -> mword ty64*)

val _ = Define `
 ((get_Sstatus:Sstatus ->(64)words$word) (Mk_Sstatus (v))=  v)`;


(*val _set_Sstatus : register_ref regstate register_value Sstatus -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Sstatus:((regstate),(register_value),(Sstatus))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Sstatus v) in
   state_monad$write_regS r_ref r)))`;


val _ = Define `
 ((get_Sstatus_SD:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 63 : int):ii) (( 63 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SD:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):ii) (( 63 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SD:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 63 : int):ii) (( 63 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_UXL:Sstatus ->(2)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 33 : int):ii) (( 32 : int):ii)  :  2 words$word)))`;


val _ = Define `
 ((set_Sstatus_UXL:((regstate),(register_value),(Sstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 33 : int):ii) (( 32 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_UXL:Sstatus ->(2)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 33 : int):ii) (( 32 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_MXR:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 19 : int):ii) (( 19 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_MXR:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 19 : int):ii) (( 19 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_MXR:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 19 : int):ii) (( 19 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SUM:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 18 : int):ii) (( 18 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SUM:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 18 : int):ii) (( 18 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SUM:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 18 : int):ii) (( 18 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_XS:Sstatus ->(2)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 16 : int):ii) (( 15 : int):ii)  :  2 words$word)))`;


val _ = Define `
 ((set_Sstatus_XS:((regstate),(register_value),(Sstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 16 : int):ii) (( 15 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_XS:Sstatus ->(2)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 16 : int):ii) (( 15 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_FS:Sstatus ->(2)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 14 : int):ii) (( 13 : int):ii)  :  2 words$word)))`;


val _ = Define `
 ((set_Sstatus_FS:((regstate),(register_value),(Sstatus))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 14 : int):ii) (( 13 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_FS:Sstatus ->(2)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 14 : int):ii) (( 13 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SPP:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SPP:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SPP:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SPIE:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SPIE:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SPIE:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_UPIE:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_UPIE:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_UPIE:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SIE:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SIE:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SIE:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_UIE:Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_UIE:((regstate),(register_value),(Sstatus))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_UIE:Sstatus ->(1)words$word -> Sstatus) (Mk_Sstatus (v)) x=
    (Mk_Sstatus ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val lower_mstatus : Mstatus -> Sstatus*)

val _ = Define `
 ((lower_mstatus:Mstatus -> Sstatus) m=
    (let s = (Mk_Sstatus ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))) in
   let s = (update_Sstatus_SD s ((get_Mstatus_SD m  :  1 words$word))) in
   let s = (update_Sstatus_UXL s ((get_Mstatus_UXL m  :  2 words$word))) in
   let s = (update_Sstatus_MXR s ((get_Mstatus_MXR m  :  1 words$word))) in
   let s = (update_Sstatus_SUM s ((get_Mstatus_SUM m  :  1 words$word))) in
   let s = (update_Sstatus_XS s ((get_Mstatus_XS m  :  2 words$word))) in
   let s = (update_Sstatus_FS s ((get_Mstatus_FS m  :  2 words$word))) in
   let s = (update_Sstatus_SPP s ((get_Mstatus_SPP m  :  1 words$word))) in
   let s = (update_Sstatus_SPIE s ((get_Mstatus_SPIE m  :  1 words$word))) in
   let s = (update_Sstatus_UPIE s ((get_Mstatus_UPIE m  :  1 words$word))) in
   let s = (update_Sstatus_SIE s ((get_Mstatus_SIE m  :  1 words$word))) in
   update_Sstatus_UIE s ((get_Mstatus_UIE m  :  1 words$word))))`;


(*val lift_sstatus : Mstatus -> Sstatus -> Mstatus*)

val _ = Define `
 ((lift_sstatus:Mstatus -> Sstatus -> Mstatus) (m : Mstatus) (s : Sstatus)=
    (let m = (update_Mstatus_SD m ((get_Sstatus_SD s  :  1 words$word))) in
   let m = (update_Mstatus_UXL m ((get_Sstatus_UXL s  :  2 words$word))) in
   let m = (update_Mstatus_MXR m ((get_Sstatus_MXR s  :  1 words$word))) in
   let m = (update_Mstatus_SUM m ((get_Sstatus_SUM s  :  1 words$word))) in
   let m = (update_Mstatus_XS m ((get_Sstatus_XS s  :  2 words$word))) in
   let m = (update_Mstatus_FS m ((get_Sstatus_FS s  :  2 words$word))) in
   let m = (update_Mstatus_SPP m ((get_Sstatus_SPP s  :  1 words$word))) in
   let m = (update_Mstatus_SPIE m ((get_Sstatus_SPIE s  :  1 words$word))) in
   let m = (update_Mstatus_UPIE m ((get_Sstatus_UPIE s  :  1 words$word))) in
   let m = (update_Mstatus_SIE m ((get_Sstatus_SIE s  :  1 words$word))) in
   update_Mstatus_UIE m ((get_Sstatus_UIE s  :  1 words$word))))`;


(*val legalize_sstatus : Mstatus -> mword ty64 -> Mstatus*)

val _ = Define `
 ((legalize_sstatus:Mstatus ->(64)words$word -> Mstatus) (m : Mstatus) (v : xlenbits)=  (lift_sstatus m (Mk_Sstatus v)))`;


(*val _get_Sedeleg : Sedeleg -> mword ty64*)

val _ = Define `
 ((get_Sedeleg:Sedeleg ->(64)words$word) (Mk_Sedeleg (v))=  v)`;


(*val _set_Sedeleg : register_ref regstate register_value Sedeleg -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Sedeleg:((regstate),(register_value),(Sedeleg))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Sedeleg v) in
   state_monad$write_regS r_ref r)))`;


val _ = Define `
 ((get_Sedeleg_UEnvCall:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_UEnvCall:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_UEnvCall:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_SAMO_Access_Fault:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=
    ((subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_SAMO_Access_Fault:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 7 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_SAMO_Access_Fault:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_SAMO_Addr_Align:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_SAMO_Addr_Align:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):ii) (( 6 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_SAMO_Addr_Align:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Load_Access_Fault:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=
    ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Load_Access_Fault:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Load_Access_Fault:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Load_Addr_Align:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Load_Addr_Align:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Load_Addr_Align:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Breakpoint:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Breakpoint:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):ii) (( 3 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Breakpoint:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Illegal_Instr:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Illegal_Instr:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):ii) (( 2 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Illegal_Instr:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Fetch_Access_Fault:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=
    ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Fetch_Access_Fault:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Fetch_Access_Fault:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Fetch_Addr_Align:Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Fetch_Addr_Align:((regstate),(register_value),(Sedeleg))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Fetch_Addr_Align:Sedeleg ->(1)words$word -> Sedeleg) (Mk_Sedeleg (v)) x=
    (Mk_Sedeleg ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val legalize_sedeleg : Sedeleg -> mword ty64 -> Sedeleg*)

val _ = Define `
 ((legalize_sedeleg:Sedeleg ->(64)words$word -> Sedeleg) (s : Sedeleg) (v : xlenbits)=
    (Mk_Sedeleg ((EXTZ (( 64 : int):ii) ((subrange_vec_dec v (( 8 : int):ii) (( 0 : int):ii)  :  9 words$word))  :  64 words$word))))`;


(*val _get_Sinterrupts : Sinterrupts -> mword ty64*)

val _ = Define `
 ((get_Sinterrupts:Sinterrupts ->(64)words$word) (Mk_Sinterrupts (v))=  v)`;


(*val _set_Sinterrupts : register_ref regstate register_value Sinterrupts -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Sinterrupts:((regstate),(register_value),(Sinterrupts))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Sinterrupts v) in
   state_monad$write_regS r_ref r)))`;


val _ = Define `
 ((get_Sinterrupts_SEI:Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_SEI:((regstate),(register_value),(Sinterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):ii) (( 9 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_SEI:Sinterrupts ->(1)words$word -> Sinterrupts) (Mk_Sinterrupts (v)) x=
    (Mk_Sinterrupts ((update_subrange_vec_dec v (( 9 : int):ii) (( 9 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_UEI:Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_UEI:((regstate),(register_value),(Sinterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_UEI:Sinterrupts ->(1)words$word -> Sinterrupts) (Mk_Sinterrupts (v)) x=
    (Mk_Sinterrupts ((update_subrange_vec_dec v (( 8 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_STI:Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_STI:((regstate),(register_value),(Sinterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_STI:Sinterrupts ->(1)words$word -> Sinterrupts) (Mk_Sinterrupts (v)) x=
    (Mk_Sinterrupts ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_UTI:Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_UTI:((regstate),(register_value),(Sinterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_UTI:Sinterrupts ->(1)words$word -> Sinterrupts) (Mk_Sinterrupts (v)) x=
    (Mk_Sinterrupts ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_SSI:Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_SSI:((regstate),(register_value),(Sinterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_SSI:Sinterrupts ->(1)words$word -> Sinterrupts) (Mk_Sinterrupts (v)) x=
    (Mk_Sinterrupts ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_USI:Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_USI:((regstate),(register_value),(Sinterrupts))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_USI:Sinterrupts ->(1)words$word -> Sinterrupts) (Mk_Sinterrupts (v)) x=
    (Mk_Sinterrupts ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val lower_mip : Minterrupts -> Minterrupts -> Sinterrupts*)

val _ = Define `
 ((lower_mip:Minterrupts -> Minterrupts -> Sinterrupts) (m : Minterrupts) (d : Minterrupts)=
    (let (s : Sinterrupts) =
     (Mk_Sinterrupts ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))) in
   let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  :  1 words$word)) ((get_Minterrupts_SEI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  :  1 words$word)) ((get_Minterrupts_STI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  :  1 words$word)) ((get_Minterrupts_SSI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  :  1 words$word)) ((get_Minterrupts_UEI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  :  1 words$word)) ((get_Minterrupts_UTI d  :  1 words$word))
          :  1 words$word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  :  1 words$word)) ((get_Minterrupts_USI d  :  1 words$word))
        :  1 words$word))))`;


(*val lower_mie : Minterrupts -> Minterrupts -> Sinterrupts*)

val _ = Define `
 ((lower_mie:Minterrupts -> Minterrupts -> Sinterrupts) (m : Minterrupts) (d : Minterrupts)=
    (let (s : Sinterrupts) =
     (Mk_Sinterrupts ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))) in
   let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  :  1 words$word)) ((get_Minterrupts_SEI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  :  1 words$word)) ((get_Minterrupts_STI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  :  1 words$word)) ((get_Minterrupts_SSI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  :  1 words$word)) ((get_Minterrupts_UEI d  :  1 words$word))
          :  1 words$word))) in
   let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  :  1 words$word)) ((get_Minterrupts_UTI d  :  1 words$word))
          :  1 words$word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  :  1 words$word)) ((get_Minterrupts_USI d  :  1 words$word))
        :  1 words$word))))`;


(*val lift_sip : Minterrupts -> Minterrupts -> Sinterrupts -> Minterrupts*)

val _ = Define `
 ((lift_sip:Minterrupts -> Minterrupts -> Sinterrupts -> Minterrupts) (o1 : Minterrupts) (d : Minterrupts) (s : Sinterrupts)=
    (let (m : Minterrupts) = o1 in
   let m =
     (update_Minterrupts_SSI m
       ((and_vec ((get_Sinterrupts_SSI s  :  1 words$word)) ((get_Minterrupts_SSI d  :  1 words$word))
          :  1 words$word))) in
   let m =
     (update_Minterrupts_UEI m
       ((and_vec ((get_Minterrupts_UEI m  :  1 words$word)) ((get_Minterrupts_UEI d  :  1 words$word))
          :  1 words$word))) in
   update_Minterrupts_USI m
     ((and_vec ((get_Minterrupts_USI m  :  1 words$word)) ((get_Minterrupts_USI d  :  1 words$word))
        :  1 words$word))))`;


(*val legalize_sip : Minterrupts -> Minterrupts -> mword ty64 -> Minterrupts*)

val _ = Define `
 ((legalize_sip:Minterrupts -> Minterrupts ->(64)words$word -> Minterrupts) (m : Minterrupts) (d : Minterrupts) (v : xlenbits)=
    (lift_sip m d (Mk_Sinterrupts v)))`;


(*val lift_sie : Minterrupts -> Minterrupts -> Sinterrupts -> Minterrupts*)

val _ = Define `
 ((lift_sie:Minterrupts -> Minterrupts -> Sinterrupts -> Minterrupts) (o1 : Minterrupts) (d : Minterrupts) (s : Sinterrupts)=
    (let (m : Minterrupts) = o1 in
   let m =
     (if (((((get_Minterrupts_SEI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_SEI m ((get_Sinterrupts_SEI s  :  1 words$word))
     else m) in
   let m =
     (if (((((get_Minterrupts_STI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_STI m ((get_Sinterrupts_STI s  :  1 words$word))
     else m) in
   let m =
     (if (((((get_Minterrupts_SSI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_SSI m ((get_Sinterrupts_SSI s  :  1 words$word))
     else m) in
   let m =
     (if (((((get_Minterrupts_UEI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  :  1 words$word))
     else m) in
   let m =
     (if (((((get_Minterrupts_UTI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_UTI m ((get_Sinterrupts_UTI s  :  1 words$word))
     else m) in
   if (((((get_Minterrupts_USI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
     update_Minterrupts_USI m ((get_Sinterrupts_USI s  :  1 words$word))
   else m))`;


(*val legalize_sie : Minterrupts -> Minterrupts -> mword ty64 -> Minterrupts*)

val _ = Define `
 ((legalize_sie:Minterrupts -> Minterrupts ->(64)words$word -> Minterrupts) (m : Minterrupts) (d : Minterrupts) (v : xlenbits)=
    (lift_sie m d (Mk_Sinterrupts v)))`;


(*val _get_Satp64 : Satp64 -> mword ty64*)

val _ = Define `
 ((get_Satp64:Satp64 ->(64)words$word) (Mk_Satp64 (v))=  v)`;


(*val _set_Satp64 : register_ref regstate register_value Satp64 -> mword ty64 -> M unit*)

val _ = Define `
 ((set_Satp64:((regstate),(register_value),(Satp64))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_Satp64 v) in
   state_monad$write_regS r_ref r)))`;


val _ = Define `
 ((get_Satp64_Mode:Satp64 ->(4)words$word) (Mk_Satp64 (v))=  ((subrange_vec_dec v (( 63 : int):ii) (( 60 : int):ii)  :  4 words$word)))`;


val _ = Define `
 ((set_Satp64_Mode:((regstate),(register_value),(Satp64))register_ref ->(4)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Satp64) . 
   let r = ((get_Satp64 w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):ii) (( 60 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Satp64 r))))`;


val _ = Define `
 ((update_Satp64_Mode:Satp64 ->(4)words$word -> Satp64) (Mk_Satp64 (v)) x=
    (Mk_Satp64 ((update_subrange_vec_dec v (( 63 : int):ii) (( 60 : int):ii) x  :  64 words$word))))`;


(*val _get_Satp64_Asid : Satp64 -> mword ty16*)

val _ = Define `
 ((get_Satp64_Asid:Satp64 ->(16)words$word) (Mk_Satp64 (v))=  ((subrange_vec_dec v (( 59 : int):ii) (( 44 : int):ii)  :  16 words$word)))`;


(*val _set_Satp64_Asid : register_ref regstate register_value Satp64 -> mword ty16 -> M unit*)

val _ = Define `
 ((set_Satp64_Asid:((regstate),(register_value),(Satp64))register_ref ->(16)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Satp64) . 
   let r = ((get_Satp64 w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 59 : int):ii) (( 44 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Satp64 r))))`;


(*val _update_Satp64_Asid : Satp64 -> mword ty16 -> Satp64*)

val _ = Define `
 ((update_Satp64_Asid:Satp64 ->(16)words$word -> Satp64) (Mk_Satp64 (v)) x=
    (Mk_Satp64 ((update_subrange_vec_dec v (( 59 : int):ii) (( 44 : int):ii) x  :  64 words$word))))`;


(*val _get_Satp64_PPN : Satp64 -> mword ty44*)

val _ = Define `
 ((get_Satp64_PPN:Satp64 ->(44)words$word) (Mk_Satp64 (v))=  ((subrange_vec_dec v (( 43 : int):ii) (( 0 : int):ii)  :  44 words$word)))`;


(*val _set_Satp64_PPN : register_ref regstate register_value Satp64 -> mword ty44 -> M unit*)

val _ = Define `
 ((set_Satp64_PPN:((regstate),(register_value),(Satp64))register_ref ->(44)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : Satp64) . 
   let r = ((get_Satp64 w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 43 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_Satp64 r))))`;


(*val _update_Satp64_PPN : Satp64 -> mword ty44 -> Satp64*)

val _ = Define `
 ((update_Satp64_PPN:Satp64 ->(44)words$word -> Satp64) (Mk_Satp64 (v)) x=
    (Mk_Satp64 ((update_subrange_vec_dec v (( 43 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val legalize_satp : Architecture -> mword ty64 -> mword ty64 -> mword ty64*)

val _ = Define `
 ((legalize_satp:Architecture ->(64)words$word ->(64)words$word ->(64)words$word) (a : Architecture) (o1 : xlenbits) (v : xlenbits)=
    (let s = (Mk_Satp64 v) in
   (case ((satpMode_of_bits a ((get_Satp64_Mode s  :  4 words$word)))) of
     NONE => o1
   | SOME (Sv32) => o1
   | SOME (_) => (get_Satp64 s  :  64 words$word)
   )))`;


(*val csr_name : mword ty12 -> string*)

val _ = Define `
 ((csr_name:(12)words$word -> string) csr=
    (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "ustatus"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "uie"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     "utvec"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "fflags"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "frm"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "fcsr"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "cycle"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "time"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "instret"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "cycleh"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "timeh"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "instreth"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "sstatus"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "sedeleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "sideleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "sie"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     "stvec"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     "scounteren"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "sscratch"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "sepc"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "scause"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "stval"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "sip"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "satp"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  :  12 words$word)))) then
     "mvendorid"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  :  12 words$word)))) then
     "marchid"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  :  12 words$word)))) then
     "mimpid"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  :  12 words$word)))) then
     "mhartid"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mstatus"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "misa"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "medeleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "mideleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "mie"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     "mtvec"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     "mcounteren"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mscratch"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "mepc"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "mcause"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "mtval"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "mip"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mcycle"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "minstret"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mcycleh"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "minstreth"
   else if (((b__0 = (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "tselect"
   else "UNKNOWN"))`;


(*val csrAccess : mword ty12 -> mword ty2*)

val _ = Define `
 ((csrAccess:(12)words$word ->(2)words$word) csr=  ((subrange_vec_dec csr (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)))`;


(*val csrPriv : mword ty12 -> mword ty2*)

val _ = Define `
 ((csrPriv:(12)words$word ->(2)words$word) csr=  ((subrange_vec_dec csr (( 9 : int):ii) (( 8 : int):ii)  :  2 words$word)))`;


(*val is_CSR_defined : mword ty12 -> Privilege -> bool*)

val _ = Define `
 ((is_CSR_defined:(12)words$word -> Privilege -> bool) (csr : 12 bits) (p : Privilege)=
    (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else F))`;


(*val check_CSR_access : mword ty2 -> mword ty2 -> Privilege -> bool -> bool*)

val _ = Define `
 ((check_CSR_access:(2)words$word ->(2)words$word -> Privilege -> bool -> bool) csrrw csrpr p isWrite=
    (((~ ((((((((bool_to_bits isWrite  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((csrrw = (vec_of_bits [B1;B1]  :  2 words$word))))))))) /\ ((zopz0zKzJ_u ((privLevel_to_bits p  :  2 words$word)) csrpr))))`;


(*val check_TVM_SATP : mword ty12 -> Privilege -> M bool*)

val _ = Define `
 ((check_TVM_SATP:(12)words$word -> Privilege ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (csr : csreg) (p : Privilege)=  (state_monad$bindS
   (state$and_boolS
     (state_monad$returnS (((csr = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))))
     (state$and_boolS
        (state_monad$returnS (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
        ( state_monad$bindS(state_monad$read_regS mstatus_ref) (\ (w__0 : Mstatus) . 
         state_monad$returnS (((((get_Mstatus_TVM w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))) (\ (w__2 :
     bool) . 
   state_monad$returnS ((~ w__2)))))`;


(*val check_CSR : mword ty12 -> Privilege -> bool -> M bool*)

val _ = Define `
 ((check_CSR:(12)words$word -> Privilege -> bool ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (csr : csreg) (p : Privilege) (isWrite : bool)=
    (state$and_boolS (state_monad$returnS ((is_CSR_defined csr p)))
     (state$and_boolS
        (state_monad$returnS ((check_CSR_access ((csrAccess csr  :  2 words$word)) ((csrPriv csr  :  2 words$word)) p
                    isWrite))) ((check_TVM_SATP csr p)))))`;


(*val exception_delegatee : ExceptionType -> Privilege -> M Privilege*)

val _ = Define `
 ((exception_delegatee:ExceptionType -> Privilege ->(regstate)state_monad$sequential_state ->(((Privilege),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (e : ExceptionType) (p : Privilege)=
    (let idx = (num_of_ExceptionType e) in state_monad$bindS
   (state_monad$read_regS medeleg_ref) (\ (w__0 : Medeleg) . 
   let super = (access_vec_dec ((get_Medeleg w__0  :  64 words$word)) idx) in state_monad$bindS
   (state_monad$read_regS sedeleg_ref) (\ (w__1 : Sedeleg) . 
   let user = (access_vec_dec ((get_Sedeleg w__1  :  64 words$word)) idx) in state_monad$bindS
   (state$and_boolS
     ( state_monad$bindS(state_monad$read_regS misa_ref) (\ (w__2 : Misa) . 
      state_monad$returnS (((((get_Misa_S w__2  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))))
     (state_monad$returnS ((bit_to_bool super)))) (\ (w__3 : bool) . 
   let deleg = (if w__3 then Supervisor else Machine) in
   state_monad$returnS (if ((zopz0zI_u ((privLevel_to_bits deleg  :  2 words$word))
                  ((privLevel_to_bits p  :  2 words$word)))) then
             p
           else deleg))))))`;


(*val findPendingInterrupt : mword ty64 -> maybe InterruptType*)

val _ = Define `
 ((findPendingInterrupt:(64)words$word ->(InterruptType)option) ip=
    (let ip = (Mk_Minterrupts ip) in
   if (((((get_Minterrupts_MEI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
     SOME I_M_External
   else if (((((get_Minterrupts_MSI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_M_Software
   else if (((((get_Minterrupts_MTI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_M_Timer
   else if (((((get_Minterrupts_SEI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_S_External
   else if (((((get_Minterrupts_SSI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_S_Software
   else if (((((get_Minterrupts_STI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_S_Timer
   else if (((((get_Minterrupts_UEI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_U_External
   else if (((((get_Minterrupts_USI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_U_Software
   else if (((((get_Minterrupts_UTI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_U_Timer
   else NONE))`;


(*val curInterrupt : Minterrupts -> Minterrupts -> Minterrupts -> M (maybe ((InterruptType * Privilege)))*)

val _ = Define `
 ((curInterrupt:Minterrupts -> Minterrupts -> Minterrupts ->(regstate)state_monad$sequential_state ->((((InterruptType#Privilege)option),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (pend : Minterrupts) (enbl : Minterrupts) (delg : Minterrupts)=
    (let (en_mip : xlenbits) =
     ((and_vec ((get_Minterrupts pend  :  64 words$word)) ((get_Minterrupts enbl  :  64 words$word))
       :  64 words$word)) in
   if (((en_mip = ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))))) then
     state_monad$returnS NONE
   else
     let eff_mip =
       ((and_vec en_mip ((not_vec ((get_Minterrupts delg  :  64 words$word))  :  64 words$word))
         :  64 words$word)) in
     let eff_sip = ((and_vec en_mip ((get_Minterrupts delg  :  64 words$word))  :  64 words$word)) in state_monad$bindS
     (state$and_boolS
       ( state_monad$bindS(state_monad$read_regS mstatus_ref) (\ (w__0 : Mstatus) . 
        state_monad$returnS (((((get_Mstatus_MIE w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))))
       (state_monad$returnS (((eff_mip <> ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))))))) (\ (w__1 :
       bool) . 
     if w__1 then
       state_monad$returnS ((case ((findPendingInterrupt eff_mip)) of
         SOME (i) =>
          let r = (i, Machine) in
          SOME r
       | NONE => NONE
       ))
     else state_monad$bindS
       (state$and_boolS
         ( state_monad$bindS(state_monad$read_regS mstatus_ref) (\ (w__2 : Mstatus) . 
          state_monad$returnS (((((get_Mstatus_SIE w__2  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))))
         (state$and_boolS
            (state_monad$returnS (((eff_sip <> ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))))))
            (state$or_boolS
               ( state_monad$bindS(state_monad$read_regS cur_privilege_ref) (\ (w__3 : Privilege) . 
                state_monad$returnS (((((privLevel_to_bits w__3  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word)))))))
               ( state_monad$bindS(state_monad$read_regS cur_privilege_ref) (\ (w__4 : Privilege) . 
                state_monad$returnS (((((privLevel_to_bits w__4  :  2 words$word)) = ((privLevel_to_bits User  :  2 words$word)))))))))) (\ (w__7 : bool) . 
       state_monad$returnS (if w__7 then
                 (case ((findPendingInterrupt eff_sip)) of
                   SOME (i) =>
                    let r = (i, Supervisor) in
                    SOME r
                 | NONE => NONE
                 )
               else NONE)))))`;


(*val tval : maybe (mword ty64) -> mword ty64*)

val _ = Define `
 ((tval:((64)words$word)option ->(64)words$word) excinfo=
    ((case excinfo of
     SOME (e) => e
   | NONE => (EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word)
   )))`;


(*val handle_trap : Privilege -> bool -> mword ty4 -> mword ty64 -> maybe (mword ty64) -> M (mword ty64)*)

val _ = Define `
 ((handle_trap:Privilege -> bool ->(4)words$word ->(64)words$word ->(xlenbits)option ->(regstate)state_monad$sequential_state ->((((64)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (del_priv : Privilege) (intr : bool) (c : exc_code) (pc : xlenbits) (info :
   xlenbits option)=
    (let (_ : unit) =
     (prerr_endline
       ((STRCAT "handling "
           ((STRCAT (if intr then "int#" else "exc#")
               ((STRCAT ((string_of_vec c))
                   ((STRCAT " at priv "
                       ((STRCAT ((privLevel_to_str del_priv))
                           ((STRCAT " with tval "
                               ((string_of_vec ((tval info  :  64 words$word))))))))))))))))) in
   (case del_priv of
     Machine => state_monad$bindS (state_monad$seqS (state_monad$seqS
      (set_Mcause_IsInterrupt mcause_ref ((bool_to_bits intr  :  1 words$word)))
      (set_Mcause_Cause mcause_ref ((EXTZ (( 63 : int):ii) c  :  63 words$word))))
      (state_monad$read_regS mstatus_ref)) (\ (w__0 : Mstatus) .  state_monad$bindS (state_monad$seqS (state_monad$seqS
      (set_Mstatus_MPIE mstatus_ref ((get_Mstatus_MIE w__0  :  1 words$word)))
      (set_Mstatus_MIE mstatus_ref ((bool_to_bits F  :  1 words$word))))
      (state_monad$read_regS cur_privilege_ref)) (\ (w__1 : Privilege) .  state_monad$bindS (state_monad$seqS (state_monad$seqS (state_monad$seqS (state_monad$seqS
      (set_Mstatus_MPP mstatus_ref ((privLevel_to_bits w__1  :  2 words$word)))
      (state_monad$write_regS mtval_ref ((tval info  :  64 words$word))))
      (state_monad$write_regS mepc_ref pc))
      (state_monad$write_regS cur_privilege_ref del_priv))
      (state_monad$read_regS mtvec_ref)) (\ (w__2 : Mtvec) .  state_monad$bindS
      (state_monad$read_regS mcause_ref) (\ (w__3 : Mcause) . 
      (case ((tvec_addr w__2 w__3  :  ( 64 words$word)option)) of
        SOME (epc) => state_monad$returnS epc
      | NONE => (internal_error "Invalid mtvec mode"  : ( 64 words$word) M)
      )))))
   | Supervisor => state_monad$bindS (state_monad$seqS (state_monad$seqS
      (set_Mcause_IsInterrupt scause_ref ((bool_to_bits intr  :  1 words$word)))
      (set_Mcause_Cause scause_ref ((EXTZ (( 63 : int):ii) c  :  63 words$word))))
      (state_monad$read_regS mstatus_ref)) (\ (w__6 : Mstatus) .  state_monad$bindS (state_monad$seqS (state_monad$seqS
      (set_Mstatus_SPIE mstatus_ref ((get_Mstatus_SIE w__6  :  1 words$word)))
      (set_Mstatus_SIE mstatus_ref ((bool_to_bits F  :  1 words$word))))
      (state_monad$read_regS cur_privilege_ref)) (\ (w__7 : Privilege) .  state_monad$bindS
      (case w__7 of
        User => state_monad$returnS ((bool_to_bits F  :  1 words$word))
      | Supervisor => state_monad$returnS ((bool_to_bits T  :  1 words$word))
      | Machine => (internal_error "invalid privilege for s-mode trap"  : ( 1 words$word) M)
      ) (\ (w__9 :  1 words$word) .  state_monad$bindS (state_monad$seqS (state_monad$seqS (state_monad$seqS (state_monad$seqS
      (set_Mstatus_SPP mstatus_ref w__9)
      (state_monad$write_regS stval_ref ((tval info  :  64 words$word))))
      (state_monad$write_regS sepc_ref pc))
      (state_monad$write_regS cur_privilege_ref del_priv))
      (state_monad$read_regS stvec_ref)) (\ (w__10 : Mtvec) .  state_monad$bindS
      (state_monad$read_regS scause_ref) (\ (w__11 : Mcause) . 
      (case ((tvec_addr w__10 w__11  :  ( 64 words$word)option)) of
        SOME (epc) => state_monad$returnS epc
      | NONE => (internal_error "Invalid stvec mode"  : ( 64 words$word) M)
      ))))))
   | User => (internal_error "the N extension is currently unsupported"  : ( 64 words$word) M)
   )))`;


(*val handle_exception : Privilege -> ctl_result -> mword ty64 -> M (mword ty64)*)

val _ = Define `
 ((handle_exception:Privilege -> ctl_result ->(64)words$word ->(regstate)state_monad$sequential_state ->((((64)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (cur_priv : Privilege) (ctl : ctl_result) (pc : xlenbits)=
    ((case (cur_priv, ctl) of
     (_, CTL_TRAP (e)) => state_monad$bindS
      (exception_delegatee e.sync_exception_trap cur_priv) (\ del_priv . 
      let (_ : unit) =
        (prerr_endline
          ((STRCAT "trapping from "
              ((STRCAT ((privLevel_to_str cur_priv))
                  ((STRCAT " to "
                      ((STRCAT ((privLevel_to_str del_priv))
                          ((STRCAT " to handle "
                              ((exceptionType_to_str e.sync_exception_trap))))))))))))) in
      (handle_trap del_priv F ((exceptionType_to_bits e.sync_exception_trap  :  4 words$word)) pc
         e.sync_exception_excinfo
        : ( 64 words$word) M))
   | (_, CTL_MRET (_)) => state_monad$bindS
      (state_monad$read_regS cur_privilege_ref) (\ prev_priv .  state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__1 : Mstatus) .  state_monad$bindS (state_monad$seqS (state_monad$seqS
      (set_Mstatus_MIE mstatus_ref ((get_Mstatus_MPIE w__1  :  1 words$word)))
      (set_Mstatus_MPIE mstatus_ref ((bool_to_bits T  :  1 words$word))))
      (state_monad$read_regS mstatus_ref)) (\ (w__2 : Mstatus) .  state_monad$bindS (state_monad$seqS (state_monad$seqS
      (state_monad$write_regS cur_privilege_ref ((privLevel_of_bits ((get_Mstatus_MPP w__2  :  2 words$word)))))
      (set_Mstatus_MPP mstatus_ref ((privLevel_to_bits User  :  2 words$word))))
      (state_monad$read_regS cur_privilege_ref)) (\ (w__3 : Privilege) . 
      let (_ : unit) =
        (prerr_endline
          ((STRCAT "ret-ing from "
              ((STRCAT ((privLevel_to_str prev_priv))
                  ((STRCAT " to " ((privLevel_to_str w__3))))))))) in
      (state_monad$read_regS mepc_ref  : ( 64 words$word) M)))))
   | (_, CTL_SRET (_)) => state_monad$bindS
      (state_monad$read_regS cur_privilege_ref) (\ prev_priv .  state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__5 : Mstatus) .  state_monad$bindS (state_monad$seqS (state_monad$seqS
      (set_Mstatus_SIE mstatus_ref ((get_Mstatus_SPIE w__5  :  1 words$word)))
      (set_Mstatus_SPIE mstatus_ref ((bool_to_bits T  :  1 words$word))))
      (state_monad$read_regS mstatus_ref)) (\ (w__6 : Mstatus) .  state_monad$bindS (state_monad$seqS (state_monad$seqS
      (state_monad$write_regS
        cur_privilege_ref
        (if (((((get_Mstatus_SPP w__6  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
         then
           Supervisor
         else User))
      (set_Mstatus_SPP mstatus_ref ((bool_to_bits F  :  1 words$word))))
      (state_monad$read_regS cur_privilege_ref)) (\ (w__7 : Privilege) . 
      let (_ : unit) =
        (prerr_endline
          ((STRCAT "ret-ing from "
              ((STRCAT ((privLevel_to_str prev_priv))
                  ((STRCAT " to " ((privLevel_to_str w__7))))))))) in
      (state_monad$read_regS sepc_ref  : ( 64 words$word) M)))))
   )))`;


(*val handle_mem_exception : mword ty64 -> ExceptionType -> M unit*)

val _ = Define `
 ((handle_mem_exception:(64)words$word -> ExceptionType ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (addr : xlenbits) (e : ExceptionType)=
    (let (t : sync_exception) = (<| sync_exception_trap := e;  sync_exception_excinfo := (SOME addr) |>) in state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) .  state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  state_monad$bindS
   (handle_exception w__0 (CTL_TRAP t) w__1  : ( 64 words$word) M) (\ (w__2 : xlenbits) . 
   state_monad$write_regS nextPC_ref w__2)))))`;


(*val handle_decode_exception : mword ty64 -> M unit*)

val _ = Define `
 ((handle_decode_exception:(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) instbits=
    (let (t : sync_exception) =
     (<| sync_exception_trap := E_Illegal_Instr; 
        sync_exception_excinfo := (SOME instbits) |>) in state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) .  state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  state_monad$bindS
   (handle_exception w__0 (CTL_TRAP t) w__1  : ( 64 words$word) M) (\ (w__2 : xlenbits) . 
   state_monad$write_regS nextPC_ref w__2)))))`;


(*val handle_interrupt : InterruptType -> Privilege -> M unit*)

val _ = Define `
 ((handle_interrupt:InterruptType -> Privilege ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (i : InterruptType) (del_priv : Privilege)=  (state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  state_monad$bindS
   (handle_trap del_priv T ((interruptType_to_bits i  :  4 words$word)) w__0 NONE
     : ( 64 words$word) M) (\ (w__1 : xlenbits) . 
   state_monad$write_regS nextPC_ref w__1))))`;


(*val handle_illegal : unit -> M unit*)

val _ = Define `
 ((handle_illegal:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =
    (let (t : sync_exception) =
     (<| sync_exception_trap := E_Illegal_Instr; 
        sync_exception_excinfo := NONE |>) in state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) .  state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__1 :  64 words$word) .  state_monad$bindS
   (handle_exception w__0 (CTL_TRAP t) w__1  : ( 64 words$word) M) (\ (w__2 : xlenbits) . 
   state_monad$write_regS nextPC_ref w__2)))))`;


(*val init_sys : unit -> M unit*)

val _ = Define `
 ((init_sys:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS (state_monad$seqS (state_monad$seqS (state_monad$seqS (state_monad$seqS (state_monad$seqS
   (state_monad$write_regS cur_privilege_ref Machine)
   (set_Misa_MXL misa_ref ((arch_to_bits RV64  :  2 words$word))))
   (set_Misa_C misa_ref ((bool_to_bits T  :  1 words$word))))
   (set_Misa_U misa_ref ((bool_to_bits T  :  1 words$word))))
   (set_Misa_S misa_ref ((bool_to_bits T  :  1 words$word))))
   (state_monad$read_regS misa_ref)) (\ (w__0 : Misa) .  state_monad$bindS (state_monad$seqS
   (set_Mstatus_SXL mstatus_ref ((get_Misa_MXL w__0  :  2 words$word)))
   (state_monad$read_regS misa_ref)) (\ (w__1 : Misa) .  state_monad$seqS (state_monad$seqS
   (set_Mstatus_UXL mstatus_ref ((get_Misa_MXL w__1  :  2 words$word)))
   (set_Mstatus_SD mstatus_ref ((bool_to_bits F  :  1 words$word))))
   (state_monad$write_regS mhartid_ref ((EXTZ (( 64 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word)))))))`;


(*val tick_clock : unit -> M unit*)

val _ = Define `
 ((tick_clock:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS mcycle_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   state_monad$write_regS mcycle_ref ((add_vec_int w__0 (( 1 : int):ii)  :  64 words$word)))))`;


val _ = Define `
 ((PAGESIZE_BITS:int)=  ((( 12 : int):ii)))`;


(*val _get_PTE_Bits : PTE_Bits -> mword ty8*)

val _ = Define `
 ((get_PTE_Bits:PTE_Bits ->(8)words$word) (Mk_PTE_Bits (v))=  v)`;


(*val _set_PTE_Bits : register_ref regstate register_value PTE_Bits -> mword ty8 -> M unit*)

val _ = Define `
 ((set_PTE_Bits:((regstate),(register_value),(PTE_Bits))register_ref ->(8)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_PTE_Bits v) in
   state_monad$write_regS r_ref r)))`;


val _ = Define `
 ((get_PTE_Bits_D:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_D:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 7 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_D:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 7 : int):ii) (( 7 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_A:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_A:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):ii) (( 6 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_A:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 6 : int):ii) (( 6 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_G:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_G:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):ii) (( 5 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_G:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 5 : int):ii) (( 5 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_U:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_U:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):ii) (( 4 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_U:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 4 : int):ii) (( 4 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_X:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_X:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):ii) (( 3 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_X:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 3 : int):ii) (( 3 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_W:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_W:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):ii) (( 2 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_W:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 2 : int):ii) (( 2 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_R:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_R:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):ii) (( 1 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_R:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 1 : int):ii) (( 1 : int):ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_V:PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_V:((regstate),(register_value),(PTE_Bits))register_ref ->(1)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):ii) (( 0 : int):ii) v  :  8 words$word)) in
   state_monad$write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_V:PTE_Bits ->(1)words$word -> PTE_Bits) (Mk_PTE_Bits (v)) x=
    (Mk_PTE_Bits ((update_subrange_vec_dec v (( 0 : int):ii) (( 0 : int):ii) x  :  8 words$word))))`;


(*val isPTEPtr : mword ty8 -> bool*)

val _ = Define `
 ((isPTEPtr:(8)words$word -> bool) p=
    (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_R a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) /\ ((((((((get_PTE_Bits_W a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) /\ (((((get_PTE_Bits_X a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word)))))))))))`;


(*val isInvalidPTE : mword ty8 -> bool*)

val _ = Define `
 ((isInvalidPTE:(8)words$word -> bool) p=
    (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_V a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ ((((((((get_PTE_Bits_W a  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((((get_PTE_Bits_R a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word)))))))))))`;


(*val checkPTEPermission : AccessType -> Privilege -> bool -> bool -> PTE_Bits -> M bool*)

val _ = Define `
 ((checkPTEPermission:AccessType -> Privilege -> bool -> bool -> PTE_Bits ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (ac : AccessType) (priv : Privilege) (mxr : bool) (do_sum : bool) (p :
  PTE_Bits)=
    ((case (ac, priv) of
     (Read, User) =>
      state_monad$returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr)))))))))
   | (Write, User) =>
      state_monad$returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (ReadWrite, User) =>
      state_monad$returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr))))))))))))
   | (Execute, User) =>
      state_monad$returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (Read, Supervisor) =>
      state_monad$returnS (((((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ do_sum))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr)))))))))
   | (Write, Supervisor) =>
      state_monad$returnS (((((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ do_sum))) /\ (((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (ReadWrite, Supervisor) =>
      state_monad$returnS (((((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ do_sum))) /\ ((((((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr))))))))))))
   | (Execute, Supervisor) =>
      state_monad$returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) /\ (((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (_, Machine) => internal_error "m-mode mem perm check"
   )))`;


(*val update_PTE_Bits : PTE_Bits -> AccessType -> maybe PTE_Bits*)

val _ = Define `
 ((update_PTE_Bits:PTE_Bits -> AccessType ->(PTE_Bits)option) (p : PTE_Bits) (a : AccessType)=
    (let update_d =
     (((((((a = Write))) \/ (((a = ReadWrite)))))) /\ (((((get_PTE_Bits_D p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word)))))) in
   let update_a = (((get_PTE_Bits_A p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))) in
   if (((update_d \/ update_a))) then
     let np = (update_PTE_Bits_A p ((bool_to_bits T  :  1 words$word))) in
     let np = (if update_d then update_PTE_Bits_D p ((bool_to_bits T  :  1 words$word)) else np) in
     SOME np
   else NONE))`;


(*val PTW_Error_of_num : integer -> PTW_Error*)

val _ = Define `
 ((PTW_Error_of_num:int -> PTW_Error) arg_=
    (let l__0 = arg_ in
   if (((l__0 = (( 0 : int):ii)))) then PTW_Access
   else if (((l__0 = (( 1 : int):ii)))) then PTW_Invalid_PTE
   else if (((l__0 = (( 2 : int):ii)))) then PTW_No_Permission
   else if (((l__0 = (( 3 : int):ii)))) then PTW_Misaligned
   else PTW_PTE_Update))`;


(*val num_of_PTW_Error : PTW_Error -> integer*)

val _ = Define `
 ((num_of_PTW_Error:PTW_Error -> int) arg_=
    ((case arg_ of
     PTW_Access => (( 0 : int):ii)
   | PTW_Invalid_PTE => (( 1 : int):ii)
   | PTW_No_Permission => (( 2 : int):ii)
   | PTW_Misaligned => (( 3 : int):ii)
   | PTW_PTE_Update => (( 4 : int):ii)
   )))`;


(*val translationException : AccessType -> PTW_Error -> ExceptionType*)

val _ = Define `
 ((translationException:AccessType -> PTW_Error -> ExceptionType) (a : AccessType) (f : PTW_Error)= 
  ((case (a, f) of
         (Read, PTW_Access) => E_Load_Access_Fault
     | (Read, _) => E_Load_Page_Fault
     | (Write, PTW_Access) => E_SAMO_Access_Fault
     | (Write, _) => E_SAMO_Page_Fault
     | (Fetch, PTW_Access) => E_Fetch_Access_Fault
     | (Fetch, _) => E_Fetch_Page_Fault
   )))`;


val _ = Define `
 ((SV39_LEVEL_BITS:int)=  ((( 9 : int):ii)))`;


val _ = Define `
 ((SV39_LEVELS:int)=  ((( 3 : int):ii)))`;


val _ = Define `
 ((PTE39_LOG_SIZE:int)=  ((( 3 : int):ii)))`;


val _ = Define `
 ((PTE39_SIZE:int)=  ((( 8 : int):ii)))`;


(*val _get_SV39_Vaddr : SV39_Vaddr -> mword ty39*)

val _ = Define `
 ((get_SV39_Vaddr:SV39_Vaddr ->(39)words$word) (Mk_SV39_Vaddr (v))=  v)`;


(*val _set_SV39_Vaddr : register_ref regstate register_value SV39_Vaddr -> mword ty39 -> M unit*)

val _ = Define `
 ((set_SV39_Vaddr:((regstate),(register_value),(SV39_Vaddr))register_ref ->(39)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_SV39_Vaddr v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27*)

val _ = Define `
 ((get_SV39_Vaddr_VPNi:SV39_Vaddr ->(27)words$word) (Mk_SV39_Vaddr (v))=  ((subrange_vec_dec v (( 38 : int):ii) (( 12 : int):ii)  :  27 words$word)))`;


(*val _set_SV39_Vaddr_VPNi : register_ref regstate register_value SV39_Vaddr -> mword ty27 -> M unit*)

val _ = Define `
 ((set_SV39_Vaddr_VPNi:((regstate),(register_value),(SV39_Vaddr))register_ref ->(27)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_Vaddr) . 
   let r = ((get_SV39_Vaddr w__0  :  39 words$word)) in
   let r = ((update_subrange_vec_dec r (( 38 : int):ii) (( 12 : int):ii) v  :  39 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_Vaddr r))))`;


(*val _update_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27 -> SV39_Vaddr*)

val _ = Define `
 ((update_SV39_Vaddr_VPNi:SV39_Vaddr ->(27)words$word -> SV39_Vaddr) (Mk_SV39_Vaddr (v)) x=
    (Mk_SV39_Vaddr ((update_subrange_vec_dec v (( 38 : int):ii) (( 12 : int):ii) x  :  39 words$word))))`;


(*val _get_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12*)

val _ = Define `
 ((get_SV39_Vaddr_PgOfs:SV39_Vaddr ->(12)words$word) (Mk_SV39_Vaddr (v))=  ((subrange_vec_dec v (( 11 : int):ii) (( 0 : int):ii)  :  12 words$word)))`;


(*val _set_SV39_Vaddr_PgOfs : register_ref regstate register_value SV39_Vaddr -> mword ty12 -> M unit*)

val _ = Define `
 ((set_SV39_Vaddr_PgOfs:((regstate),(register_value),(SV39_Vaddr))register_ref ->(12)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_Vaddr) . 
   let r = ((get_SV39_Vaddr w__0  :  39 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):ii) (( 0 : int):ii) v  :  39 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_Vaddr r))))`;


(*val _update_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12 -> SV39_Vaddr*)

val _ = Define `
 ((update_SV39_Vaddr_PgOfs:SV39_Vaddr ->(12)words$word -> SV39_Vaddr) (Mk_SV39_Vaddr (v)) x=
    (Mk_SV39_Vaddr ((update_subrange_vec_dec v (( 11 : int):ii) (( 0 : int):ii) x  :  39 words$word))))`;


(*val _update_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12 -> SV39_Paddr*)

(*val _get_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12*)

(*val _set_SV39_Paddr_PgOfs : register_ref regstate register_value SV39_Paddr -> mword ty12 -> M unit*)

(*val _get_SV39_Paddr : SV39_Paddr -> mword ty56*)

val _ = Define `
 ((get_SV39_Paddr:SV39_Paddr ->(56)words$word) (Mk_SV39_Paddr (v))=  v)`;


(*val _set_SV39_Paddr : register_ref regstate register_value SV39_Paddr -> mword ty56 -> M unit*)

val _ = Define `
 ((set_SV39_Paddr:((regstate),(register_value),(SV39_Paddr))register_ref ->(56)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_SV39_Paddr v) in
   state_monad$write_regS r_ref r)))`;


(*val _get_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44*)

val _ = Define `
 ((get_SV39_Paddr_PPNi:SV39_Paddr ->(44)words$word) (Mk_SV39_Paddr (v))=  ((subrange_vec_dec v (( 55 : int):ii) (( 12 : int):ii)  :  44 words$word)))`;


(*val _set_SV39_Paddr_PPNi : register_ref regstate register_value SV39_Paddr -> mword ty44 -> M unit*)

val _ = Define `
 ((set_SV39_Paddr_PPNi:((regstate),(register_value),(SV39_Paddr))register_ref ->(44)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_Paddr) . 
   let r = ((get_SV39_Paddr w__0  :  56 words$word)) in
   let r = ((update_subrange_vec_dec r (( 55 : int):ii) (( 12 : int):ii) v  :  56 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_Paddr r))))`;


(*val _update_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44 -> SV39_Paddr*)

val _ = Define `
 ((update_SV39_Paddr_PPNi:SV39_Paddr ->(44)words$word -> SV39_Paddr) (Mk_SV39_Paddr (v)) x=
    (Mk_SV39_Paddr ((update_subrange_vec_dec v (( 55 : int):ii) (( 12 : int):ii) x  :  56 words$word))))`;


(*val _update_SV39_PTE_PPNi : SV39_PTE -> mword ty44 -> SV39_PTE*)

(*val _get_SV39_PTE_PPNi : SV39_PTE -> mword ty44*)

(*val _set_SV39_PTE_PPNi : register_ref regstate register_value SV39_PTE -> mword ty44 -> M unit*)

val _ = Define `
 ((get_SV39_Paddr_PgOfs:SV39_Paddr ->(12)words$word) (Mk_SV39_Paddr (v))=  ((subrange_vec_dec v (( 11 : int):ii) (( 0 : int):ii)  :  12 words$word)))`;


val _ = Define `
 ((set_SV39_Paddr_PgOfs:((regstate),(register_value),(SV39_Paddr))register_ref ->(12)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_Paddr) . 
   let r = ((get_SV39_Paddr w__0  :  56 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):ii) (( 0 : int):ii) v  :  56 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_Paddr r))))`;


val _ = Define `
 ((update_SV39_Paddr_PgOfs:SV39_Paddr ->(12)words$word -> SV39_Paddr) (Mk_SV39_Paddr (v)) x=
    (Mk_SV39_Paddr ((update_subrange_vec_dec v (( 11 : int):ii) (( 0 : int):ii) x  :  56 words$word))))`;


val _ = Define `
 ((get_SV39_PTE:SV39_PTE ->(64)words$word) (Mk_SV39_PTE (v))=  v)`;


val _ = Define `
 ((set_SV39_PTE:((regstate),(register_value),(SV39_PTE))register_ref ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ r . 
   let r = (Mk_SV39_PTE v) in
   state_monad$write_regS r_ref r)))`;


val _ = Define `
 ((get_SV39_PTE_PPNi:SV39_PTE ->(44)words$word) (Mk_SV39_PTE (v))=  ((subrange_vec_dec v (( 53 : int):ii) (( 10 : int):ii)  :  44 words$word)))`;


val _ = Define `
 ((set_SV39_PTE_PPNi:((regstate),(register_value),(SV39_PTE))register_ref ->(44)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_PTE) . 
   let r = ((get_SV39_PTE w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 53 : int):ii) (( 10 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_PTE r))))`;


val _ = Define `
 ((update_SV39_PTE_PPNi:SV39_PTE ->(44)words$word -> SV39_PTE) (Mk_SV39_PTE (v)) x=
    (Mk_SV39_PTE ((update_subrange_vec_dec v (( 53 : int):ii) (( 10 : int):ii) x  :  64 words$word))))`;


(*val _get_SV39_PTE_RSW : SV39_PTE -> mword ty2*)

val _ = Define `
 ((get_SV39_PTE_RSW:SV39_PTE ->(2)words$word) (Mk_SV39_PTE (v))=  ((subrange_vec_dec v (( 9 : int):ii) (( 8 : int):ii)  :  2 words$word)))`;


(*val _set_SV39_PTE_RSW : register_ref regstate register_value SV39_PTE -> mword ty2 -> M unit*)

val _ = Define `
 ((set_SV39_PTE_RSW:((regstate),(register_value),(SV39_PTE))register_ref ->(2)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_PTE) . 
   let r = ((get_SV39_PTE w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):ii) (( 8 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_PTE r))))`;


(*val _update_SV39_PTE_RSW : SV39_PTE -> mword ty2 -> SV39_PTE*)

val _ = Define `
 ((update_SV39_PTE_RSW:SV39_PTE ->(2)words$word -> SV39_PTE) (Mk_SV39_PTE (v)) x=
    (Mk_SV39_PTE ((update_subrange_vec_dec v (( 9 : int):ii) (( 8 : int):ii) x  :  64 words$word))))`;


(*val _get_SV39_PTE_BITS : SV39_PTE -> mword ty8*)

val _ = Define `
 ((get_SV39_PTE_BITS:SV39_PTE ->(8)words$word) (Mk_SV39_PTE (v))=  ((subrange_vec_dec v (( 7 : int):ii) (( 0 : int):ii)  :  8 words$word)))`;


(*val _set_SV39_PTE_BITS : register_ref regstate register_value SV39_PTE -> mword ty8 -> M unit*)

val _ = Define `
 ((set_SV39_PTE_BITS:((regstate),(register_value),(SV39_PTE))register_ref ->(8)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) r_ref v=  (state_monad$bindS
   (state_monad$read_regS r_ref) (\ (w__0 : SV39_PTE) . 
   let r = ((get_SV39_PTE w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):ii) (( 0 : int):ii) v  :  64 words$word)) in
   state_monad$write_regS r_ref (Mk_SV39_PTE r))))`;


(*val _update_SV39_PTE_BITS : SV39_PTE -> mword ty8 -> SV39_PTE*)

val _ = Define `
 ((update_SV39_PTE_BITS:SV39_PTE ->(8)words$word -> SV39_PTE) (Mk_SV39_PTE (v)) x=
    (Mk_SV39_PTE ((update_subrange_vec_dec v (( 7 : int):ii) (( 0 : int):ii) x  :  64 words$word))))`;


(*val curAsid64 : unit -> M (mword ty16)*)

val _ = Define `
 ((curAsid64:unit ->(regstate)state_monad$sequential_state ->((((16)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS satp_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let satp64 = (Mk_Satp64 w__0) in
   state_monad$returnS ((get_Satp64_Asid satp64  :  16 words$word)))))`;


(*val curPTB39 : unit -> M (mword ty56)*)

val _ = Define `
 ((curPTB39:unit ->(regstate)state_monad$sequential_state ->((((56)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS satp_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let satp64 = (Mk_Satp64 w__0) in
   state_monad$returnS ((EXTZ (( 56 : int):ii)
              ((shiftl ((get_Satp64_PPN satp64  :  44 words$word)) PAGESIZE_BITS  :  44 words$word))
             :  56 words$word)))))`;


(*val walk39 : mword ty39 -> AccessType -> Privilege -> bool -> bool -> mword ty56 -> ii -> bool -> M PTW_Result*)

 val walk39_defn = Hol_defn "walk39" `
 ((walk39:(39)words$word -> AccessType -> Privilege -> bool -> bool ->(56)words$word -> int -> bool ->(regstate)state_monad$sequential_state ->(((PTW_Result),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) vaddr ac priv mxr do_sum ptb level global=
    (let va = (Mk_SV39_Vaddr vaddr) in
   let (pt_ofs : paddr39) =
     ((shiftl
        ((EXTZ (( 56 : int):ii)
            ((subrange_vec_dec
                ((shiftr ((get_SV39_Vaddr_VPNi va  :  27 words$word))
                    ((level * SV39_LEVEL_BITS))
                   :  27 words$word)) ((SV39_LEVEL_BITS - (( 1 : int):ii))) (( 0 : int):ii)
               :  9 words$word))
           :  56 words$word)) PTE39_LOG_SIZE
       :  56 words$word)) in
   let pte_addr = ((add_vec ptb pt_ofs  :  56 words$word)) in state_monad$bindS
   (checked_mem_read Data ((EXTZ (( 64 : int):ii) pte_addr  :  64 words$word)) (( 8 : int):ii)
     : ( ( 64 words$word)MemoryOpResult) M) (\ (w__0 : ( 64 words$word) MemoryOpResult) . 
   (case w__0 of
     MemException (_) => state_monad$returnS (PTW_Failure PTW_Access)
   | MemValue (v) =>
      let pte = (Mk_SV39_PTE v) in
      let pbits = ((get_SV39_PTE_BITS pte  :  8 words$word)) in
      let pattr = (Mk_PTE_Bits pbits) in
      let is_global =
        (global \/ (((((get_PTE_Bits_G pattr  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))) in
      if ((isInvalidPTE pbits)) then state_monad$returnS (PTW_Failure PTW_Invalid_PTE)
      else if ((isPTEPtr pbits)) then
        if (((level = (( 0 : int):ii)))) then state_monad$returnS (PTW_Failure PTW_Invalid_PTE)
        else
          walk39 vaddr ac priv mxr do_sum
            ((EXTZ (( 56 : int):ii)
                ((shiftl ((get_SV39_PTE_PPNi pte  :  44 words$word)) PAGESIZE_BITS  :  44 words$word))
               :  56 words$word)) ((level - (( 1 : int):ii))) is_global
      else state_monad$bindS
        (checkPTEPermission ac priv mxr do_sum pattr) (\ (w__3 : bool) . 
        state_monad$returnS (if ((~ w__3)) then PTW_Failure PTW_No_Permission
                else if ((level > (( 0 : int):ii))) then
                  let mask =
                    ((sub_vec_int
                       ((shiftl
                           ((xor_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                               ((xor_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                                   ((EXTZ (( 44 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  44 words$word))
                                  :  44 words$word))
                              :  44 words$word)) ((level * SV39_LEVEL_BITS))
                          :  44 words$word)) (( 1 : int):ii)
                      :  44 words$word)) in
                  if (((((and_vec ((get_SV39_PTE_PPNi pte  :  44 words$word)) mask  :  44 words$word)) <> ((EXTZ (( 44 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  44 words$word))))) then
                    PTW_Failure PTW_Misaligned
                  else
                    let ppn =
                      ((or_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                         ((and_vec
                             ((EXTZ (( 44 : int):ii) ((get_SV39_Vaddr_VPNi va  :  27 words$word))  :  44 words$word))
                             mask
                            :  44 words$word))
                        :  44 words$word)) in
                    PTW_Success ((concat_vec ppn ((get_SV39_Vaddr_PgOfs va  :  12 words$word))
                                   :  56 words$word),pte,pte_addr,level,is_global)
                else
                  PTW_Success ((concat_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                                  ((get_SV39_Vaddr_PgOfs va  :  12 words$word))
                                 :  56 words$word),pte,pte_addr,level,is_global)))
   ))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn walk39_defn;

(*val make_TLB39_Entry : mword ty16 -> bool -> mword ty39 -> mword ty56 -> SV39_PTE -> ii -> mword ty56 -> M TLB39_Entry*)

val _ = Define `
 ((make_TLB39_Entry:(16)words$word -> bool ->(39)words$word ->(56)words$word -> SV39_PTE -> int ->(56)words$word ->(regstate)state_monad$sequential_state ->(((TLB39_Entry),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) asid global vAddr pAddr pte level pteAddr=
    (let (shift : ii) = (PAGESIZE_BITS + ((level * SV39_LEVEL_BITS))) in
   let (vAddrMask : vaddr39) =
     ((sub_vec_int
        ((shiftl
            ((xor_vec vAddr
                ((xor_vec vAddr ((EXTZ (( 39 : int):ii) (vec_of_bits [B1]  :  1 words$word)  :  39 words$word))
                   :  39 words$word))
               :  39 words$word)) shift
           :  39 words$word)) (( 1 : int):ii)
       :  39 words$word)) in
   let (vMatchMask : vaddr39) = ((not_vec vAddrMask  :  39 words$word)) in state_monad$bindS
   (state_monad$read_regS mcycle_ref  : ( 64 words$word) M) (\ (w__0 : xlenbits) . 
   state_monad$returnS (<| TLB39_Entry_asid := asid; 
              TLB39_Entry_global := global; 
              TLB39_Entry_pte := pte; 
              TLB39_Entry_pteAddr := pteAddr; 
              TLB39_Entry_vAddrMask := vAddrMask; 
              TLB39_Entry_vMatchMask := vMatchMask; 
              TLB39_Entry_vAddr := ((and_vec vAddr vMatchMask  :  39 words$word)); 
              TLB39_Entry_pAddr :=
                ((shiftl ((shiftr pAddr shift  :  56 words$word)) shift  :  56 words$word)); 
              TLB39_Entry_age := w__0 |>))))`;


val _ = Define `
 ((TLBEntries:int)=  ((( 32 : int):ii)))`;


(*val lookupTLB39 : mword ty16 -> mword ty39 -> M (maybe ((ii * TLB39_Entry)))*)

val _ = Define `
 ((lookupTLB39:(16)words$word ->(39)words$word ->(regstate)state_monad$sequential_state ->((((int#TLB39_Entry)option),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) asid vaddr=  (state_monad$bindS
   (state_monad$read_regS tlb39_ref) (\ (w__0 :  TLB39_Entry option) . 
   state_monad$returnS ((case w__0 of
     NONE => NONE
   | SOME (e) =>
      if ((((((e.TLB39_Entry_global \/ (((e.TLB39_Entry_asid = asid)))))) /\ (((e.TLB39_Entry_vAddr = ((and_vec e.TLB39_Entry_vMatchMask vaddr  :  39 words$word))))))))
      then
        SOME ((( 0 : int):ii), e)
      else NONE
   )))))`;


(*val addToTLB39 : mword ty16 -> mword ty39 -> mword ty56 -> SV39_PTE -> mword ty56 -> ii -> bool -> M unit*)

val _ = Define `
 ((addToTLB39:(16)words$word ->(39)words$word ->(56)words$word -> SV39_PTE ->(56)words$word -> int -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) asid vAddr pAddr pte pteAddr level global=  (state_monad$bindS
   (make_TLB39_Entry asid global vAddr pAddr pte level pteAddr) (\ ent . 
   state_monad$write_regS tlb39_ref (SOME ent))))`;


(*val writeTLB39 : ii -> TLB39_Entry -> M unit*)

val _ = Define `
 ((writeTLB39:int -> TLB39_Entry ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (idx : ii) (ent : TLB39_Entry)=  (state_monad$write_regS tlb39_ref (SOME ent)))`;


(*val flushTLB : maybe (mword ty16) -> maybe (mword ty39) -> M unit*)

val _ = Define `
 ((flushTLB:((16)words$word)option ->((39)words$word)option ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) asid addr=  (state_monad$bindS
   (state_monad$read_regS tlb39_ref) (\ (w__0 :  TLB39_Entry option) . 
   let (ent :  TLB39_Entry option) =
     ((case (w__0, asid, addr) of
       (NONE, _, _) => NONE
     | (SOME (e), NONE, NONE) => NONE
     | (SOME (e), NONE, SOME (a)) =>
        if (((e.TLB39_Entry_vAddr = ((and_vec e.TLB39_Entry_vMatchMask a  :  39 words$word))))) then
          NONE
        else SOME e
     | (SOME (e), SOME (i), NONE) =>
        if ((((((e.TLB39_Entry_asid = i))) /\ ((~ e.TLB39_Entry_global))))) then NONE
        else SOME e
     | (SOME (e), SOME (i), SOME (a)) =>
        if ((((((e.TLB39_Entry_asid = i))) /\ ((((((e.TLB39_Entry_vAddr = ((and_vec a e.TLB39_Entry_vMatchMask  :  39 words$word))))) /\ ((~ e.TLB39_Entry_global)))))))) then
          NONE
        else SOME e
     )) in
   state_monad$write_regS tlb39_ref ent)))`;


val _ = Define `
 ((enable_dirty_update:bool)=  F)`;


(*val translate39 : mword ty39 -> AccessType -> Privilege -> bool -> bool -> ii -> M TR39_Result*)

val _ = Define `
 ((translate39:(39)words$word -> AccessType -> Privilege -> bool -> bool -> int ->(regstate)state_monad$sequential_state ->(((TR39_Result),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) vAddr ac priv mxr do_sum level=  (state_monad$bindS
   (curAsid64 ()   : ( 16 words$word) M) (\ asid .  state_monad$bindS
   (lookupTLB39 asid vAddr) (\ (w__0 :  ((ii # TLB39_Entry))option) . 
   (case w__0 of
     SOME (idx,ent) =>
      let pteBits = (Mk_PTE_Bits ((get_SV39_PTE_BITS ent.TLB39_Entry_pte  :  8 words$word))) in state_monad$bindS
      (checkPTEPermission ac priv mxr do_sum pteBits) (\ (w__1 : bool) . 
      if ((~ w__1)) then state_monad$returnS (TR39_Failure PTW_No_Permission)
      else
        (case ((update_PTE_Bits pteBits ac)) of
          NONE =>
           state_monad$returnS (TR39_Address ((or_vec ent.TLB39_Entry_pAddr
                                    ((EXTZ (( 56 : int):ii)
                                        ((and_vec vAddr ent.TLB39_Entry_vAddrMask  :  39 words$word))
                                       :  56 words$word))
                                   :  56 words$word)))
        | SOME (pbits) =>
           if ((~ enable_dirty_update)) then state_monad$returnS (TR39_Failure PTW_PTE_Update)
           else
             let (n_ent : TLB39_Entry) = ent in
             let n_ent =
               ((n_ent with<|
                 TLB39_Entry_pte :=
                   ((update_SV39_PTE_BITS ent.TLB39_Entry_pte ((get_PTE_Bits pbits  :  8 words$word))))|>)) in state_monad$bindS (state_monad$seqS
             (writeTLB39 idx n_ent)
             (checked_mem_write ((EXTZ (( 64 : int):ii) ent.TLB39_Entry_pteAddr  :  64 words$word)) (( 8 : int):ii)
               ((get_SV39_PTE ent.TLB39_Entry_pte  :  64 words$word)))) (\ (w__2 : unit
               MemoryOpResult) .  state_monad$seqS
             (case w__2 of
               MemValue (_) => state_monad$returnS () 
             | MemException (e) => internal_error "invalid physical address in TLB"
             )
             (state_monad$returnS (TR39_Address ((or_vec ent.TLB39_Entry_pAddr
                                      ((EXTZ (( 56 : int):ii)
                                          ((and_vec vAddr ent.TLB39_Entry_vAddrMask  :  39 words$word))
                                         :  56 words$word))
                                     :  56 words$word)))))
        ))
   | NONE => state_monad$bindS
      (curPTB39 ()   : ( 56 words$word) M) (\ (w__6 :  56 words$word) .  state_monad$bindS
      (walk39 vAddr ac priv mxr do_sum w__6 level F) (\ (w__7 : PTW_Result) . 
      (case w__7 of
        PTW_Failure (f) => state_monad$returnS (TR39_Failure f)
      | PTW_Success (pAddr,pte,pteAddr,level,global) =>
         (case ((update_PTE_Bits (Mk_PTE_Bits ((get_SV39_PTE_BITS pte  :  8 words$word))) ac)) of
           NONE => state_monad$seqS
            (addToTLB39 asid vAddr pAddr pte pteAddr level global) (state_monad$returnS (TR39_Address pAddr))
         | SOME (pbits) =>
            if ((~ enable_dirty_update)) then state_monad$returnS (TR39_Failure PTW_PTE_Update)
            else
              let (w_pte : SV39_PTE) =
                (update_SV39_PTE_BITS pte ((get_PTE_Bits pbits  :  8 words$word))) in state_monad$bindS
              (checked_mem_write ((EXTZ (( 64 : int):ii) pteAddr  :  64 words$word)) (( 8 : int):ii)
                ((get_SV39_PTE w_pte  :  64 words$word))) (\ (w__8 : unit MemoryOpResult) . 
              (case w__8 of
                MemValue (_) => state_monad$seqS
                 (addToTLB39 asid vAddr pAddr w_pte pteAddr level global)
                 (state_monad$returnS (TR39_Address pAddr))
              | MemException (e) => state_monad$returnS (TR39_Failure PTW_Access)
              ))
         )
      )))
   )))))`;


(*val translationMode : Privilege -> M SATPMode*)

val _ = Define `
 ((translationMode:Privilege ->(regstate)state_monad$sequential_state ->(((SATPMode),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) priv=
    (if (((((privLevel_to_bits priv  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))))
   then
     state_monad$returnS Sbare
   else state_monad$bindS
     (state_monad$read_regS mstatus_ref) (\ (w__0 : Mstatus) . 
     let arch = (architecture ((get_Mstatus_SXL w__0  :  2 words$word))) in
     (case arch of
       SOME (RV64) => state_monad$bindS
        (state_monad$read_regS satp_ref  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
        let (mbits : satp_mode) = ((get_Satp64_Mode (Mk_Satp64 w__1)  :  4 words$word)) in
        (case ((satpMode_of_bits RV64 mbits)) of
          SOME (m) => state_monad$returnS m
        | NONE => internal_error "invalid RV64 translation mode in satp"
        ))
     | _ => internal_error "unsupported address translation arch"
     ))))`;


(*val translateAddr : mword ty64 -> AccessType -> ReadType -> M TR_Result*)

val _ = Define `
 ((translateAddr:(64)words$word -> AccessType -> ReadType ->(regstate)state_monad$sequential_state ->(((TR_Result),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) vAddr ac rt=  (state_monad$bindS
   (case rt of
     Instruction => state_monad$read_regS cur_privilege_ref
   | Data => state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__1 : Mstatus) . 
      if (((((get_Mstatus_MPRV w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then state_monad$bindS
        (state_monad$read_regS mstatus_ref) (\ (w__2 : Mstatus) . 
        state_monad$returnS ((privLevel_of_bits ((get_Mstatus_MPP w__2  :  2 words$word)))))
      else state_monad$read_regS cur_privilege_ref)
   ) (\ (effPriv : Privilege) .  state_monad$bindS
   (state_monad$read_regS mstatus_ref) (\ (w__5 : Mstatus) . 
   let (mxr : bool) =
     (((get_Mstatus_MXR w__5  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))) in state_monad$bindS
   (state_monad$read_regS mstatus_ref) (\ (w__6 : Mstatus) . 
   let (do_sum : bool) =
     (((get_Mstatus_SUM w__6  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))) in state_monad$bindS
   (translationMode effPriv) (\ (mode : SATPMode) .  
  (case mode of
        Sbare => state_monad$returnS (TR_Address vAddr)
    | SV39 => state_monad$bindS
                (translate39
                   ((subrange_vec_dec vAddr (( 38 : int): ii)
                       (( 0 : int): ii) : 39 words$word)) ac effPriv 
                 mxr do_sum ((SV39_LEVELS - (( 1 : int): ii))))
                (\ (w__7 : TR39_Result) . 
                 state_monad$returnS
                   ((case w__7 of
                          TR39_Address (pa) => TR_Address
                                                 ((EXTZ (( 64 : int): ii) pa : 64 words$word))
                      | TR39_Failure (f) => TR_Failure
                                              ((translationException ac f))
                    )))
  )))))))`;


(*val decode : mword ty32 -> maybe ast*)

(*val decodeCompressed : mword ty16 -> maybe ast*)

(*val execute : ast -> M unit*)

(*val print_insn : ast -> string*)

(*val extend_value : forall 'int8_times_n . Size 'int8_times_n => bool -> MemoryOpResult (mword 'int8_times_n) -> MemoryOpResult (mword ty64)*)

val _ = Define `
 ((extend_value:bool ->('int8_times_n words$word)MemoryOpResult ->((64)words$word)MemoryOpResult) is_unsigned value=
    ((case value of
     MemValue (v) =>
      MemValue (if is_unsigned then (EXTZ (( 64 : int):ii) v  :  64 words$word)
                else (EXTS (( 64 : int):ii) v  :  64 words$word))
   | MemException (e) => MemException e
   )))`;


(*val process_load : forall 'int8_times_n . Size 'int8_times_n => mword ty5 -> mword ty64 -> MemoryOpResult (mword 'int8_times_n) -> bool -> M unit*)

val _ = Define `
 ((process_load:(5)words$word ->(64)words$word ->('int8_times_n words$word)MemoryOpResult -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rd addr value is_unsigned=
    ((case ((extend_value is_unsigned value  : ( 64 words$word) MemoryOpResult)) of
     MemValue (result) => wX ((regbits_to_regno rd)) result
   | MemException (e) => handle_mem_exception addr e
   )))`;


(*val process_loadres : forall 'int8_times_n . regbits -> xlenbits -> MemoryOpResult (bits 'int8_times_n) -> bool -> unit*)

(*val readCSR : mword ty12 -> M (mword ty64)*)

val _ = Define `
 ((readCSR:(12)words$word ->(regstate)state_monad$sequential_state ->((((64)words$word),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) csr=
    (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  :  12 words$word)))) then
     (state_monad$read_regS mvendorid_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  :  12 words$word)))) then
     (state_monad$read_regS marchid_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  :  12 words$word)))) then
     (state_monad$read_regS mimpid_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  :  12 words$word)))) then
     (state_monad$read_regS mhartid_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mstatus_ref) (\ (w__4 : Mstatus) .  state_monad$returnS ((get_Mstatus w__4  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS misa_ref) (\ (w__5 : Misa) .  state_monad$returnS ((get_Misa w__5  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS medeleg_ref) (\ (w__6 : Medeleg) .  state_monad$returnS ((get_Medeleg w__6  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mideleg_ref) (\ (w__7 : Minterrupts) . 
     state_monad$returnS ((get_Minterrupts w__7  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mie_ref) (\ (w__8 : Minterrupts) .  state_monad$returnS ((get_Minterrupts w__8  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mtvec_ref) (\ (w__9 : Mtvec) .  state_monad$returnS ((get_Mtvec w__9  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (state_monad$read_regS mscratch_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (state_monad$read_regS mepc_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mcause_ref) (\ (w__12 : Mcause) .  state_monad$returnS ((get_Mcause w__12  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (state_monad$read_regS mtval_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mip_ref) (\ (w__14 : Minterrupts) . 
     state_monad$returnS ((get_Minterrupts w__14  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mstatus_ref) (\ (w__15 : Mstatus) .  state_monad$returnS ((get_Mstatus w__15  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS sedeleg_ref) (\ (w__16 : Sedeleg) .  state_monad$returnS ((get_Sedeleg w__16  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS sideleg_ref) (\ (w__17 : Sinterrupts) . 
     state_monad$returnS ((get_Sinterrupts w__17  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mie_ref) (\ (w__18 : Minterrupts) .  state_monad$bindS
     (state_monad$read_regS mideleg_ref) (\ (w__19 : Minterrupts) . 
     state_monad$returnS ((get_Sinterrupts ((lower_mie w__18 w__19))  :  64 words$word))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS stvec_ref) (\ (w__20 : Mtvec) .  state_monad$returnS ((get_Mtvec w__20  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (state_monad$read_regS sscratch_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (state_monad$read_regS sepc_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS scause_ref) (\ (w__23 : Mcause) .  state_monad$returnS ((get_Mcause w__23  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (state_monad$read_regS stval_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS mip_ref) (\ (w__25 : Minterrupts) .  state_monad$bindS
     (state_monad$read_regS mideleg_ref) (\ (w__26 : Minterrupts) . 
     state_monad$returnS ((get_Sinterrupts ((lower_mip w__25 w__26))  :  64 words$word))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (state_monad$read_regS satp_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (state_monad$read_regS mcycle_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (state_monad$read_regS mtime_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     (state_monad$read_regS minstret_ref  : ( 64 words$word) M)
   else if (((b__0 = (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS
     (state_monad$read_regS tselect_ref  : ( 64 words$word) M) (\ (w__31 :  64 words$word) . 
     state_monad$returnS ((not_vec w__31  :  64 words$word)))
   else
     let (_ : unit) = (print_bits "unhandled read to CSR " csr) in
     state_monad$returnS (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                          B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                          B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
              :  64 words$word)))`;


(*val writeCSR : mword ty12 -> mword ty64 -> M unit*)

val _ = Define `
 ((writeCSR:(12)words$word ->(64)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) (csr : csreg) (value : xlenbits)=
    (let b__0 = csr in state_monad$bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__0 : Mstatus) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mstatus_ref ((legalize_mstatus w__0 value)))
      (state_monad$read_regS mstatus_ref)) (\ (w__1 : Mstatus) . 
      state_monad$returnS (SOME ((get_Mstatus w__1  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS medeleg_ref) (\ (w__2 : Medeleg) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS medeleg_ref ((legalize_medeleg w__2 value)))
      (state_monad$read_regS medeleg_ref)) (\ (w__3 : Medeleg) . 
      state_monad$returnS (SOME ((get_Medeleg w__3  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mideleg_ref) (\ (w__4 : Minterrupts) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mideleg_ref ((legalize_mideleg w__4 value)))
      (state_monad$read_regS mideleg_ref)) (\ (w__5 : Minterrupts) . 
      state_monad$returnS (SOME ((get_Minterrupts w__5  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mie_ref) (\ (w__6 : Minterrupts) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mie_ref ((legalize_mie w__6 value)))
      (state_monad$read_regS mie_ref)) (\ (w__7 : Minterrupts) . 
      state_monad$returnS (SOME ((get_Minterrupts w__7  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mtvec_ref) (\ (w__8 : Mtvec) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mtvec_ref ((legalize_tvec w__8 value)))
      (state_monad$read_regS mtvec_ref)) (\ (w__9 : Mtvec) .  state_monad$returnS (SOME ((get_Mtvec w__9  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mscratch_ref value)
      (state_monad$read_regS mscratch_ref  : ( 64 words$word) M)) (\ (w__10 :  64 words$word) .  state_monad$returnS (SOME w__10))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then state_monad$bindS
      (legalize_xepc value  : ( 64 words$word) M) (\ (w__11 : xlenbits) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mepc_ref w__11)
      (state_monad$read_regS mepc_ref  : ( 64 words$word) M)) (\ (w__12 :  64 words$word) .  state_monad$returnS (SOME w__12)))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (set_Mcause mcause_ref value)
      (state_monad$read_regS mcause_ref)) (\ (w__13 : Mcause) . 
      state_monad$returnS (SOME ((get_Mcause w__13  :  64 words$word))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mtval_ref value)
      (state_monad$read_regS mtval_ref  : ( 64 words$word) M)) (\ (w__14 :  64 words$word) .  state_monad$returnS (SOME w__14))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mip_ref) (\ (w__15 : Minterrupts) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mip_ref ((legalize_mip w__15 value)))
      (state_monad$read_regS mip_ref)) (\ (w__16 : Minterrupts) . 
      state_monad$returnS (SOME ((get_Minterrupts w__16  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__17 : Mstatus) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mstatus_ref ((legalize_sstatus w__17 value)))
      (state_monad$read_regS mstatus_ref)) (\ (w__18 : Mstatus) . 
      state_monad$returnS (SOME ((get_Mstatus w__18  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS sedeleg_ref) (\ (w__19 : Sedeleg) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS sedeleg_ref ((legalize_sedeleg w__19 value)))
      (state_monad$read_regS sedeleg_ref)) (\ (w__20 : Sedeleg) . 
      state_monad$returnS (SOME ((get_Sedeleg w__20  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (set_Sinterrupts sideleg_ref value)
      (state_monad$read_regS sideleg_ref)) (\ (w__21 : Sinterrupts) . 
      state_monad$returnS (SOME ((get_Sinterrupts w__21  :  64 words$word))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mie_ref) (\ (w__22 : Minterrupts) .  state_monad$bindS
      (state_monad$read_regS mideleg_ref) (\ (w__23 : Minterrupts) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mie_ref ((legalize_sie w__22 w__23 value)))
      (state_monad$read_regS mie_ref)) (\ (w__24 : Minterrupts) . 
      state_monad$returnS (SOME ((get_Minterrupts w__24  :  64 words$word))))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS stvec_ref) (\ (w__25 : Mtvec) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS stvec_ref ((legalize_tvec w__25 value)))
      (state_monad$read_regS stvec_ref)) (\ (w__26 : Mtvec) .  state_monad$returnS (SOME ((get_Mtvec w__26  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (state_monad$write_regS sscratch_ref value)
      (state_monad$read_regS sscratch_ref  : ( 64 words$word) M)) (\ (w__27 :  64 words$word) .  state_monad$returnS (SOME w__27))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then state_monad$bindS
      (legalize_xepc value  : ( 64 words$word) M) (\ (w__28 : xlenbits) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS sepc_ref w__28)
      (state_monad$read_regS sepc_ref  : ( 64 words$word) M)) (\ (w__29 :  64 words$word) .  state_monad$returnS (SOME w__29)))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (set_Mcause scause_ref value)
      (state_monad$read_regS scause_ref)) (\ (w__30 : Mcause) . 
      state_monad$returnS (SOME ((get_Mcause w__30  :  64 words$word))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (state_monad$write_regS stval_ref value)
      (state_monad$read_regS stval_ref  : ( 64 words$word) M)) (\ (w__31 :  64 words$word) .  state_monad$returnS (SOME w__31))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (state_monad$read_regS mip_ref) (\ (w__32 : Minterrupts) .  state_monad$bindS
      (state_monad$read_regS mideleg_ref) (\ (w__33 : Minterrupts) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS mip_ref ((legalize_sip w__32 w__33 value)))
      (state_monad$read_regS mip_ref)) (\ (w__34 : Minterrupts) . 
      state_monad$returnS (SOME ((get_Minterrupts w__34  :  64 words$word))))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS
      (cur_Architecture () ) (\ (w__35 : Architecture) .  state_monad$bindS
      (state_monad$read_regS satp_ref  : ( 64 words$word) M) (\ (w__36 :  64 words$word) .  state_monad$bindS (state_monad$seqS
      (state_monad$write_regS satp_ref ((legalize_satp w__35 w__36 value  :  64 words$word)))
      (state_monad$read_regS satp_ref  : ( 64 words$word) M)) (\ (w__37 :  64 words$word) .  state_monad$returnS (SOME w__37))))
    else if (((b__0 = (vec_of_bits [B0;B1;B1;B1;B1;B0;B1;B0;B0;B0;B0;B0]  :  12 words$word)))) then state_monad$bindS (state_monad$seqS
      (state_monad$write_regS tselect_ref value)
      (state_monad$read_regS tselect_ref  : ( 64 words$word) M)) (\ (w__38 :  64 words$word) .  state_monad$returnS (SOME w__38))
    else state_monad$returnS NONE) (\ (res :  xlenbits option) . 
   state_monad$returnS ((case res of
     SOME (v) =>
      prerr_endline
        ((STRCAT "CSR "
            ((STRCAT ((csr_name csr))
                ((STRCAT " <- "
                    ((STRCAT ((string_of_vec v))
                        ((STRCAT " (input: " ((STRCAT ((string_of_vec value)) ")"))))))))))))
   | NONE => print_bits "unhandled write to CSR " csr
   )))))`;


val _ = Define `
 ((decode:(32)words$word ->(ast)option) v__0=
    (if (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  :  7 words$word)))) then
     let (imm : 20 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (UTYPE (imm,rd,RISCV_LUI))
   else if (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  :  7 words$word)))) then
     let (imm : 20 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (UTYPE (imm,rd,RISCV_AUIPC))
   else if (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  :  7 words$word)))) then
     let (imm : 20 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 12 : int):ii)  :  20 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RISCV_JAL ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm (( 19 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm (( 7 : int):ii) (( 0 : int):ii)  :  8 words$word))
                             ((concat_vec
                                 ((cast_unit_vec0 ((access_vec_dec imm (( 8 : int):ii)))  :  1 words$word))
                                 ((concat_vec ((subrange_vec_dec imm (( 18 : int):ii) (( 13 : int):ii)  :  6 words$word))
                                     ((concat_vec
                                         ((subrange_vec_dec imm (( 12 : int):ii) (( 9 : int):ii)  :  4 words$word))
                                         (vec_of_bits [B0]  :  1 words$word)
                                        :  5 words$word))
                                    :  11 words$word))
                                :  12 words$word))
                            :  20 words$word))
                        :  21 words$word),rd))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RISCV_JALR (imm,rs1,rd))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):ii) (( 1 : int):ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BEQ))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):ii) (( 1 : int):ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BNE))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):ii) (( 1 : int):ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BLT))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):ii) (( 1 : int):ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BGE))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):ii) (( 1 : int):ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BLTU))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):ii) (( 1 : int):ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BGEU))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_ADDI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_SLTI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_SLTIU))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_XORI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_ORI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_ANDI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 26 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 6 bits) = ((subrange_vec_dec v__0 (( 25 : int):ii) (( 20 : int):ii)  :  6 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (SHIFTIOP (shamt,rs1,rd,RISCV_SLLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 26 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 6 bits) = ((subrange_vec_dec v__0 (( 25 : int):ii) (( 20 : int):ii)  :  6 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (SHIFTIOP (shamt,rs1,rd,RISCV_SRLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 26 : int):ii)  :  6 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 6 bits) = ((subrange_vec_dec v__0 (( 25 : int):ii) (( 20 : int):ii)  :  6 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (SHIFTIOP (shamt,rs1,rd,RISCV_SRAI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_ADD))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SUB))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SLL))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SLT))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SLTU))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_XOR))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SRL))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SRA))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_OR))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_AND))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,BYTE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,HALF,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,WORD,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,DOUBLE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,T,BYTE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,T,HALF,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,T,WORD,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,BYTE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,HALF,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,WORD,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (imm5 : 5 bits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,DOUBLE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (ADDIW (imm,rs1,rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 5 bits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (SHIFTW (shamt,rs1,rd,RISCV_SLLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 5 bits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (SHIFTW (shamt,rs1,rd,RISCV_SRLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 5 bits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (SHIFTW (shamt,rs1,rd,RISCV_SRAI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_ADDW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SUBW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SLLW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SRLW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SRAW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,F,T,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,T,T,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,T,T,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,T,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (DIV0 (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (DIV0 (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (REM (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (REM (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (MULW (rs2,rs1,rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (DIVW (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (DIVW (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (REMW (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (REMW (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 28 : int):ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec v__0 (( 19 : int):ii) (( 0 : int):ii)  :  20 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                     :  20 words$word))))))) then
     let (pred : 4 bits) = ((subrange_vec_dec v__0 (( 27 : int):ii) (( 24 : int):ii)  :  4 words$word)) in
     let (succ : 4 bits) = ((subrange_vec_dec v__0 (( 23 : int):ii) (( 20 : int):ii)  :  4 words$word)) in
     SOME (FENCE (pred,succ))
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;
                             B0;B0;B0;B0;B1;B1;B1;B1]
                 :  32 words$word)))) then
     SOME (FENCEI () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (ECALL () )
   else if (((v__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (MRET () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (SRET () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (EBREAK () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (WFI () )
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):ii) (( 25 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  :  7 words$word)))) /\ (((((subrange_vec_dec v__0 (( 14 : int):ii) (( 0 : int):ii)  :  15 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]  :  15 words$word)))))))
   then
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     SOME (SFENCE_VMA (rs1,rs2))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word))))))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOADRES (bit_to_bool aq,bit_to_bool rl,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word))))))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (LOADRES (bit_to_bool aq,bit_to_bool rl,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (STORECON (bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (STORECON (bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOSWAP,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOSWAP,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOADD,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOADD,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOXOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOXOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOAND,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOAND,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMIN,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMIN,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMAX,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMAX,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMINU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMINU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMAXU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):ii) (( 27 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):ii)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__0 (( 24 : int):ii) (( 20 : int):ii)  :  5 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (AMO (AMOMAXU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,F,CSRRW))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,F,CSRRS))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,F,CSRRC))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,T,CSRRW))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,T,CSRRS))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):ii) (( 12 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 bits) = ((subrange_vec_dec v__0 (( 31 : int):ii) (( 20 : int):ii)  :  12 words$word)) in
     let (rs1 : regbits) = ((subrange_vec_dec v__0 (( 19 : int):ii) (( 15 : int):ii)  :  5 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__0 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,T,CSRRC))
   else NONE))`;


val _ = Define `
 ((decodeCompressed:(16)words$word ->(ast)option) v__418=
    (if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzi1 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (nzi0 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     if ((((((nzi1 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((regbits_to_regno nzi0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word))))))))) then
       SOME (NOP () )
     else NONE
   else if (((v__418 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  16 words$word)))) then
     SOME (ILLEGAL () )
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (nz54 : 2 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 11 : int):ii)  :  2 words$word)) in
     let (nz96 : 4 bits) = ((subrange_vec_dec v__418 (( 10 : int):ii) (( 7 : int):ii)  :  4 words$word)) in
     let (nz2 : 1 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)) in
     let (nz3 : 1 bits) = ((subrange_vec_dec v__418 (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)) in
     let (rd : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let nzimm =
       ((concat_vec nz96 ((concat_vec nz54 ((concat_vec nz3 nz2  :  2 words$word))  :  4 words$word))
         :  8 words$word)) in
     if (((nzimm = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)))) then NONE
     else SOME (C_ADDI4SPN (rd,nzimm))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) in
     let (rs1 : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (ui2 : 1 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)) in
     let (ui6 : 1 bits) = ((subrange_vec_dec v__418 (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)) in
     let (rd : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui6 ((concat_vec ui53 ui2  :  4 words$word))  :  5 words$word)) in
     SOME (C_LW (uimm,rs1,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) in
     let (rs1 : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (ui76 : 2 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) in
     let (rd : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui76 ui53  :  5 words$word)) in
     SOME (C_LD (uimm,rs1,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) in
     let (rs1 : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (ui2 : 1 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)) in
     let (ui6 : 1 bits) = ((subrange_vec_dec v__418 (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui6 ((concat_vec ui53 ui2  :  4 words$word))  :  5 words$word)) in
     SOME (C_SW (uimm,rs1,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) in
     let (rs1 : 3 bits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (ui76 : 2 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) in
     let (rs2 : 3 bits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui76 ui53  :  5 words$word)) in
     SOME (C_SD (uimm,rs1,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (nzi5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rsd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (nzi40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     let nzi = ((concat_vec nzi5 nzi40  :  6 words$word)) in
     if ((((((nzi = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) \/ (((((regbits_to_regno rsd)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_ADDI (nzi,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (imm5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rsd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (imm40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     SOME (C_ADDIW ((concat_vec imm5 imm40  :  6 words$word),rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (imm5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (imm40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_LI ((concat_vec imm5 imm40  :  6 words$word),rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzi9 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (nzi4 : 1 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)) in
     let (nzi6 : 1 bits) = ((subrange_vec_dec v__418 (( 5 : int):ii) (( 5 : int):ii)  :  1 words$word)) in
     let (nzi87 : 2 bits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 3 : int):ii)  :  2 words$word)) in
     let (nzi5 : 1 bits) = ((subrange_vec_dec v__418 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)) in
     let nzimm =
       ((concat_vec nzi9
          ((concat_vec nzi87 ((concat_vec nzi6 ((concat_vec nzi5 nzi4  :  2 words$word))  :  3 words$word))
             :  5 words$word))
         :  6 words$word)) in
     if (((nzimm = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) then NONE
     else SOME (C_ADDI16SP nzimm)
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (imm17 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (imm1612 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     if ((((((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) \/ (((((regbits_to_regno rd)) = ((regbits_to_regno sp)))))))) then
       NONE
     else SOME (C_LUI ((concat_vec imm17 imm1612  :  6 words$word),rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzui5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (nzui40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     let (shamt : 6 bits) = ((concat_vec nzui5 nzui40  :  6 words$word)) in
     if (((shamt = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) then NONE
     else SOME (C_SRLI (shamt,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzui5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (nzui40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     let (shamt : 6 bits) = ((concat_vec nzui5 nzui40  :  6 words$word)) in
     if (((shamt = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) then NONE
     else SOME (C_SRAI (shamt,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (i5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (i40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     SOME (C_ANDI ((concat_vec i5 i40  :  6 words$word),rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     SOME (C_SUB (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     SOME (C_XOR (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     SOME (C_OR (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     SOME (C_AND (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     SOME (C_SUBW (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 10 : int):ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : cregbits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     SOME (C_ADDW (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (i11 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (i4 : 1 bits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 11 : int):ii)  :  1 words$word)) in
     let (i98 : 2 bits) = ((subrange_vec_dec v__418 (( 10 : int):ii) (( 9 : int):ii)  :  2 words$word)) in
     let (i10 : 1 bits) = ((subrange_vec_dec v__418 (( 8 : int):ii) (( 8 : int):ii)  :  1 words$word)) in
     let (i6 : 1 bits) = ((subrange_vec_dec v__418 (( 7 : int):ii) (( 7 : int):ii)  :  1 words$word)) in
     let (i7 : 1 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 6 : int):ii)  :  1 words$word)) in
     let (i31 : 3 bits) = ((subrange_vec_dec v__418 (( 5 : int):ii) (( 3 : int):ii)  :  3 words$word)) in
     let (i5 : 1 bits) = ((subrange_vec_dec v__418 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)) in
     SOME (C_J ((concat_vec i11
                   ((concat_vec i10
                       ((concat_vec i98
                           ((concat_vec i7
                               ((concat_vec i6
                                   ((concat_vec i5 ((concat_vec i4 i31  :  4 words$word))  :  5 words$word))
                                  :  6 words$word))
                              :  7 words$word))
                          :  9 words$word))
                      :  10 words$word))
                  :  11 words$word)))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (i8 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (i43 : 2 bits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (rs : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (i76 : 2 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) in
     let (i21 : 2 bits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 3 : int):ii)  :  2 words$word)) in
     let (i5 : 1 bits) = ((subrange_vec_dec v__418 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)) in
     SOME (C_BEQZ ((concat_vec i8
                      ((concat_vec i76
                          ((concat_vec i5 ((concat_vec i43 i21  :  4 words$word))  :  5 words$word))
                         :  7 words$word))
                     :  8 words$word),rs))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (i8 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (i43 : 2 bits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 10 : int):ii)  :  2 words$word)) in
     let (rs : cregbits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (i76 : 2 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) in
     let (i21 : 2 bits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 3 : int):ii)  :  2 words$word)) in
     let (i5 : 1 bits) = ((subrange_vec_dec v__418 (( 2 : int):ii) (( 2 : int):ii)  :  1 words$word)) in
     SOME (C_BNEZ ((concat_vec i8
                      ((concat_vec i76
                          ((concat_vec i5 ((concat_vec i43 i21  :  4 words$word))  :  5 words$word))
                         :  7 words$word))
                     :  8 words$word),rs))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (nzui5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rsd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (nzui40 : 5 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     let (shamt : 6 bits) = ((concat_vec nzui5 nzui40  :  6 words$word)) in
     if ((((((shamt = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) \/ (((((regbits_to_regno rsd)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_SLLI (shamt,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (ui42 : 3 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 4 : int):ii)  :  3 words$word)) in
     let (ui76 : 2 bits) = ((subrange_vec_dec v__418 (( 3 : int):ii) (( 2 : int):ii)  :  2 words$word)) in
     let (uimm : 6 bits) = ((concat_vec ui76 ((concat_vec ui5 ui42  :  4 words$word))  :  6 words$word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_LWSP (uimm,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui5 : 1 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 12 : int):ii)  :  1 words$word)) in
     let (rd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (ui43 : 2 bits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 5 : int):ii)  :  2 words$word)) in
     let (ui86 : 3 bits) = ((subrange_vec_dec v__418 (( 4 : int):ii) (( 2 : int):ii)  :  3 words$word)) in
     let (uimm : 6 bits) = ((concat_vec ui86 ((concat_vec ui5 ui43  :  3 words$word))  :  6 words$word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_LDSP (uimm,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui52 : 4 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 9 : int):ii)  :  4 words$word)) in
     let (ui76 : 2 bits) = ((subrange_vec_dec v__418 (( 8 : int):ii) (( 7 : int):ii)  :  2 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     let (uimm : 6 bits) = ((concat_vec ui76 ui52  :  6 words$word)) in
     SOME (C_SWSP (uimm,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 13 : int):ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui53 : 3 bits) = ((subrange_vec_dec v__418 (( 12 : int):ii) (( 10 : int):ii)  :  3 words$word)) in
     let (ui86 : 3 bits) = ((subrange_vec_dec v__418 (( 9 : int):ii) (( 7 : int):ii)  :  3 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     let (uimm : 6 bits) = ((concat_vec ui86 ui53  :  6 words$word)) in
     SOME (C_SDSP (uimm,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  :  7 words$word))))))) then
     let (rs1 : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     if (((((regbits_to_regno rs1)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_JR rs1)
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 6 : int):ii) (( 0 : int):ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  :  7 words$word))))))) then
     let (rs1 : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     if (((((regbits_to_regno rs1)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_JALR rs1)
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (rd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     if ((((((((regbits_to_regno rs2)) = ((regbits_to_regno zreg))))) \/ (((((regbits_to_regno rd)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_MV (rd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):ii) (( 12 : int):ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (rsd : regbits) = ((subrange_vec_dec v__418 (( 11 : int):ii) (( 7 : int):ii)  :  5 words$word)) in
     let (rs2 : regbits) = ((subrange_vec_dec v__418 (( 6 : int):ii) (( 2 : int):ii)  :  5 words$word)) in
     if ((((((((regbits_to_regno rsd)) = ((regbits_to_regno zreg))))) \/ (((((regbits_to_regno rs2)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_ADD (rsd,rs2))
   else NONE))`;


(*val execute_WFI : unit -> M unit*)

 val _ = Define `
 ((execute_WFI:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__110=  (state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) . 
   (case w__0 of
     Machine => state_monad$returnS () 
   | Supervisor => state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__1 : Mstatus) . 
      if (((((get_Mstatus_TW w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
        handle_illegal () 
      else state_monad$returnS () )
   | User => handle_illegal () 
   ))))`;


(*val execute_UTYPE : mword ty20 -> mword ty5 -> uop -> M unit*)

 val _ = Define `
 ((execute_UTYPE:(20)words$word ->(5)words$word -> uop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rd op=
    (let (off : xlenbits) =
     ((EXTS (( 64 : int):ii)
        ((concat_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)
           :  32 words$word))
       :  64 words$word)) in state_monad$bindS
   (case op of
     RISCV_LUI => state_monad$returnS off
   | RISCV_AUIPC => state_monad$bindS
      (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
      state_monad$returnS ((add_vec w__0 off  :  64 words$word)))
   ) (\ (ret : xlenbits) . 
   wX ((regbits_to_regno rd)) ret)))`;


(*val execute_STORECON : bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_STORECON:bool -> bool ->(5)words$word ->(5)words$word -> word_width ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) aq rl rs2 rs1 width rd=  (state_monad$bindS
   (speculate_conditional_success () ) (\ (w__0 : bool) . 
   let (status : 1 bits) =
     (if w__0 then (vec_of_bits [B0]  :  1 words$word)
     else (vec_of_bits [B1]  :  1 words$word)) in state_monad$seqS
   (wX ((regbits_to_regno rd)) ((EXTZ (( 64 : int):ii) status  :  64 words$word)))
   (if (((status = (vec_of_bits [B1]  :  1 words$word)))) then state_monad$returnS () 
   else state_monad$bindS
     (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (vaddr : xlenbits) .  state_monad$bindS
     (translateAddr vaddr Write Data) (\ (w__1 : TR_Result) . 
     (case w__1 of
       TR_Failure (e) => handle_mem_exception vaddr e
     | TR_Address (addr) => state_monad$bindS
        (case width of
          WORD => mem_write_ea addr (( 4 : int):ii) aq rl T
        | DOUBLE => mem_write_ea addr (( 8 : int):ii) aq rl T
        | _ => internal_error "STORECON expected word or double"
        ) (\ (eares : unit MemoryOpResult) . 
        (case eares of
          MemException (e) => handle_mem_exception addr e
        | MemValue (_) => state_monad$bindS
           (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val .  state_monad$bindS
           (case width of
             WORD =>
              mem_write_value addr (( 4 : int):ii) ((subrange_vec_dec rs2_val (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word))
                aq rl T
           | DOUBLE => mem_write_value addr (( 8 : int):ii) rs2_val aq rl T
           | _ => internal_error "STORECON expected word or double"
           ) (\ (res : unit MemoryOpResult) . 
           (case res of
             MemValue (_) => state_monad$returnS () 
           | MemException (e) => handle_mem_exception addr e
           )))
        ))
     )))))))`;


(*val execute_STORE : mword ty12 -> mword ty5 -> mword ty5 -> word_width -> bool -> bool -> M unit*)

 val _ = Define `
 ((execute_STORE:(12)words$word ->(5)words$word ->(5)words$word -> word_width -> bool -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rs2 rs1 width aq rl=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let (vaddr : xlenbits) = ((add_vec w__0 ((EXTS (( 64 : int):ii) imm  :  64 words$word))  :  64 words$word)) in state_monad$bindS
   (translateAddr vaddr Write Data) (\ (w__1 : TR_Result) . 
   (case w__1 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) => state_monad$bindS
      (case width of
        BYTE => mem_write_ea addr (( 1 : int):ii) aq rl F
      | HALF => mem_write_ea addr (( 2 : int):ii) aq rl F
      | WORD => mem_write_ea addr (( 4 : int):ii) aq rl F
      | DOUBLE => mem_write_ea addr (( 8 : int):ii) aq rl F
      ) (\ (eares : unit MemoryOpResult) . 
      (case eares of
        MemException (e) => handle_mem_exception addr e
      | MemValue (_) => state_monad$bindS
         (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val .  state_monad$bindS
         (case width of
           BYTE =>
            mem_write_value addr (( 1 : int):ii) ((subrange_vec_dec rs2_val (( 7 : int):ii) (( 0 : int):ii)  :  8 words$word)) aq
              rl F
         | HALF =>
            mem_write_value addr (( 2 : int):ii) ((subrange_vec_dec rs2_val (( 15 : int):ii) (( 0 : int):ii)  :  16 words$word)) aq
              rl F
         | WORD =>
            mem_write_value addr (( 4 : int):ii) ((subrange_vec_dec rs2_val (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) aq
              rl F
         | DOUBLE => mem_write_value addr (( 8 : int):ii) rs2_val aq rl F
         ) (\ (res : unit MemoryOpResult) . 
         (case res of
           MemValue (_) => state_monad$returnS () 
         | MemException (e) => handle_mem_exception addr e
         )))
      ))
   )))))`;


(*val execute_SRET : unit -> M unit*)

 val _ = Define `
 ((execute_SRET:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__108=  (state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) . 
   (case w__0 of
     User => handle_illegal () 
   | Supervisor => state_monad$bindS
      (state_monad$read_regS mstatus_ref) (\ (w__1 : Mstatus) . 
      if (((((get_Mstatus_TSR w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
        handle_illegal () 
      else state_monad$bindS
        (state_monad$read_regS cur_privilege_ref) (\ (w__2 : Privilege) .  state_monad$bindS
        (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__3 :  64 words$word) .  state_monad$bindS
        (handle_exception w__2 (CTL_SRET () ) w__3  : ( 64 words$word) M) (\ (w__4 : xlenbits) . 
        state_monad$write_regS nextPC_ref w__4))))
   | Machine => state_monad$bindS
      (state_monad$read_regS cur_privilege_ref) (\ (w__5 : Privilege) .  state_monad$bindS
      (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__6 :  64 words$word) .  state_monad$bindS
      (handle_exception w__5 (CTL_SRET () ) w__6  : ( 64 words$word) M) (\ (w__7 : xlenbits) . 
      state_monad$write_regS nextPC_ref w__7)))
   ))))`;


(*val execute_SHIFTW : mword ty5 -> mword ty5 -> mword ty5 -> sop -> M unit*)

 val _ = Define `
 ((execute_SHIFTW:(5)words$word ->(5)words$word ->(5)words$word -> sop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) shamt rs1 rd op=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in
   let (result : 32 bits) =
     ((case op of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  :  32 words$word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  :  32 words$word)
     | RISCV_SRAI => (shift_right_arith32 rs1_val shamt  :  32 words$word)
     )) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):ii) result  :  64 words$word)))))`;


(*val execute_SHIFTIOP : mword ty6 -> mword ty5 -> mword ty5 -> sop -> M unit*)

 val _ = Define `
 ((execute_SHIFTIOP:(6)words$word ->(5)words$word ->(5)words$word -> sop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) shamt rs1 rd op=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val . 
   let (result : xlenbits) =
     ((case op of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  :  64 words$word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  :  64 words$word)
     | RISCV_SRAI => (shift_right_arith64 rs1_val shamt  :  64 words$word)
     )) in
   wX ((regbits_to_regno rd)) result)))`;


(*val execute_SFENCE_VMA : mword ty5 -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_SFENCE_VMA:(5)words$word ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs1 rs2=  (state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) . 
   if (((((privLevel_to_bits w__0  :  2 words$word)) = ((privLevel_to_bits User  :  2 words$word)))))
   then
     handle_illegal () 
   else state_monad$bindS
     (state_monad$read_regS mstatus_ref) (\ (w__1 : Mstatus) .  state_monad$bindS
     (state_monad$read_regS mstatus_ref) (\ (w__2 : Mstatus) . 
     let p__104 =
       (architecture ((get_Mstatus_SXL w__1  :  2 words$word)), (get_Mstatus_TVM w__2  :  1 words$word)) in
     (case p__104 of
       (SOME (RV64), v_0) =>
        if (((v_0 = ((bool_to_bits T  :  1 words$word))))) then handle_illegal () 
        else state_monad$bindS
          (if (((((regbits_to_regno rs1)) = (( 0 : int):ii)))) then state_monad$returnS NONE
           else state_monad$bindS
             (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__3 :  64 words$word) . 
             state_monad$returnS (SOME ((subrange_vec_dec w__3 (( 38 : int):ii) (( 0 : int):ii)  :  39 words$word))))) (\ (addr :
             vaddr39 option) .  state_monad$bindS
          (if (((((regbits_to_regno rs2)) = (( 0 : int):ii)))) then state_monad$returnS NONE
           else state_monad$bindS
             (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ (w__4 :  64 words$word) . 
             state_monad$returnS (SOME ((subrange_vec_dec w__4 (( 15 : int):ii) (( 0 : int):ii)  :  16 words$word))))) (\ (asid :
             asid64 option) . 
          flushTLB asid addr))
     | (g__102, g__103) => internal_error "unimplemented sfence architecture"
     ))))))`;


(*val execute_RTYPEW : mword ty5 -> mword ty5 -> mword ty5 -> ropw -> M unit*)

 val _ = Define `
 ((execute_RTYPEW:(5)words$word ->(5)words$word ->(5)words$word -> ropw ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd op=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in
   let (result : 32 bits) =
     ((case op of
       RISCV_ADDW => (add_vec rs1_val rs2_val  :  32 words$word)
     | RISCV_SUBW => (sub_vec rs1_val rs2_val  :  32 words$word)
     | RISCV_SLLW =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word))
          :  32 words$word)
     | RISCV_SRLW =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word))
          :  32 words$word)
     | RISCV_SRAW =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec rs2_val (( 4 : int):ii) (( 0 : int):ii)  :  5 words$word))
          :  32 words$word)
     )) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):ii) result  :  64 words$word))))))`;


(*val execute_RTYPE : mword ty5 -> mword ty5 -> mword ty5 -> rop -> M unit*)

 val _ = Define `
 ((execute_RTYPE:(5)words$word ->(5)words$word ->(5)words$word -> rop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd op=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val .  state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val . 
   let (result : xlenbits) =
     ((case op of
       RISCV_ADD => (add_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_SUB => (sub_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_SLL =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
          :  64 words$word)
     | RISCV_SLT =>
        (EXTZ (( 64 : int):ii) ((bool_to_bits ((zopz0zI_s rs1_val rs2_val))  :  1 words$word))  :  64 words$word)
     | RISCV_SLTU =>
        (EXTZ (( 64 : int):ii) ((bool_to_bits ((zopz0zI_u rs1_val rs2_val))  :  1 words$word))  :  64 words$word)
     | RISCV_XOR => (xor_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_SRL =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
          :  64 words$word)
     | RISCV_SRA =>
        (shift_right_arith64 rs1_val ((subrange_vec_dec rs2_val (( 5 : int):ii) (( 0 : int):ii)  :  6 words$word))
          :  64 words$word)
     | RISCV_OR => (or_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_AND => (and_vec rs1_val rs2_val  :  64 words$word)
     )) in
   wX ((regbits_to_regno rd)) result))))`;


(*val execute_RISCV_JALR : mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_RISCV_JALR:(12)words$word ->(5)words$word ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rs1 rd=  (state_monad$bindS
   (state_monad$read_regS nextPC_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  state_monad$bindS (state_monad$seqS
   (wX ((regbits_to_regno rd)) w__0)
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M)) (\ (w__1 :  64 words$word) . 
   let (newPC : xlenbits) = ((add_vec w__1 ((EXTS (( 64 : int):ii) imm  :  64 words$word))  :  64 words$word)) in
   state_monad$write_regS
     nextPC_ref
     ((concat_vec ((subrange_vec_dec newPC (( 63 : int):ii) (( 1 : int):ii)  :  63 words$word))
         (vec_of_bits [B0]  :  1 words$word)
        :  64 words$word))))))`;


(*val execute_RISCV_JAL : mword ty21 -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_RISCV_JAL:(21)words$word ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rd=  (state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (pc : xlenbits) .  state_monad$bindS
   (state_monad$read_regS nextPC_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) .  state_monad$seqS
   (wX ((regbits_to_regno rd)) w__0)
   (let (offset : xlenbits) = ((EXTS (( 64 : int):ii) imm  :  64 words$word)) in
   state_monad$write_regS nextPC_ref ((add_vec pc offset  :  64 words$word)))))))`;


(*val execute_REMW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

 val _ = Define `
 ((execute_REMW:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in
   let (rs1_int : ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (r : ii) = (if (((rs2_int = (( 0 : int):ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):ii) ((to_bits (( 32 : int):ii) r  :  32 words$word))  :  64 words$word))))))`;


(*val execute_REM : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

 val _ = Define `
 ((execute_REM:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val .  state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val . 
   let (rs1_int : ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (r : ii) = (if (((rs2_int = (( 0 : int):ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
   wX ((regbits_to_regno rd)) ((to_bits xlen r  :  64 words$word))))))`;


(*val execute_NOP : unit -> unit*)

 val _ = Define `
 ((execute_NOP:unit -> unit) g__111=  () )`;


(*val execute_MULW : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_MULW:(5)words$word ->(5)words$word ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in
   let (rs1_int : ii) = (integer_word$w2i rs1_val) in
   let (rs2_int : ii) = (integer_word$w2i rs2_val) in
   let result32 =
     ((subrange_vec_dec ((to_bits (( 64 : int):ii) ((rs1_int * rs2_int))  :  64 words$word)) (( 31 : int):ii)
        (( 0 : int):ii)
       :  32 words$word)) in
   let (result : xlenbits) = ((EXTS (( 64 : int):ii) result32  :  64 words$word)) in
   wX ((regbits_to_regno rd)) result))))`;


(*val execute_MUL : mword ty5 -> mword ty5 -> mword ty5 -> bool -> bool -> bool -> M unit*)

 val _ = Define `
 ((execute_MUL:(5)words$word ->(5)words$word ->(5)words$word -> bool -> bool -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd high signed1 signed2=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val .  state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val . 
   let (rs1_int : ii) = (if signed1 then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : ii) = (if signed2 then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let result128 = ((to_bits (( 128 : int):ii) ((rs1_int * rs2_int))  :  128 words$word)) in
   let result =
     (if high then (subrange_vec_dec result128 (( 127 : int):ii) (( 64 : int):ii)  :  64 words$word)
     else (subrange_vec_dec result128 (( 63 : int):ii) (( 0 : int):ii)  :  64 words$word)) in
   wX ((regbits_to_regno rd)) result))))`;


(*val execute_MRET : unit -> M unit*)

 val _ = Define `
 ((execute_MRET:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__107=  (state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) . 
   if (((((privLevel_to_bits w__0  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))))
   then state_monad$bindS
     (state_monad$read_regS cur_privilege_ref) (\ (w__1 : Privilege) .  state_monad$bindS
     (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  state_monad$bindS
     (handle_exception w__1 (CTL_MRET () ) w__2  : ( 64 words$word) M) (\ (w__3 : xlenbits) . 
     state_monad$write_regS nextPC_ref w__3)))
   else handle_illegal () )))`;


(*val execute_LOADRES : bool -> bool -> mword ty5 -> word_width -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_LOADRES:bool -> bool ->(5)words$word -> word_width ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) aq rl rs1 width rd=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (vaddr : xlenbits) .  state_monad$bindS
   (translateAddr vaddr Read Data) (\ (w__0 : TR_Result) . 
   (case w__0 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case width of
        WORD => state_monad$bindS
         (mem_read addr (( 4 : int):ii) aq rl T  : ( ( 32 words$word)MemoryOpResult) M) (\ (w__1 : ( 32 words$word)
           MemoryOpResult) . 
         process_load rd addr w__1 F)
      | DOUBLE => state_monad$bindS
         (mem_read addr (( 8 : int):ii) aq rl T  : ( ( 64 words$word)MemoryOpResult) M) (\ (w__2 : ( 64 words$word)
           MemoryOpResult) . 
         process_load rd addr w__2 F)
      | _ => internal_error "LOADRES expected WORD or DOUBLE"
      )
   )))))`;


(*val execute_LOAD : mword ty12 -> mword ty5 -> mword ty5 -> bool -> word_width -> bool -> bool -> M unit*)

 val _ = Define `
 ((execute_LOAD:(12)words$word ->(5)words$word ->(5)words$word -> bool -> word_width -> bool -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rs1 rd is_unsigned width aq rl=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let (vaddr : xlenbits) = ((add_vec w__0 ((EXTS (( 64 : int):ii) imm  :  64 words$word))  :  64 words$word)) in state_monad$bindS
   (translateAddr vaddr Read Data) (\ (w__1 : TR_Result) . 
   (case w__1 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case width of
        BYTE => state_monad$bindS
         (mem_read addr (( 1 : int):ii) aq rl F  : ( ( 8 words$word)MemoryOpResult) M) (\ (w__2 : ( 8 words$word)
           MemoryOpResult) . 
         process_load rd vaddr w__2 is_unsigned)
      | HALF => state_monad$bindS
         (mem_read addr (( 2 : int):ii) aq rl F  : ( ( 16 words$word)MemoryOpResult) M) (\ (w__3 : ( 16 words$word)
           MemoryOpResult) . 
         process_load rd vaddr w__3 is_unsigned)
      | WORD => state_monad$bindS
         (mem_read addr (( 4 : int):ii) aq rl F  : ( ( 32 words$word)MemoryOpResult) M) (\ (w__4 : ( 32 words$word)
           MemoryOpResult) . 
         process_load rd vaddr w__4 is_unsigned)
      | DOUBLE => state_monad$bindS
         (mem_read addr (( 8 : int):ii) aq rl F  : ( ( 64 words$word)MemoryOpResult) M) (\ (w__5 : ( 64 words$word)
           MemoryOpResult) . 
         process_load rd vaddr w__5 is_unsigned)
      )
   )))))`;


(*val execute_ITYPE : mword ty12 -> mword ty5 -> mword ty5 -> iop -> M unit*)

 val _ = Define `
 ((execute_ITYPE:(12)words$word ->(5)words$word ->(5)words$word -> iop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rs1 rd op=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val . 
   let (immext : xlenbits) = ((EXTS (( 64 : int):ii) imm  :  64 words$word)) in
   let (result : xlenbits) =
     ((case op of
       RISCV_ADDI => (add_vec rs1_val immext  :  64 words$word)
     | RISCV_SLTI =>
        (EXTZ (( 64 : int):ii) ((bool_to_bits ((zopz0zI_s rs1_val immext))  :  1 words$word))  :  64 words$word)
     | RISCV_SLTIU =>
        (EXTZ (( 64 : int):ii) ((bool_to_bits ((zopz0zI_u rs1_val immext))  :  1 words$word))  :  64 words$word)
     | RISCV_XORI => (xor_vec rs1_val immext  :  64 words$word)
     | RISCV_ORI => (or_vec rs1_val immext  :  64 words$word)
     | RISCV_ANDI => (and_vec rs1_val immext  :  64 words$word)
     )) in
   wX ((regbits_to_regno rd)) result)))`;


(*val execute_ILLEGAL : unit -> M unit*)

 val _ = Define `
 ((execute_ILLEGAL:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__112=  (handle_illegal () ))`;


(*val execute_FENCEI : unit -> M unit*)

 val _ = Define `
 ((execute_FENCEI:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__105=  (MEM_fence_i () ))`;


(*val execute_FENCE : mword ty4 -> mword ty4 -> M unit*)

 val _ = Define `
 ((execute_FENCE:(4)words$word ->(4)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) pred succ= 
  ((case (pred, succ) of
         (b__0, b__1) =>
   if ((((((b__0 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word)))) /\
           (((b__1 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word))))))) then
     MEM_fence_rw_rw ()  else
     if ((((((b__0 = (vec_of_bits [B0;B0;B1;B0] : 4 words$word)))) /\
             (((b__1 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word))))))) then
       MEM_fence_r_rw ()  else
       if ((((((b__0 = (vec_of_bits [B0;B0;B1;B0] : 4 words$word)))) /\
               (((b__1 = (vec_of_bits [B0;B0;B1;B0] : 4 words$word))))))) then
         MEM_fence_r_r ()  else
         if ((((((b__0 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word)))) /\
                 (((b__1 = (vec_of_bits [B0;B0;B0;B1] : 4 words$word))))))) then
           MEM_fence_rw_w ()  else MEM_fence_w_w () 
   )))`;


(*val execute_ECALL : unit -> M unit*)

 val _ = Define `
 ((execute_ECALL:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__106=  (state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__0 : Privilege) . 
   let (t : sync_exception) =
     (<| sync_exception_trap :=
          ((case w__0 of
            User => E_U_EnvCall
          | Supervisor => E_S_EnvCall
          | Machine => E_M_EnvCall
          )); 
        sync_exception_excinfo := NONE |>) in state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__1 : Privilege) .  state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__2 :  64 words$word) .  state_monad$bindS
   (handle_exception w__1 (CTL_TRAP t) w__2  : ( 64 words$word) M) (\ (w__3 : xlenbits) . 
   state_monad$write_regS nextPC_ref w__3))))))`;


(*val execute_EBREAK : unit -> M unit*)

 val _ = Define `
 ((execute_EBREAK:unit ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) g__109=  (state_monad$bindS
   (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   handle_mem_exception w__0 E_Breakpoint)))`;


(*val execute_DIVW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

 val _ = Define `
 ((execute_DIVW:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) in
   let (rs1_int : ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (q : ii) = (if (((rs2_int = (( 0 : int):ii)))) then ((( 0 : int)-( 1 : int)):ii) else hardware_quot rs1_int rs2_int) in
   let (q' : ii) =
     (if (((s /\ ((q > ((((pow2 (( 31 : int):ii))) - (( 1 : int):ii)))))))) then
       (( 0 : int):ii) - ((ex_int ((pow0 (( 2 : int):ii) (( 31 : int):ii)))))
     else q) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):ii) ((to_bits (( 32 : int):ii) q'  :  32 words$word))  :  64 words$word))))))`;


(*val execute_DIV : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

 val _ = Define `
 ((execute_DIV:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val .  state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val . 
   let (rs1_int : ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (q : ii) = (if (((rs2_int = (( 0 : int):ii)))) then ((( 0 : int)-( 1 : int)):ii) else hardware_quot rs1_int rs2_int) in
   let (q' : ii) = (if (((s /\ ((q > xlen_max_signed))))) then xlen_min_signed else q) in
   wX ((regbits_to_regno rd)) ((to_bits xlen q'  :  64 words$word))))))`;


(*val execute_C_ADDIW : mword ty6 -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_C_ADDIW:(6)words$word ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rsd=
    (let (imm : 32 bits) = ((EXTS (( 32 : int):ii) imm  :  32 words$word)) in state_monad$bindS
   (rX ((regbits_to_regno rsd))  : ( 64 words$word) M) (\ rs_val . 
   let (res : 32 bits) =
     ((add_vec ((subrange_vec_dec rs_val (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word)) imm  :  32 words$word)) in
   wX ((regbits_to_regno rsd)) ((EXTS (( 64 : int):ii) res  :  64 words$word)))))`;


(*val execute_CSR : mword ty12 -> mword ty5 -> mword ty5 -> bool -> csrop -> M unit*)

 val _ = Define `
 ((execute_CSR:(12)words$word ->(5)words$word ->(5)words$word -> bool -> csrop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) csr rs1 rd is_imm op=  (state_monad$bindS
   (if is_imm then state_monad$returnS ((EXTZ (( 64 : int):ii) rs1  :  64 words$word))
    else (rX ((regbits_to_regno rs1))  : ( 64 words$word) M)) (\ (rs1_val : xlenbits) . 
   let (isWrite : bool) =
     ((case op of
       CSRRW => T
     | _ => if is_imm then (((lem$w2ui rs1_val)) <> (( 0 : int):ii)) else (((lem$w2ui rs1)) <> (( 0 : int):ii))
     )) in state_monad$bindS
   (state_monad$read_regS cur_privilege_ref) (\ (w__1 : Privilege) .  state_monad$bindS
   (check_CSR csr w__1 isWrite) (\ (w__2 : bool) . 
   if ((~ w__2)) then handle_illegal () 
   else state_monad$bindS
     (readCSR csr  : ( 64 words$word) M) (\ csr_val .  state_monad$seqS
     (if isWrite then
        let (new_val : xlenbits) =
          ((case op of
            CSRRW => rs1_val
          | CSRRS => (or_vec csr_val rs1_val  :  64 words$word)
          | CSRRC => (and_vec csr_val ((not_vec rs1_val  :  64 words$word))  :  64 words$word)
          )) in
        writeCSR csr new_val
      else state_monad$returnS () )
     (wX ((regbits_to_regno rd)) csr_val)))))))`;


(*val execute_BTYPE : mword ty13 -> mword ty5 -> mword ty5 -> bop -> M unit*)

 val _ = Define `
 ((execute_BTYPE:(13)words$word ->(5)words$word ->(5)words$word -> bop ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rs2 rs1 op=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ rs1_val .  state_monad$bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ rs2_val . 
   let (taken : bool) =
     ((case op of
       RISCV_BEQ => (rs1_val = rs2_val)
     | RISCV_BNE => (rs1_val <> rs2_val)
     | RISCV_BLT => zopz0zI_s rs1_val rs2_val
     | RISCV_BGE => zopz0zKzJ_s rs1_val rs2_val
     | RISCV_BLTU => zopz0zI_u rs1_val rs2_val
     | RISCV_BGEU => zopz0zKzJ_u rs1_val rs2_val
     )) in
   if taken then state_monad$bindS
     (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
     state_monad$write_regS nextPC_ref ((add_vec w__0 ((EXTS (( 64 : int):ii) imm  :  64 words$word))  :  64 words$word)))
   else state_monad$returnS () ))))`;


(*val execute_AMO : amoop -> bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_AMO:amoop -> bool -> bool ->(5)words$word ->(5)words$word -> word_width ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) op aq rl rs2 rs1 width rd=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (vaddr : xlenbits) .  state_monad$bindS
   (translateAddr vaddr ReadWrite Data) (\ (w__0 : TR_Result) . 
   (case w__0 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) => state_monad$bindS
      (case width of
        WORD => mem_write_ea addr (( 4 : int):ii) (((aq /\ rl))) rl T
      | DOUBLE => mem_write_ea addr (( 8 : int):ii) (((aq /\ rl))) rl T
      | _ => internal_error "AMO expected WORD or DOUBLE"
      ) (\ (eares : unit MemoryOpResult) . 
      (case eares of
        MemException (e) => handle_mem_exception addr e
      | MemValue (_) => state_monad$bindS
         (case width of
           WORD => state_monad$bindS
            (mem_read addr (( 4 : int):ii) aq (((aq /\ rl))) T  : ( ( 32 words$word)MemoryOpResult) M) (\ (w__4 : ( 32 words$word)
              MemoryOpResult) . 
            state_monad$returnS ((extend_value F w__4  : ( 64 words$word) MemoryOpResult)))
         | DOUBLE => state_monad$bindS
            (mem_read addr (( 8 : int):ii) aq (((aq /\ rl))) T  : ( ( 64 words$word)MemoryOpResult) M) (\ (w__5 : ( 64 words$word)
              MemoryOpResult) . 
            state_monad$returnS ((extend_value F w__5  : ( 64 words$word) MemoryOpResult)))
         | _ => (internal_error "AMO expected WORD or DOUBLE"  : ( ( 64 words$word)MemoryOpResult) M)
         ) (\ (rval : xlenbits MemoryOpResult) . 
         (case rval of
           MemException (e) => handle_mem_exception addr e
         | MemValue (loaded) => state_monad$bindS
            (rX ((regbits_to_regno rs2))  : ( 64 words$word) M) (\ (rs2_val : xlenbits) . 
            let (result : xlenbits) =
              ((case op of
                AMOSWAP => rs2_val
              | AMOADD => (add_vec rs2_val loaded  :  64 words$word)
              | AMOXOR => (xor_vec rs2_val loaded  :  64 words$word)
              | AMOAND => (and_vec rs2_val loaded  :  64 words$word)
              | AMOOR => (or_vec rs2_val loaded  :  64 words$word)
              | AMOMIN => (vector64 ((int_min ((integer_word$w2i rs2_val)) ((integer_word$w2i loaded))))  :  64 words$word)
              | AMOMAX => (vector64 ((int_max ((integer_word$w2i rs2_val)) ((integer_word$w2i loaded))))  :  64 words$word)
              | AMOMINU => (vector64 ((int_min ((lem$w2ui rs2_val)) ((lem$w2ui loaded))))  :  64 words$word)
              | AMOMAXU => (vector64 ((int_max ((lem$w2ui rs2_val)) ((lem$w2ui loaded))))  :  64 words$word)
              )) in state_monad$bindS
            (case width of
              WORD =>
               mem_write_value addr (( 4 : int):ii) ((subrange_vec_dec result (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word))
                 (((aq /\ rl))) rl T
            | DOUBLE => mem_write_value addr (( 8 : int):ii) result (((aq /\ rl))) rl T
            | _ => internal_error "AMO expected WORD or DOUBLE"
            ) (\ (wval : unit MemoryOpResult) . 
            (case wval of
              MemValue (_) => wX ((regbits_to_regno rd)) loaded
            | MemException (e) => handle_mem_exception addr e
            )))
         ))
      ))
   )))))`;


(*val execute_ADDIW : mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

 val _ = Define `
 ((execute_ADDIW:(12)words$word ->(5)words$word ->(5)words$word ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) imm rs1 rd=  (state_monad$bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) M) (\ (w__0 :  64 words$word) . 
   let (result : xlenbits) = ((add_vec ((EXTS (( 64 : int):ii) imm  :  64 words$word)) w__0  :  64 words$word)) in
   wX ((regbits_to_regno rd))
     ((EXTS (( 64 : int):ii) ((subrange_vec_dec result (( 31 : int):ii) (( 0 : int):ii)  :  32 words$word))  :  64 words$word)))))`;


 val execute_defn = Hol_defn "execute" `
 ((execute:ast ->(regstate)state_monad$sequential_state ->(((unit),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) merge_var=
    ((case merge_var of
     C_ADDI4SPN (rdc,nzimm) =>
      let (imm : 12 bits) =
        ((concat_vec (vec_of_bits [B0;B0]  :  2 words$word)
           ((concat_vec nzimm (vec_of_bits [B0;B0]  :  2 words$word)  :  10 words$word))
          :  12 words$word)) in
      let rd = ((creg2reg_bits rdc  :  5 words$word)) in
      execute (ITYPE (imm,sp,rd,RISCV_ADDI))
   | C_LW (uimm,rsc,rdc) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  7 words$word))
          :  12 words$word)) in
      let rd = ((creg2reg_bits rdc  :  5 words$word)) in
      let rs = ((creg2reg_bits rsc  :  5 words$word)) in
      execute (LOAD (imm,rs,rd,F,WORD,F,F))
   | C_LD (uimm,rsc,rdc) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  8 words$word))
          :  12 words$word)) in
      let rd = ((creg2reg_bits rdc  :  5 words$word)) in
      let rs = ((creg2reg_bits rsc  :  5 words$word)) in
      execute (LOAD (imm,rs,rd,F,DOUBLE,F,F))
   | C_SW (uimm,rsc1,rsc2) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  7 words$word))
          :  12 words$word)) in
      let rs1 = ((creg2reg_bits rsc1  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rsc2  :  5 words$word)) in
      execute (STORE (imm,rs2,rs1,WORD,F,F))
   | C_SD (uimm,rsc1,rsc2) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  8 words$word))
          :  12 words$word)) in
      let rs1 = ((creg2reg_bits rsc1  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rsc2  :  5 words$word)) in
      execute (STORE (imm,rs2,rs1,DOUBLE,F,F))
   | C_ADDI (nzi,rsd) =>
      let (imm : 12 bits) = ((EXTS (( 12 : int):ii) nzi  :  12 words$word)) in
      execute (ITYPE (imm,rsd,rsd,RISCV_ADDI))
   | C_JAL (imm) =>
      execute
        (RISCV_JAL ((EXTS (( 21 : int):ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  12 words$word))
                      :  21 words$word),ra))
   | C_LI (imm,rd) =>
      let (imm : 12 bits) = ((EXTS (( 12 : int):ii) imm  :  12 words$word)) in
      execute (ITYPE (imm,zreg,rd,RISCV_ADDI))
   | C_ADDI16SP (imm) =>
      let (imm : 12 bits) =
        ((EXTS (( 12 : int):ii) ((concat_vec imm (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)  :  10 words$word))
          :  12 words$word)) in
      execute (ITYPE (imm,sp,sp,RISCV_ADDI))
   | C_LUI (imm,rd) =>
      let (res : 20 bits) = ((EXTS (( 20 : int):ii) imm  :  20 words$word)) in
      execute (UTYPE (res,rd,RISCV_LUI))
   | C_SRLI (shamt,rsd) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SRLI))
   | C_SRAI (shamt,rsd) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SRAI))
   | C_ANDI (imm,rsd) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      execute (ITYPE ((EXTS (( 12 : int):ii) imm  :  12 words$word),rsd,rsd,RISCV_ANDI))
   | C_SUB (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_SUB))
   | C_XOR (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_XOR))
   | C_OR (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_OR))
   | C_AND (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_AND))
   | C_SUBW (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPEW (rs2,rsd,rsd,RISCV_SUBW))
   | C_ADDW (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPEW (rs2,rsd,rsd,RISCV_ADDW))
   | C_J (imm) =>
      execute
        (RISCV_JAL ((EXTS (( 21 : int):ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  12 words$word))
                      :  21 words$word),zreg))
   | C_BEQZ (imm,rs) =>
      execute
        (BTYPE ((EXTS (( 13 : int):ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  9 words$word))
                  :  13 words$word),zreg,(creg2reg_bits rs  :  5 words$word),RISCV_BEQ))
   | C_BNEZ (imm,rs) =>
      execute
        (BTYPE ((EXTS (( 13 : int):ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  9 words$word))
                  :  13 words$word),zreg,(creg2reg_bits rs  :  5 words$word),RISCV_BNE))
   | C_SLLI (shamt,rsd) => execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SLLI))
   | C_LWSP (uimm,rd) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  8 words$word))
          :  12 words$word)) in
      execute (LOAD (imm,sp,rd,F,WORD,F,F))
   | C_LDSP (uimm,rd) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  9 words$word))
          :  12 words$word)) in
      execute (LOAD (imm,sp,rd,F,DOUBLE,F,F))
   | C_SWSP (uimm,rs2) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  8 words$word))
          :  12 words$word)) in
      execute (STORE (imm,rs2,sp,WORD,F,F))
   | C_SDSP (uimm,rs2) =>
      let (imm : 12 bits) =
        ((EXTZ (( 12 : int):ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  9 words$word))
          :  12 words$word)) in
      execute (STORE (imm,rs2,sp,DOUBLE,F,F))
   | C_JR (rs1) =>
      execute (RISCV_JALR ((EXTZ (( 12 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  12 words$word),rs1,zreg))
   | C_JALR (rs1) =>
      execute (RISCV_JALR ((EXTZ (( 12 : int):ii) (vec_of_bits [B0]  :  1 words$word)  :  12 words$word),rs1,ra))
   | C_MV (rd,rs2) => execute (RTYPE (rs2,zreg,rd,RISCV_ADD))
   | C_ADD (rsd,rs2) => execute (RTYPE (rs2,rsd,rsd,RISCV_ADD))
   | UTYPE (imm,rd,op) => execute_UTYPE imm rd op
   | RISCV_JAL (imm,rd) => execute_RISCV_JAL imm rd
   | RISCV_JALR (imm,rs1,rd) => execute_RISCV_JALR imm rs1 rd
   | BTYPE (imm,rs2,rs1,op) => execute_BTYPE imm rs2 rs1 op
   | ITYPE (imm,rs1,rd,op) => execute_ITYPE imm rs1 rd op
   | SHIFTIOP (shamt,rs1,rd,op) => execute_SHIFTIOP shamt rs1 rd op
   | RTYPE (rs2,rs1,rd,op) => execute_RTYPE rs2 rs1 rd op
   | LOAD (imm,rs1,rd,is_unsigned,width,aq,rl) => execute_LOAD imm rs1 rd is_unsigned width aq rl
   | STORE (imm,rs2,rs1,width,aq,rl) => execute_STORE imm rs2 rs1 width aq rl
   | ADDIW (imm,rs1,rd) => execute_ADDIW imm rs1 rd
   | SHIFTW (shamt,rs1,rd,op) => execute_SHIFTW shamt rs1 rd op
   | RTYPEW (rs2,rs1,rd,op) => execute_RTYPEW rs2 rs1 rd op
   | MUL (rs2,rs1,rd,high,signed1,signed2) => execute_MUL rs2 rs1 rd high signed1 signed2
   | DIV0 (rs2,rs1,rd,s) => execute_DIV rs2 rs1 rd s
   | REM (rs2,rs1,rd,s) => execute_REM rs2 rs1 rd s
   | MULW (rs2,rs1,rd) => execute_MULW rs2 rs1 rd
   | DIVW (rs2,rs1,rd,s) => execute_DIVW rs2 rs1 rd s
   | REMW (rs2,rs1,rd,s) => execute_REMW rs2 rs1 rd s
   | FENCE (pred,succ) => execute_FENCE pred succ
   | FENCEI (g__105) => execute_FENCEI g__105
   | ECALL (g__106) => execute_ECALL g__106
   | MRET (g__107) => execute_MRET g__107
   | SRET (g__108) => execute_SRET g__108
   | EBREAK (g__109) => execute_EBREAK g__109
   | WFI (g__110) => execute_WFI g__110
   | SFENCE_VMA (rs1,rs2) => execute_SFENCE_VMA rs1 rs2
   | LOADRES (aq,rl,rs1,width,rd) => execute_LOADRES aq rl rs1 width rd
   | STORECON (aq,rl,rs2,rs1,width,rd) => execute_STORECON aq rl rs2 rs1 width rd
   | AMO (op,aq,rl,rs2,rs1,width,rd) => execute_AMO op aq rl rs2 rs1 width rd
   | CSR (csr,rs1,rd,is_imm,op) => execute_CSR csr rs1 rd is_imm op
   | NOP (g__111) => state_monad$returnS ((execute_NOP g__111))
   | ILLEGAL (g__112) => execute_ILLEGAL g__112
   | C_ADDIW (imm,rsd) => execute_C_ADDIW imm rsd
   )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn execute_defn;

val _ = Define `
 ((print_insn:ast -> string) merge_var=
    ((case merge_var of
     UTYPE (imm,rd,op) =>
      (case op of
        RISCV_LUI =>
         STRCAT "lui   "
           ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
      | RISCV_AUIPC =>
         STRCAT "auipc "
           ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
      )
   | RISCV_JAL (imm,rd) =>
      STRCAT "jal   "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
   | RISCV_JALR (imm,rs1,rd) =>
      STRCAT "jalr  "
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | BTYPE (imm,rs2,rs1,op) =>
      let (insn : string) =
        ((case op of
          RISCV_BEQ => "beq   "
        | RISCV_BNE => "bne   "
        | RISCV_BLT => "blt   "
        | RISCV_BGE => "bge   "
        | RISCV_BLTU => "bltu  "
        | RISCV_BGEU => "bgeu  "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rs1))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs2)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | ITYPE (imm,rs1,rd,op) =>
      let (insn : string) =
        ((case op of
          RISCV_ADDI => "addi  "
        | RISCV_SLTI => "slti  "
        | RISCV_SLTIU => "sltiu "
        | RISCV_XORI => "xori  "
        | RISCV_ORI => "ori   "
        | RISCV_ANDI => "andi  "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | SHIFTIOP (shamt,rs1,rd,op) =>
      let (insn : string) =
        ((case op of   RISCV_SLLI => "slli  " | RISCV_SRLI => "srli  " | RISCV_SRAI => "srai  " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec shamt))))))))))
   | RTYPE (rs2,rs1,rd,op) =>
      let (insn : string) =
        ((case op of
          RISCV_ADD => "add   "
        | RISCV_SUB => "sub   "
        | RISCV_SLL => "sll   "
        | RISCV_SLT => "slt   "
        | RISCV_SLTU => "sltu  "
        | RISCV_XOR => "xor   "
        | RISCV_SRL => "srl   "
        | RISCV_SRA => "sra   "
        | RISCV_OR => "or    "
        | RISCV_AND => "and   "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | LOAD (imm,rs1,rd,is_unsigned,width,aq,rl) =>
      let (insn : string) =
        ((case (width, is_unsigned) of
          (BYTE, F) => "lb    "
        | (BYTE, T) => "lbu   "
        | (HALF, F) => "lh    "
        | (HALF, T) => "lhu   "
        | (WORD, F) => "lw    "
        | (WORD, T) => "lwu   "
        | (DOUBLE, F) => "ld    "
        | (DOUBLE, T) => "ldu   "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | STORE (imm,rs2,rs1,width,aq,rl) =>
      let (insn : string) =
        ((case width of
          BYTE => "sb    "
        | HALF => "sh    "
        | WORD => "sw    "
        | DOUBLE => "sd    "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rs2))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | ADDIW (imm,rs1,rd) =>
      STRCAT "addiw "
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | SHIFTW (shamt,rs1,rd,op) =>
      let (insn : string) =
        ((case op of   RISCV_SLLI => "slli  " | RISCV_SRLI => "srli  " | RISCV_SRAI => "srai  " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec shamt))))))))))
   | RTYPEW (rs2,rs1,rd,op) =>
      let (insn : string) =
        ((case op of
          RISCV_ADDW => "addw  "
        | RISCV_SUBW => "subw  "
        | RISCV_SLLW => "sllw  "
        | RISCV_SRLW => "srlw  "
        | RISCV_SRAW => "sraw  "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | MUL (rs2,rs1,rd,high,signed1,signed2) =>
      let (insn : string) =
        ((case (high, signed1, signed2) of
          (F, T, T) => "mul   "
        | (T, T, T) => "mulh  "
        | (T, T, F) => "mulhsu "
        | (T, F, F) => "mulhu"
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | DIV0 (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "div   " else "divu  ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | REM (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "rem   " else "remu  ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | MULW (rs2,rs1,rd) =>
      STRCAT "mulw  "
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | DIVW (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "divw  " else "divuw ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | REMW (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "remw  " else "remuw ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | FENCE (pred,succ) => "fence"
   | FENCEI (g__93) => "fence.i"
   | ECALL (g__94) => "ecall"
   | MRET (g__95) => "mret"
   | SRET (g__96) => "sret"
   | EBREAK (g__97) => "ebreak"
   | WFI (g__98) => "wfi"
   | SFENCE_VMA (rs1,rs2) =>
      STRCAT "sfence.vma "
        ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))
   | LOADRES (aq,rl,rs1,width,rd) =>
      let (insn : string) =
        ((case width of   WORD => "lr.w  " | DOUBLE => "lr.d  " | _ => "lr.bad " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((reg_name_abi rs1))))))
   | STORECON (aq,rl,rs2,rs1,width,rd) =>
      let (insn : string) =
        ((case width of   WORD => "sc.w  " | DOUBLE => "sc.d  " | _ => "sc.bad " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | AMO (op,aq,rl,rs2,rs1,width,rd) =>
      let (insn : string) =
        ((case (op, width) of
          (AMOSWAP, WORD) => "amoswap.w "
        | (AMOADD, WORD) => "amoadd.w  "
        | (AMOXOR, WORD) => "amoxor.w  "
        | (AMOAND, WORD) => "amoand.w  "
        | (AMOOR, WORD) => "amoor.w   "
        | (AMOMIN, WORD) => "amomin.w  "
        | (AMOMAX, WORD) => "amomax.w  "
        | (AMOMINU, WORD) => "amominu.w "
        | (AMOMAXU, WORD) => "amomaxu.w "
        | (AMOSWAP, DOUBLE) => "amoswap.d "
        | (AMOADD, DOUBLE) => "amoadd.d  "
        | (AMOXOR, DOUBLE) => "amoxor.d  "
        | (AMOAND, DOUBLE) => "amoand.d  "
        | (AMOOR, DOUBLE) => "amoor.d   "
        | (AMOMIN, DOUBLE) => "amomin.d  "
        | (AMOMAX, DOUBLE) => "amomax.d  "
        | (AMOMINU, DOUBLE) => "amominu.d "
        | (AMOMAXU, DOUBLE) => "amomaxu.d "
        | (_, _) => "amo.bad "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | CSR (csr,rs1,rd,is_imm,op) =>
      let (insn : string) =
        ((case (op, is_imm) of
          (CSRRW, T) => "csrrwi "
        | (CSRRW, F) => "csrrw  "
        | (CSRRS, T) => "csrrsi "
        | (CSRRS, F) => "csrrs  "
        | (CSRRC, T) => "csrrci "
        | (CSRRC, F) => "csrrc  "
        )) in
      let (rs1_str : string) = (if is_imm then string_of_vec rs1 else reg_name_abi rs1) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", " ((STRCAT rs1_str ((STRCAT ", " ((csr_name csr))))))))))
   | NOP (g__99) => "nop"
   | ILLEGAL (g__100) => "illegal"
   | C_ADDI4SPN (rdc,nzimm) =>
      STRCAT "c.addi4spn "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rdc  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec nzimm))))))
   | C_LW (uimm,rsc,rdc) =>
      STRCAT "c.lw   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rdc  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_LD (uimm,rsc,rdc) =>
      STRCAT "c.ld   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rdc  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_SW (uimm,rsc1,rsc2) =>
      STRCAT "c.sw   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsc1  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc2  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_SD (uimm,rsc1,rsc2) =>
      STRCAT "c.sd   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsc1  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc2  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_ADDI (nzi,rsd) =>
      STRCAT "c.addi   "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((string_of_vec nzi))))))
   | C_JAL (imm) => STRCAT "c.jal   " ((string_of_vec imm))
   | C_ADDIW (imm,rsd) =>
      STRCAT "c.addiw "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((string_of_vec imm))))))
   | C_LI (imm,rd) =>
      STRCAT "c.li  "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
   | C_ADDI16SP (imm) => STRCAT "c.addi16sp  " ((string_of_vec imm))
   | C_LUI (imm,rd) =>
      STRCAT "c.lui  "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
   | C_SRLI (shamt,rsd) =>
      STRCAT "c.srli  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec shamt))))))
   | C_SRAI (shamt,rsd) =>
      STRCAT "c.srai  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec shamt))))))
   | C_ANDI (imm,rsd) =>
      STRCAT "c.andi  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec imm))))))
   | C_SUB (rsd,rs2) =>
      STRCAT "c.sub  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_XOR (rsd,rs2) =>
      STRCAT "c.xor  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_OR (rsd,rs2) =>
      STRCAT "c.or   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_AND (rsd,rs2) =>
      STRCAT "c.and  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_SUBW (rsd,rs2) =>
      STRCAT "c.subw "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_ADDW (rsd,rs2) =>
      STRCAT "c.addw "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_J (imm) => STRCAT "c.j    " ((string_of_vec imm))
   | C_BEQZ (imm,rs) =>
      STRCAT "c.beqz "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rs  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec imm))))))
   | C_BNEZ (imm,rs) =>
      STRCAT "c.bnez "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rs  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec imm))))))
   | C_SLLI (shamt,rsd) =>
      STRCAT "c.slli "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((string_of_vec shamt))))))
   | C_LWSP (uimm,rd) =>
      STRCAT "c.lwsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_LDSP (uimm,rd) =>
      STRCAT "c.ldsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_SWSP (uimm,rd) =>
      STRCAT "c.swsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_SDSP (uimm,rd) =>
      STRCAT "c.sdsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_JR (rs1) => STRCAT "c.jr  " ((reg_name_abi rs1))
   | C_JALR (rs1) => STRCAT "c.jalr  " ((reg_name_abi rs1))
   | C_MV (rd,rs2) =>
      STRCAT "c.mv  "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((reg_name_abi rs2))))))
   | C_ADD (rsd,rs2) =>
      STRCAT "c.add  "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((reg_name_abi rs2))))))
   )))`;


(*val isRVC : mword ty16 -> bool*)

val _ = Define `
 ((isRVC:(16)words$word -> bool) h=
    (~ (((((subrange_vec_dec h (( 1 : int):ii) (( 0 : int):ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word))))))`;


(*val fetch : unit -> M FetchResult*)

val _ = Define `
 ((fetch:unit ->(regstate)state_monad$sequential_state ->(((FetchResult),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state$or_boolS
     ( state_monad$bindS(state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__0 : xlenbits) . 
      state_monad$returnS (((((cast_unit_vec0 ((access_vec_dec w__0 (( 0 : int):ii)))  :  1 words$word)) <> (vec_of_bits [B0]  :  1 words$word))))))
     (state$and_boolS
        ( state_monad$bindS(state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__1 : xlenbits) . 
         state_monad$returnS (((((cast_unit_vec0 ((access_vec_dec w__1 (( 1 : int):ii)))  :  1 words$word)) <> (vec_of_bits [B0]  :  1 words$word))))))
        ( state_monad$bindS(haveRVC () ) (\ (w__2 : bool) .  state_monad$returnS ((~ w__2)))))) (\ (w__4 : bool) . 
   if w__4 then state_monad$bindS
     (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__5 :  64 words$word) . 
     state_monad$returnS (F_Error (E_Fetch_Addr_Align,w__5)))
   else state_monad$bindS
     (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__6 :  64 words$word) .  state_monad$bindS
     (translateAddr w__6 Execute Instruction) (\ (w__7 : TR_Result) . 
     (case w__7 of
       TR_Failure (e) => state_monad$bindS
        (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__8 :  64 words$word) .  state_monad$returnS (F_Error (e,w__8)))
     | TR_Address (ppclo) => state_monad$bindS
        (checked_mem_read Instruction ppclo (( 2 : int):ii)  : ( ( 16 words$word)MemoryOpResult) M) (\ (w__9 : ( 16 words$word)
          MemoryOpResult) . 
        (case w__9 of
          MemException (e) => state_monad$bindS
           (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__10 :  64 words$word) . 
           state_monad$returnS (F_Error (E_Fetch_Access_Fault,w__10)))
        | MemValue (ilo) =>
           if ((isRVC ilo)) then state_monad$returnS (F_RVC ilo)
           else state_monad$bindS
             (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__11 :  64 words$word) . 
             let (PChi : xlenbits) = ((add_vec_int w__11 (( 2 : int):ii)  :  64 words$word)) in state_monad$bindS
             (translateAddr PChi Execute Instruction) (\ (w__12 : TR_Result) . 
             (case w__12 of
               TR_Failure (e) => state_monad$returnS (F_Error (e,PChi))
             | TR_Address (ppchi) => state_monad$bindS
                (checked_mem_read Instruction ppchi (( 2 : int):ii)  : ( ( 16 words$word)MemoryOpResult) M) (\ (w__13 : ( 16 words$word)
                  MemoryOpResult) . 
                state_monad$returnS ((case w__13 of
                  MemException (e) => F_Error (E_Fetch_Access_Fault,PChi)
                | MemValue (ihi) => F_Base ((concat_vec ihi ilo  :  32 words$word))
                )))
             )))
        ))
     ))))))`;


(*val step : unit -> M bool*)

val _ = Define `
 ((step:unit ->(regstate)state_monad$sequential_state ->(((bool),(exception))state_monad$result#(regstate)state_monad$sequential_state)set) () =  (state_monad$bindS
   (state_monad$read_regS mip_ref) (\ (w__0 : Minterrupts) .  state_monad$bindS
   (state_monad$read_regS mie_ref) (\ (w__1 : Minterrupts) .  state_monad$bindS
   (state_monad$read_regS mideleg_ref) (\ (w__2 : Minterrupts) .  state_monad$bindS
   (curInterrupt w__0 w__1 w__2) (\ (w__3 :  ((InterruptType # Privilege))option) . 
   (case w__3 of
     SOME (intr,priv) =>
      let (_ : unit) = (print_bits "Handling interrupt: " ((interruptType_to_bits intr  :  4 words$word))) in state_monad$seqS
      (handle_interrupt intr priv) (state_monad$returnS F)
   | NONE => state_monad$bindS
      (fetch () ) (\ (w__4 : FetchResult) . 
      (case w__4 of
        F_Error (e,addr) => state_monad$seqS (handle_mem_exception addr e) (state_monad$returnS F)
      | F_RVC (h) =>
         (case ((decodeCompressed h)) of
           NONE => state_monad$bindS
            (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__5 : xlenbits) . 
            let (_ : unit) =
              (prerr_endline
                ((STRCAT "PC: "
                    ((STRCAT ((string_of_vec w__5))
                        ((STRCAT " instr: "
                            ((STRCAT ((string_of_vec h)) " :  <no-decode>"))))))))) in state_monad$seqS
            (handle_decode_exception ((EXTZ (( 64 : int):ii) h  :  64 words$word))) (state_monad$returnS F))
         | SOME (ast) => state_monad$bindS
            (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__6 : xlenbits) . 
            let (_ : unit) =
              (prerr_endline
                ((STRCAT "PC: "
                    ((STRCAT ((string_of_vec w__6))
                        ((STRCAT " instr: "
                            ((STRCAT ((string_of_vec h))
                                ((STRCAT " :  " ((print_insn ast))))))))))))) in state_monad$bindS
            (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__7 :  64 words$word) .  state_monad$seqS (state_monad$seqS
            (state_monad$write_regS nextPC_ref ((add_vec_int w__7 (( 2 : int):ii)  :  64 words$word)))
            (execute ast)) (state_monad$returnS T)))
         )
      | F_Base (w) =>
         (case ((decode w)) of
           NONE => state_monad$bindS
            (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__9 : xlenbits) . 
            let (_ : unit) =
              (prerr_endline
                ((STRCAT "PC: "
                    ((STRCAT ((string_of_vec w__9))
                        ((STRCAT " instr: "
                            ((STRCAT ((string_of_vec w)) " :  <no-decode>"))))))))) in state_monad$seqS
            (handle_decode_exception ((EXTZ (( 64 : int):ii) w  :  64 words$word))) (state_monad$returnS F))
         | SOME (ast) => state_monad$bindS
            (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__10 : xlenbits) . 
            let (_ : unit) =
              (prerr_endline
                ((STRCAT "PC: "
                    ((STRCAT ((string_of_vec w__10))
                        ((STRCAT " instr: "
                            ((STRCAT ((string_of_vec w))
                                ((STRCAT " :  " ((print_insn ast))))))))))))) in state_monad$bindS
            (state_monad$read_regS PC_ref  : ( 64 words$word) M) (\ (w__11 :  64 words$word) .  state_monad$seqS (state_monad$seqS
            (state_monad$write_regS nextPC_ref ((add_vec_int w__11 (( 4 : int):ii)  :  64 words$word)))
            (execute ast)) (state_monad$returnS T)))
         )
      ))
   )))))))`;


val _ = Define `
((initial_regstate:regstate)=
   (<| tlb39 := NONE; 
     tselect :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     stval :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     scause :=
       (Mk_Mcause (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                    :  64 words$word)); 
     sepc :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     sscratch :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     stvec :=
       (Mk_Mtvec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                   :  64 words$word)); 
     satp :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     sideleg :=
       (Mk_Sinterrupts (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0]
                         :  64 words$word)); 
     sedeleg :=
       (Mk_Sedeleg (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                     :  64 words$word)); 
     pmpcfg0 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     pmpaddr0 :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mhartid :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     marchid :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mimpid :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mvendorid :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     minstret :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mtime :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mcycle :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mscratch :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mtval :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mepc :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     mcause :=
       (Mk_Mcause (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                    :  64 words$word)); 
     mtvec :=
       (Mk_Mtvec (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                               B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                   :  64 words$word)); 
     medeleg :=
       (Mk_Medeleg (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                     :  64 words$word)); 
     mideleg :=
       (Mk_Minterrupts (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0]
                         :  64 words$word)); 
     mie :=
       (Mk_Minterrupts (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0]
                         :  64 words$word)); 
     mip :=
       (Mk_Minterrupts (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                     B0]
                         :  64 words$word)); 
     mstatus :=
       (Mk_Mstatus (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                                 B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                     :  64 words$word)); 
     misa :=
       (Mk_Misa (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                              B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
                  :  64 words$word)); 
     cur_inst :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     cur_privilege := User; 
     Xs :=
       ([(vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word);
         (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                       B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
           :  64 words$word)]); 
     nextPC :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)); 
     PC :=
       ((vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                     B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]
         :  64 words$word)) |>))`;



val _ = export_theory()

