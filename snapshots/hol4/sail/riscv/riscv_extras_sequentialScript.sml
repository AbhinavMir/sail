(*Generated by Lem from riscv_extras_sequential.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasivesTheory lem_pervasives_extraTheory sail_instr_kindsTheory sail_valuesTheory sail_operators_mwordsTheory state_monadTheory stateTheory;

val _ = numLib.prefer_num();



val _ = new_theory "riscv_extras_sequential"

(*open import Pervasives*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators_mwords*)
(*open import State_monad*)
(*open import State*)

val _ = type_abbrev((*  'a *) "bitvector" , ``:  'a words$word``);

(*val barrierS : forall 'rv 'e. Sail_instr_kinds.barrier_kind -> State_monad.monadS 'rv unit 'e*)
val _ = Define `
 ((barrierS:sail_instr_kinds$barrier_kind -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) _=  (returnS () ))`;


val _ = Define `
 ((MEM_fence_rw_rw:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (barrierS Barrier_RISCV_rw_rw))`;

val _ = Define `
 ((MEM_fence_r_rw:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set)  () =  (barrierS Barrier_RISCV_r_rw))`;

val _ = Define `
 ((MEM_fence_r_r:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set)   () =  (barrierS Barrier_RISCV_r_r))`;

val _ = Define `
 ((MEM_fence_rw_w:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set)  () =  (barrierS Barrier_RISCV_rw_w))`;

val _ = Define `
 ((MEM_fence_w_w:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set)   () =  (barrierS Barrier_RISCV_w_w))`;

val _ = Define `
 ((MEM_fence_i:unit -> 'b state_monad$sequential_state ->(((unit),'a)state_monad$result#'b state_monad$sequential_state)set)     () =  (barrierS Barrier_RISCV_i))`;


(*val MEMea                            : forall 'rv 'a 'e. Size 'a => bitvector 'a -> Num.integer -> State_monad.monadS 'rv unit 'e*)
(*val MEMea_release                    : forall 'rv 'a 'e. Size 'a => bitvector 'a -> Num.integer -> State_monad.monadS 'rv unit 'e*)
(*val MEMea_strong_release             : forall 'rv 'a 'e. Size 'a => bitvector 'a -> Num.integer -> State_monad.monadS 'rv unit 'e*)
(*val MEMea_conditional                : forall 'rv 'a 'e. Size 'a => bitvector 'a -> Num.integer -> State_monad.monadS 'rv unit 'e*)
(*val MEMea_conditional_release        : forall 'rv 'a 'e. Size 'a => bitvector 'a -> Num.integer -> State_monad.monadS 'rv unit 'e*)
(*val MEMea_conditional_strong_release : forall 'rv 'a 'e. Size 'a => bitvector 'a -> Num.integer -> State_monad.monadS 'rv unit 'e*)

val _ = Define `
 ((MEMea:'a words$word -> int -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addr size1=                       (write_mem_eaS 
  instance_Sail_values_Bitvector_Machine_word_mword_dict Write_plain addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_release:'a words$word -> int -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addr size1=               (write_mem_eaS 
  instance_Sail_values_Bitvector_Machine_word_mword_dict Write_RISCV_release addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_strong_release:'a words$word -> int -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addr size1=        (write_mem_eaS 
  instance_Sail_values_Bitvector_Machine_word_mword_dict Write_RISCV_strong_release addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_conditional:'a words$word -> int -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addr size1=           (write_mem_eaS 
  instance_Sail_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_conditional_release:'a words$word -> int -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addr size1=   (write_mem_eaS 
  instance_Sail_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional_release addr (nat_of_int size1)))`;

val _ = Define `
 ((MEMea_conditional_strong_release:'a words$word -> int -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addr size1=                                           
(write_mem_eaS instance_Sail_values_Bitvector_Machine_word_mword_dict Write_RISCV_conditional_strong_release addr (nat_of_int size1)))`;


(*val write_ram : forall 'rv 'a 'b 'e. Size 'a, Size 'b =>
  Num.integer -> Num.integer -> bitvector 'a -> bitvector 'a -> bitvector 'b -> State_monad.monadS 'rv unit 'e*)
val _ = Define `
 ((write_ram:int -> int -> 'a words$word -> 'a words$word -> 'b words$word -> 'rv state_monad$sequential_state ->(((unit),'e)state_monad$result#'rv state_monad$sequential_state)set) addrsize size1 hexRAM address value=  (bindS (seqS  
(write_mem_eaS instance_Sail_values_Bitvector_Machine_word_mword_dict Write_plain address (nat_of_int size1))  
(write_mem_valS instance_Sail_values_Bitvector_Machine_word_mword_dict value)) (\b .  (case (b ) of ( _ ) => returnS ()  ))))`;


(*val read_ram : forall 'rv 'a 'b 'e. Size 'a, Size 'b =>
  Num.integer -> Num.integer -> bitvector 'a -> bitvector 'a -> State_monad.monadS 'rv (bitvector 'b) 'e*)
val _ = Define `
 ((read_ram:int -> int -> 'a words$word -> 'a words$word -> 'rv state_monad$sequential_state ->((('b words$word),'e)state_monad$result#'rv state_monad$sequential_state)set) addrsize size1 hexRAM address=  
 (read_memS instance_Sail_values_Bitvector_Machine_word_mword_dict instance_Sail_values_Bitvector_Machine_word_mword_dict Read_plain address size1))`;


val _ = Define `
 ((speculate_conditional_success:unit -> 'b state_monad$sequential_state ->(((bool),'a)state_monad$result#'b state_monad$sequential_state)set) () =  (excl_resultS () ))`;


(*val get_slice_int : forall 'a. Size 'a => Num.integer -> Num.integer -> Num.integer -> bitvector 'a*)
val _ = Define `
 ((get_slice_int:int -> int -> int -> 'a words$word) len n lo=  
( 
  (* TODO: Is this the intended behaviour? *)let hi = ((lo + len) -( 1 : int)) in
  let bits = (bits_of_int (hi +( 1 : int)) n) in
  of_bits_failwith instance_Sail_values_Bitvector_Machine_word_mword_dict (subrange_list F bits hi lo)))`;


(*val shift_bits_right : forall 'a 'b. Size 'a, Size 'b => bitvector 'a -> bitvector 'b -> bitvector 'a*)
val _ = Define `
 ((shift_bits_right:'a words$word -> 'b words$word -> 'a words$word) v m=  (shiftr v (lem$w2ui m)))`;

(*val shift_bits_left : forall 'a 'b. Size 'a, Size 'b => bitvector 'a -> bitvector 'b -> bitvector 'a*)
val _ = Define `
 ((shift_bits_left:'a words$word -> 'b words$word -> 'a words$word) v m=  (shiftl v (lem$w2ui m)))`;


(*val print_string : string -> string -> unit*)
val _ = Define `
 ((print_string:string -> string -> unit) msg s=  (prerr_endline ( STRCAT msg s)))`;


(*val print_bits : forall 'a. Size 'a => string -> bitvector 'a -> unit*)
val _ = Define `
 ((print_bits:string -> 'a words$word -> unit) msg bs=  (prerr_endline ( STRCAT msg (show_bitlist (MAP bitU_of_bool (bitstring$w2v bs))))))`;


val _ = Define `
 ((reg_deref0:('d,'c,'b)sail_values$register_ref ->('d,'b,'a)state_monad$monadS)=  read_regS)`;
val _ = export_theory()

