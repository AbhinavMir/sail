(*Generated by Lem from riscv_sequential.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory sail_instr_kindsTheory sail_valuesTheory sail_operators_mwordsTheory state_monadTheory stateTheory riscv_sequential_typesTheory riscv_extras_sequentialTheory;

val _ = numLib.prefer_num();



val _ = new_theory "riscv_sequential"

(*Generated by Sail from riscv_sequential.*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators_mwords*)
(*open import State_monad*)
(*open import State*)
(*open import Riscv_sequential_types*)
(*open import Riscv_extras_sequential*)









(*val builtin_and_vec : forall 'n. Riscv_sequential_types.bits 'n -> Riscv_sequential_types.bits 'n -> Riscv_sequential_types.bits 'n*)



(*val builtin_or_vec : forall 'n. Riscv_sequential_types.bits 'n -> Riscv_sequential_types.bits 'n -> Riscv_sequential_types.bits 'n*)



(*val __raw_SetSlice_int : forall 'w. Num.integer -> Sail_values.ii -> Sail_values.ii -> Riscv_sequential_types.bits 'w -> Sail_values.ii*)

(*val __GetSlice_int : forall 'n. Size 'n => Num.integer -> Sail_values.ii -> Sail_values.ii -> Machine_word.mword 'n*)

val _ = Define `
 ((GetSlice_int:int -> int -> int -> 'n words$word) n m o1=  ((get_slice_int n m o1  :  'n words$word)))`;


(*val __raw_SetSlice_bits : forall 'n 'w. Num.integer -> Num.integer -> Riscv_sequential_types.bits 'n -> Sail_values.ii -> Riscv_sequential_types.bits 'w -> Riscv_sequential_types.bits 'n*)

(*val __raw_GetSlice_bits : forall 'n 'w. Num.integer -> Num.integer -> Riscv_sequential_types.bits 'n -> Sail_values.ii -> Riscv_sequential_types.bits 'w*)

(*val cast_unit_vec : Sail_values.bitU -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((cast_unit_vec0:sail_values$bitU ->(1)words$word) b=   
 ((case b of   B0 => (vec_of_bits [B0]  :  1 words$word) | B1 => (vec_of_bits [B1]  :  1 words$word) )))`;


(*val DecStr : Sail_values.ii -> string*)

(*val HexStr : Sail_values.ii -> string*)

(*val __RISCV_write : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((RISCV_write:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (seqS   
(write_ram (( 64 : int):sail_values$ii) width
     (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                   B0]
       :  64 words$word) addr data)   
(returnS T)))`;


(*val __TraceMemoryWrite : forall 'int8_times_n 'm. Num.integer -> Riscv_sequential_types.bits 'm -> Riscv_sequential_types.bits 'int8_times_n -> unit*)

(*val __RISCV_read : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Maybe.maybe (Machine_word.mword 'int8_times_n))*)

val _ = Define `
 ((RISCV_read:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)option),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=  (bindS
   (read_ram (( 64 : int):sail_values$ii) width
      (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                    B0]
        :  64 words$word) addr
     : ( 'int8_times_n words$word) riscv_sequential_types$M) (\ (w__0 :  'int8_times_n words$word) . 
   returnS (SOME w__0))))`;


(*val __TraceMemoryRead : forall 'int8_times_n 'm. Num.integer -> Riscv_sequential_types.bits 'm -> Riscv_sequential_types.bits 'int8_times_n -> unit*)

(*val ex_nat : Sail_values.ii -> Num.integer*)

val _ = Define `
 ((ex_nat:int -> int) n=  n)`;


(*val ex_int : Sail_values.ii -> Num.integer*)

val _ = Define `
 ((ex_int:int -> int) n=  n)`;


(*val coerce_int_nat : Sail_values.ii -> Riscv_sequential_types.M Sail_values.ii*)

val _ = Define `
 ((coerce_int_nat:int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((int),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) x=  (seqS (assert_expS T "") (returnS x)))`;


(*val EXTS : forall 'n 'm . Size 'm, Size 'n => Num.integer -> Machine_word.mword 'n -> Machine_word.mword 'm*)

(*val EXTZ : forall 'n 'm . Size 'm, Size 'n => Num.integer -> Machine_word.mword 'n -> Machine_word.mword 'm*)

val _ = Define `
 ((EXTS:int -> 'n words$word -> 'm words$word) (m__tv : int) v=  ((sign_extend v m__tv  :  'm words$word)))`;


val _ = Define `
 ((EXTZ:int -> 'n words$word -> 'm words$word) (m__tv : int) v=  ((zero_extend v m__tv  :  'm words$word)))`;












(*val bool_to_bits : bool -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((bool_to_bits:bool ->(1)words$word) x=  (if x then (vec_of_bits [B1]  :  1 words$word) else (vec_of_bits [B0]  :  1 words$word)))`;


(*val bit_to_bool : Sail_values.bitU -> bool*)

val _ = Define `
 ((bit_to_bool:sail_values$bitU -> bool) b=  ((case b of   B1 => T | B0 => F )))`;


(*val vector64 : Sail_values.ii -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((vector64:int ->(64)words$word) n=  ((get_slice_int (( 64 : int):sail_values$ii) n (( 0 : int):sail_values$ii)  :  64 words$word)))`;


(*val to_bits : forall 'l. Size 'l => Num.integer -> Sail_values.ii -> Machine_word.mword 'l*)

val _ = Define `
 ((to_bits:int -> int -> 'l words$word) l n=  ((get_slice_int l n (( 0 : int):sail_values$ii)  :  'l words$word)))`;


(*val shift_right_arith64 : Machine_word.mword Machine_word.ty64 -> Machine_word.mword Machine_word.ty6 -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((shift_right_arith64:(64)words$word ->(6)words$word ->(64)words$word) (v : 64 riscv_sequential_types$bits) (shift : 6 riscv_sequential_types$bits)=   
 (let (v128 : 128 riscv_sequential_types$bits) = ((EXTS (( 128 : int):sail_values$ii) v  :  128 words$word)) in
   (subrange_vec_dec ((shift_bits_right v128 shift  :  128 words$word)) (( 63 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  64 words$word)))`;


(*val shift_right_arith32 : Machine_word.mword Machine_word.ty32 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty32*)

val _ = Define `
 ((shift_right_arith32:(32)words$word ->(5)words$word ->(32)words$word) (v : 32 riscv_sequential_types$bits) (shift : 5 riscv_sequential_types$bits)=   
 (let (v64 : 64 riscv_sequential_types$bits) = ((EXTS (( 64 : int):sail_values$ii) v  :  64 words$word)) in
   (subrange_vec_dec ((shift_bits_right v64 shift  :  64 words$word)) (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)))`;


val _ = Define `
 ((xlen:int)=  ((( 64 : int):sail_values$ii)))`;


val _ = Define `
 ((xlen_max_unsigned:int)=  (((pow2 xlen)) - (( 1 : int):sail_values$ii)))`;


val _ = Define `
 ((xlen_max_signed:int)=  (((pow2 ((xlen - (( 1 : int):sail_values$ii))))) - (( 1 : int):sail_values$ii)))`;


val _ = Define `
 ((xlen_min_signed:int)=  ((( 0 : int):sail_values$ii) - ((pow2 ((xlen - (( 1 : int):sail_values$ii)))))))`;


(*val regbits_to_regno : Machine_word.mword Machine_word.ty5 -> Num.integer*)

val _ = Define `
 ((regbits_to_regno:(5)words$word -> int) b=   
 (let r = (lem$w2ui b) in
   r))`;


(*val creg2reg_bits : Machine_word.mword Machine_word.ty3 -> Machine_word.mword Machine_word.ty5*)

val _ = Define `
 ((creg2reg_bits:(3)words$word ->(5)words$word) creg=  ((concat_vec (vec_of_bits [B0;B1]  :  2 words$word) creg  :  5 words$word)))`;


val _ = Define `
((zreg:(5)words$word)=  ((vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))`;


val _ = Define `
((ra:(5)words$word)=  ((vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))`;


val _ = Define `
((sp:(5)words$word)=  ((vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))`;


(*val rX : Num.integer -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((rX:int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((64)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) l__81=   
 (if (((l__81 = (( 0 : int):sail_values$ii)))) then
     returnS (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                           B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                           B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                           B0]
               :  64 words$word)
   else bindS     
(read_regS Xs_ref) (\ (w__0 : riscv_sequential_types$xlenbits list) . 
     returnS ((access_list_dec w__0 l__81  :  64 words$word)))))`;


(*val wX : Num.integer -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((wX:int ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r v=   
 (if (((r <> (( 0 : int):sail_values$ii)))) then bindS     
(read_regS Xs_ref) (\ (w__0 : ( 64 words$word) list) .  seqS     
(write_regS Xs_ref ((update_list_dec w__0 r v  : ( 64 words$word) list)))     
(returnS ((prerr_endline
                 ((STRCAT "x"
                     ((STRCAT ((stringFromInteger r))
                         ((STRCAT " <- " ((string_of_vec v))))))))))))
   else returnS () ))`;


(*val reg_name_abi : Machine_word.mword Machine_word.ty5 -> string*)

val _ = Define `
 ((reg_name_abi:(5)words$word -> string) r=   
 (let b__0 = r in
   if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) then
     "zero"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))))) then
     "ra"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) then
     "sp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word)))))) then
     "gp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  :  5 words$word)))))) then
     "tp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B1]  :  5 words$word)))))) then
     "t0"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B0]  :  5 words$word)))))) then
     "t1"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B1;B1]  :  5 words$word)))))) then
     "t2"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  :  5 words$word)))))) then
     "fp"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B1]  :  5 words$word)))))) then
     "s1"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B0]  :  5 words$word)))))) then
     "a0"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B1;B1]  :  5 words$word)))))) then
     "a1"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))))) then
     "a2"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B1]  :  5 words$word)))))) then
     "a3"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B0]  :  5 words$word)))))) then
     "a4"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B1;B1]  :  5 words$word)))))) then
     "a5"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))) then
     "a6"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B1]  :  5 words$word)))))) then
     "a7"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B0]  :  5 words$word)))))) then
     "s2"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B1;B1]  :  5 words$word)))))) then
     "s3"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))))) then
     "s4"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B1]  :  5 words$word)))))) then
     "s5"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B0]  :  5 words$word)))))) then
     "s6"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B1;B1]  :  5 words$word)))))) then
     "s7"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  :  5 words$word)))))) then
     "s8"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B1]  :  5 words$word)))))) then
     "s9"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B0]  :  5 words$word)))))) then
     "s10"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B1;B1]  :  5 words$word)))))) then
     "s11"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))))) then
     "t3"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B1]  :  5 words$word)))))) then
     "t4"
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B1;B0]  :  5 words$word)))))) then
     "t5"
   else "t6"))`;


(*val Architecture_of_num : Num.integer -> Riscv_sequential_types.Architecture*)

val _ = Define `
 ((Architecture_of_num:int -> riscv_sequential_types$Architecture) arg_=   
 (let l__79 = arg_ in
   if (((l__79 = (( 0 : int):sail_values$ii)))) then RV32
   else if (((l__79 = (( 1 : int):sail_values$ii)))) then RV64
   else RV128))`;


(*val num_of_Architecture : Riscv_sequential_types.Architecture -> Num.integer*)

val _ = Define `
 ((num_of_Architecture:riscv_sequential_types$Architecture -> int) arg_=   
 ((case arg_ of   RV32 => (( 0 : int):sail_values$ii) | RV64 => (( 1 : int):sail_values$ii) | RV128 => (( 2 : int):sail_values$ii) )))`;


(*val architecture : Machine_word.mword Machine_word.ty2 -> Maybe.maybe Riscv_sequential_types.Architecture*)

val _ = Define `
 ((architecture:(2)words$word ->(riscv_sequential_types$Architecture)option) a=   
 (let b__0 = a in
   if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then SOME RV32
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then SOME RV64
   else if (((b__0 = (vec_of_bits [B1;B1]  :  2 words$word)))) then SOME RV128
   else NONE))`;


(*val arch_to_bits : Riscv_sequential_types.Architecture -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((arch_to_bits:riscv_sequential_types$Architecture ->(2)words$word) a=   
 ((case a of
     RV32 => (vec_of_bits [B0;B1]  :  2 words$word)
   | RV64 => (vec_of_bits [B1;B0]  :  2 words$word)
   | RV128 => (vec_of_bits [B1;B1]  :  2 words$word)
   )))`;


(*val Privilege_of_num : Num.integer -> Riscv_sequential_types.Privilege*)

val _ = Define `
 ((Privilege_of_num:int -> riscv_sequential_types$Privilege) arg_=   
 (let l__77 = arg_ in
   if (((l__77 = (( 0 : int):sail_values$ii)))) then User
   else if (((l__77 = (( 1 : int):sail_values$ii)))) then Supervisor
   else Machine))`;


(*val num_of_Privilege : Riscv_sequential_types.Privilege -> Num.integer*)

val _ = Define `
 ((num_of_Privilege:riscv_sequential_types$Privilege -> int) arg_=   
 ((case arg_ of   User => (( 0 : int):sail_values$ii) | Supervisor => (( 1 : int):sail_values$ii) | Machine => (( 2 : int):sail_values$ii) )))`;


(*val privLevel_to_bits : Riscv_sequential_types.Privilege -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((privLevel_to_bits:riscv_sequential_types$Privilege ->(2)words$word) p=   
 ((case p of
     User => (vec_of_bits [B0;B0]  :  2 words$word)
   | Supervisor => (vec_of_bits [B0;B1]  :  2 words$word)
   | Machine => (vec_of_bits [B1;B1]  :  2 words$word)
   )))`;


(*val privLevel_of_bits : Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Privilege*)

val _ = Define `
 ((privLevel_of_bits:(2)words$word -> riscv_sequential_types$Privilege) p=   
 (let b__0 = p in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then User
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then Supervisor
   else Machine))`;


(*val privLevel_to_str : Riscv_sequential_types.Privilege -> string*)

val _ = Define `
 ((privLevel_to_str:riscv_sequential_types$Privilege -> string) p=  ((case p of   User => "U" | Supervisor => "S" | Machine => "M" )))`;


(*val AccessType_of_num : Num.integer -> Riscv_sequential_types.AccessType*)

val _ = Define `
 ((AccessType_of_num:int -> riscv_sequential_types$AccessType) arg_=   
 (let l__74 = arg_ in
   if (((l__74 = (( 0 : int):sail_values$ii)))) then Read
   else if (((l__74 = (( 1 : int):sail_values$ii)))) then Write
   else if (((l__74 = (( 2 : int):sail_values$ii)))) then ReadWrite
   else Execute))`;


(*val num_of_AccessType : Riscv_sequential_types.AccessType -> Num.integer*)

val _ = Define `
 ((num_of_AccessType:riscv_sequential_types$AccessType -> int) arg_=   
 ((case arg_ of   Read => (( 0 : int):sail_values$ii) | Write => (( 1 : int):sail_values$ii) | ReadWrite => (( 2 : int):sail_values$ii) | Execute => (( 3 : int):sail_values$ii) )))`;


(*val ReadType_of_num : Num.integer -> Riscv_sequential_types.ReadType*)

val _ = Define `
 ((ReadType_of_num:int -> riscv_sequential_types$ReadType) arg_=   
 (let l__73 = arg_ in
   if (((l__73 = (( 0 : int):sail_values$ii)))) then Instruction
   else Data))`;


(*val num_of_ReadType : Riscv_sequential_types.ReadType -> Num.integer*)

val _ = Define `
 ((num_of_ReadType:riscv_sequential_types$ReadType -> int) arg_=  ((case arg_ of   Instruction => (( 0 : int):sail_values$ii) | Data => (( 1 : int):sail_values$ii) )))`;


(*val ExceptionType_of_num : Num.integer -> Riscv_sequential_types.ExceptionType*)

val _ = Define `
 ((ExceptionType_of_num:int -> riscv_sequential_types$ExceptionType) arg_=   
 (let l__58 = arg_ in
   if (((l__58 = (( 0 : int):sail_values$ii)))) then E_Fetch_Addr_Align
   else if (((l__58 = (( 1 : int):sail_values$ii)))) then E_Fetch_Access_Fault
   else if (((l__58 = (( 2 : int):sail_values$ii)))) then E_Illegal_Instr
   else if (((l__58 = (( 3 : int):sail_values$ii)))) then E_Breakpoint
   else if (((l__58 = (( 4 : int):sail_values$ii)))) then E_Load_Addr_Align
   else if (((l__58 = (( 5 : int):sail_values$ii)))) then E_Load_Access_Fault
   else if (((l__58 = (( 6 : int):sail_values$ii)))) then E_SAMO_Addr_Align
   else if (((l__58 = (( 7 : int):sail_values$ii)))) then E_SAMO_Access_Fault
   else if (((l__58 = (( 8 : int):sail_values$ii)))) then E_U_EnvCall
   else if (((l__58 = (( 9 : int):sail_values$ii)))) then E_S_EnvCall
   else if (((l__58 = (( 10 : int):sail_values$ii)))) then E_Reserved_10
   else if (((l__58 = (( 11 : int):sail_values$ii)))) then E_M_EnvCall
   else if (((l__58 = (( 12 : int):sail_values$ii)))) then E_Fetch_Page_Fault
   else if (((l__58 = (( 13 : int):sail_values$ii)))) then E_Load_Page_Fault
   else if (((l__58 = (( 14 : int):sail_values$ii)))) then E_Reserved_14
   else E_SAMO_Page_Fault))`;


(*val num_of_ExceptionType : Riscv_sequential_types.ExceptionType -> Num.integer*)

val _ = Define `
 ((num_of_ExceptionType:riscv_sequential_types$ExceptionType -> int) arg_=   
 ((case arg_ of
     E_Fetch_Addr_Align => (( 0 : int):sail_values$ii)
   | E_Fetch_Access_Fault => (( 1 : int):sail_values$ii)
   | E_Illegal_Instr => (( 2 : int):sail_values$ii)
   | E_Breakpoint => (( 3 : int):sail_values$ii)
   | E_Load_Addr_Align => (( 4 : int):sail_values$ii)
   | E_Load_Access_Fault => (( 5 : int):sail_values$ii)
   | E_SAMO_Addr_Align => (( 6 : int):sail_values$ii)
   | E_SAMO_Access_Fault => (( 7 : int):sail_values$ii)
   | E_U_EnvCall => (( 8 : int):sail_values$ii)
   | E_S_EnvCall => (( 9 : int):sail_values$ii)
   | E_Reserved_10 => (( 10 : int):sail_values$ii)
   | E_M_EnvCall => (( 11 : int):sail_values$ii)
   | E_Fetch_Page_Fault => (( 12 : int):sail_values$ii)
   | E_Load_Page_Fault => (( 13 : int):sail_values$ii)
   | E_Reserved_14 => (( 14 : int):sail_values$ii)
   | E_SAMO_Page_Fault => (( 15 : int):sail_values$ii)
   )))`;


(*val exceptionType_to_bits : Riscv_sequential_types.ExceptionType -> Machine_word.mword Machine_word.ty4*)

val _ = Define `
 ((exceptionType_to_bits:riscv_sequential_types$ExceptionType ->(4)words$word) e=   
 ((case e of
     E_Fetch_Addr_Align => (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
   | E_Fetch_Access_Fault => (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
   | E_Illegal_Instr => (vec_of_bits [B0;B0;B1;B0]  :  4 words$word)
   | E_Breakpoint => (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
   | E_Load_Addr_Align => (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)
   | E_Load_Access_Fault => (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
   | E_SAMO_Addr_Align => (vec_of_bits [B0;B1;B1;B0]  :  4 words$word)
   | E_SAMO_Access_Fault => (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
   | E_U_EnvCall => (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
   | E_S_EnvCall => (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)
   | E_Reserved_10 => (vec_of_bits [B1;B0;B1;B0]  :  4 words$word)
   | E_M_EnvCall => (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
   | E_Fetch_Page_Fault => (vec_of_bits [B1;B1;B0;B0]  :  4 words$word)
   | E_Load_Page_Fault => (vec_of_bits [B1;B1;B0;B1]  :  4 words$word)
   | E_Reserved_14 => (vec_of_bits [B1;B1;B1;B0]  :  4 words$word)
   | E_SAMO_Page_Fault => (vec_of_bits [B1;B1;B1;B1]  :  4 words$word)
   )))`;


(*val exceptionType_to_str : Riscv_sequential_types.ExceptionType -> string*)

val _ = Define `
 ((exceptionType_to_str:riscv_sequential_types$ExceptionType -> string) e=   
 ((case e of
     E_Fetch_Addr_Align => "fisaligned-fetch"
   | E_Fetch_Access_Fault => "fetch-access-fault"
   | E_Illegal_Instr => "illegal-instruction"
   | E_Breakpoint => "breakpoint"
   | E_Load_Addr_Align => "misaligned-load"
   | E_Load_Access_Fault => "load-access-fault"
   | E_SAMO_Addr_Align => "misaliged-store/amo"
   | E_SAMO_Access_Fault => "store/amo-access-fault"
   | E_U_EnvCall => "u-call"
   | E_S_EnvCall => "s-call"
   | E_Reserved_10 => "reserved-0"
   | E_M_EnvCall => "m-call"
   | E_Fetch_Page_Fault => "fetch-page-fault"
   | E_Load_Page_Fault => "load-page-fault"
   | E_Reserved_14 => "reserved-1"
   | E_SAMO_Page_Fault => "store/amo-page-fault"
   )))`;


(*val InterruptType_of_num : Num.integer -> Riscv_sequential_types.InterruptType*)

val _ = Define `
 ((InterruptType_of_num:int -> riscv_sequential_types$InterruptType) arg_=   
 (let l__50 = arg_ in
   if (((l__50 = (( 0 : int):sail_values$ii)))) then I_U_Software
   else if (((l__50 = (( 1 : int):sail_values$ii)))) then I_S_Software
   else if (((l__50 = (( 2 : int):sail_values$ii)))) then I_M_Software
   else if (((l__50 = (( 3 : int):sail_values$ii)))) then I_U_Timer
   else if (((l__50 = (( 4 : int):sail_values$ii)))) then I_S_Timer
   else if (((l__50 = (( 5 : int):sail_values$ii)))) then I_M_Timer
   else if (((l__50 = (( 6 : int):sail_values$ii)))) then I_U_External
   else if (((l__50 = (( 7 : int):sail_values$ii)))) then I_S_External
   else I_M_External))`;


(*val num_of_InterruptType : Riscv_sequential_types.InterruptType -> Num.integer*)

val _ = Define `
 ((num_of_InterruptType:riscv_sequential_types$InterruptType -> int) arg_=   
 ((case arg_ of
     I_U_Software => (( 0 : int):sail_values$ii)
   | I_S_Software => (( 1 : int):sail_values$ii)
   | I_M_Software => (( 2 : int):sail_values$ii)
   | I_U_Timer => (( 3 : int):sail_values$ii)
   | I_S_Timer => (( 4 : int):sail_values$ii)
   | I_M_Timer => (( 5 : int):sail_values$ii)
   | I_U_External => (( 6 : int):sail_values$ii)
   | I_S_External => (( 7 : int):sail_values$ii)
   | I_M_External => (( 8 : int):sail_values$ii)
   )))`;


(*val interruptType_to_bits : Riscv_sequential_types.InterruptType -> Machine_word.mword Machine_word.ty4*)

val _ = Define `
 ((interruptType_to_bits:riscv_sequential_types$InterruptType ->(4)words$word) i=   
 ((case i of
     I_U_Software => (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)
   | I_S_Software => (vec_of_bits [B0;B0;B0;B1]  :  4 words$word)
   | I_M_Software => (vec_of_bits [B0;B0;B1;B1]  :  4 words$word)
   | I_U_Timer => (vec_of_bits [B0;B1;B0;B0]  :  4 words$word)
   | I_S_Timer => (vec_of_bits [B0;B1;B0;B1]  :  4 words$word)
   | I_M_Timer => (vec_of_bits [B0;B1;B1;B1]  :  4 words$word)
   | I_U_External => (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)
   | I_S_External => (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)
   | I_M_External => (vec_of_bits [B1;B0;B1;B1]  :  4 words$word)
   )))`;


(*val TrapVectorMode_of_num : Num.integer -> Riscv_sequential_types.TrapVectorMode*)

val _ = Define `
 ((TrapVectorMode_of_num:int -> riscv_sequential_types$TrapVectorMode) arg_=   
 (let l__48 = arg_ in
   if (((l__48 = (( 0 : int):sail_values$ii)))) then TV_Direct
   else if (((l__48 = (( 1 : int):sail_values$ii)))) then TV_Vector
   else TV_Reserved))`;


(*val num_of_TrapVectorMode : Riscv_sequential_types.TrapVectorMode -> Num.integer*)

val _ = Define `
 ((num_of_TrapVectorMode:riscv_sequential_types$TrapVectorMode -> int) arg_=   
 ((case arg_ of   TV_Direct => (( 0 : int):sail_values$ii) | TV_Vector => (( 1 : int):sail_values$ii) | TV_Reserved => (( 2 : int):sail_values$ii) )))`;


(*val trapVectorMode_of_bits : Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.TrapVectorMode*)

val _ = Define `
 ((trapVectorMode_of_bits:(2)words$word -> riscv_sequential_types$TrapVectorMode) m=   
 (let b__0 = m in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then TV_Direct
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then TV_Vector
   else TV_Reserved))`;


(*val not_implemented : forall 'a. string -> Riscv_sequential_types.M 'a*)

val _ = Define `
 ((not_implemented:string ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(('a,(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) message=  (throwS (Error_not_implemented message)))`;


(*val internal_error : forall 'a. string -> Riscv_sequential_types.M 'a*)

val _ = Define `
 ((internal_error:string ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(('a,(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) s=  (seqS (assert_expS F s) (throwS (Error_internal_error () ))))`;


(*val ExtStatus_of_num : Num.integer -> Riscv_sequential_types.ExtStatus*)

val _ = Define `
 ((ExtStatus_of_num:int -> riscv_sequential_types$ExtStatus) arg_=   
 (let l__45 = arg_ in
   if (((l__45 = (( 0 : int):sail_values$ii)))) then Off
   else if (((l__45 = (( 1 : int):sail_values$ii)))) then Initial
   else if (((l__45 = (( 2 : int):sail_values$ii)))) then Clean
   else Dirty))`;


(*val num_of_ExtStatus : Riscv_sequential_types.ExtStatus -> Num.integer*)

val _ = Define `
 ((num_of_ExtStatus:riscv_sequential_types$ExtStatus -> int) arg_=   
 ((case arg_ of   Off => (( 0 : int):sail_values$ii) | Initial => (( 1 : int):sail_values$ii) | Clean => (( 2 : int):sail_values$ii) | Dirty => (( 3 : int):sail_values$ii) )))`;


(*val extStatus_to_bits : Riscv_sequential_types.ExtStatus -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((extStatus_to_bits:riscv_sequential_types$ExtStatus ->(2)words$word) e=   
 ((case e of
     Off => (vec_of_bits [B0;B0]  :  2 words$word)
   | Initial => (vec_of_bits [B0;B1]  :  2 words$word)
   | Clean => (vec_of_bits [B1;B0]  :  2 words$word)
   | Dirty => (vec_of_bits [B1;B1]  :  2 words$word)
   )))`;


(*val extStatus_of_bits : Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.ExtStatus*)

val _ = Define `
 ((extStatus_of_bits:(2)words$word -> riscv_sequential_types$ExtStatus) e=   
 (let b__0 = e in
   if (((b__0 = (vec_of_bits [B0;B0]  :  2 words$word)))) then Off
   else if (((b__0 = (vec_of_bits [B0;B1]  :  2 words$word)))) then Initial
   else if (((b__0 = (vec_of_bits [B1;B0]  :  2 words$word)))) then Clean
   else Dirty))`;


(*val SATPMode_of_num : Num.integer -> Riscv_sequential_types.SATPMode*)

val _ = Define `
 ((SATPMode_of_num:int -> riscv_sequential_types$SATPMode) arg_=   
 (let l__43 = arg_ in
   if (((l__43 = (( 0 : int):sail_values$ii)))) then Sbare
   else if (((l__43 = (( 1 : int):sail_values$ii)))) then Sv32
   else Sv39))`;


(*val num_of_SATPMode : Riscv_sequential_types.SATPMode -> Num.integer*)

val _ = Define `
 ((num_of_SATPMode:riscv_sequential_types$SATPMode -> int) arg_=  ((case arg_ of   Sbare => (( 0 : int):sail_values$ii) | Sv32 => (( 1 : int):sail_values$ii) | Sv39 => (( 2 : int):sail_values$ii) )))`;


(*val satpMode_of_bits : Riscv_sequential_types.Architecture -> Machine_word.mword Machine_word.ty4 -> Maybe.maybe Riscv_sequential_types.SATPMode*)

val _ = Define `
 ((satpMode_of_bits:riscv_sequential_types$Architecture ->(4)words$word ->(riscv_sequential_types$SATPMode)option) (a : riscv_sequential_types$Architecture) (m : riscv_sequential_types$satp_mode)= 
  ((case (a, m) of   (g__113, b__0) => SOME Sbare )))`;


(*val uop_of_num : Num.integer -> Riscv_sequential_types.uop*)

val _ = Define `
 ((uop_of_num:int -> riscv_sequential_types$uop) arg_=   
 (let l__42 = arg_ in
   if (((l__42 = (( 0 : int):sail_values$ii)))) then RISCV_LUI
   else RISCV_AUIPC))`;


(*val num_of_uop : Riscv_sequential_types.uop -> Num.integer*)

val _ = Define `
 ((num_of_uop:riscv_sequential_types$uop -> int) arg_=  ((case arg_ of   RISCV_LUI => (( 0 : int):sail_values$ii) | RISCV_AUIPC => (( 1 : int):sail_values$ii) )))`;


(*val bop_of_num : Num.integer -> Riscv_sequential_types.bop*)

val _ = Define `
 ((bop_of_num:int -> riscv_sequential_types$bop) arg_=   
 (let l__37 = arg_ in
   if (((l__37 = (( 0 : int):sail_values$ii)))) then RISCV_BEQ
   else if (((l__37 = (( 1 : int):sail_values$ii)))) then RISCV_BNE
   else if (((l__37 = (( 2 : int):sail_values$ii)))) then RISCV_BLT
   else if (((l__37 = (( 3 : int):sail_values$ii)))) then RISCV_BGE
   else if (((l__37 = (( 4 : int):sail_values$ii)))) then RISCV_BLTU
   else RISCV_BGEU))`;


(*val num_of_bop : Riscv_sequential_types.bop -> Num.integer*)

val _ = Define `
 ((num_of_bop:riscv_sequential_types$bop -> int) arg_=   
 ((case arg_ of
     RISCV_BEQ => (( 0 : int):sail_values$ii)
   | RISCV_BNE => (( 1 : int):sail_values$ii)
   | RISCV_BLT => (( 2 : int):sail_values$ii)
   | RISCV_BGE => (( 3 : int):sail_values$ii)
   | RISCV_BLTU => (( 4 : int):sail_values$ii)
   | RISCV_BGEU => (( 5 : int):sail_values$ii)
   )))`;


(*val iop_of_num : Num.integer -> Riscv_sequential_types.iop*)

val _ = Define `
 ((iop_of_num:int -> riscv_sequential_types$iop) arg_=   
 (let l__32 = arg_ in
   if (((l__32 = (( 0 : int):sail_values$ii)))) then RISCV_ADDI
   else if (((l__32 = (( 1 : int):sail_values$ii)))) then RISCV_SLTI
   else if (((l__32 = (( 2 : int):sail_values$ii)))) then RISCV_SLTIU
   else if (((l__32 = (( 3 : int):sail_values$ii)))) then RISCV_XORI
   else if (((l__32 = (( 4 : int):sail_values$ii)))) then RISCV_ORI
   else RISCV_ANDI))`;


(*val num_of_iop : Riscv_sequential_types.iop -> Num.integer*)

val _ = Define `
 ((num_of_iop:riscv_sequential_types$iop -> int) arg_=   
 ((case arg_ of
     RISCV_ADDI => (( 0 : int):sail_values$ii)
   | RISCV_SLTI => (( 1 : int):sail_values$ii)
   | RISCV_SLTIU => (( 2 : int):sail_values$ii)
   | RISCV_XORI => (( 3 : int):sail_values$ii)
   | RISCV_ORI => (( 4 : int):sail_values$ii)
   | RISCV_ANDI => (( 5 : int):sail_values$ii)
   )))`;


(*val sop_of_num : Num.integer -> Riscv_sequential_types.sop*)

val _ = Define `
 ((sop_of_num:int -> riscv_sequential_types$sop) arg_=   
 (let l__30 = arg_ in
   if (((l__30 = (( 0 : int):sail_values$ii)))) then RISCV_SLLI
   else if (((l__30 = (( 1 : int):sail_values$ii)))) then RISCV_SRLI
   else RISCV_SRAI))`;


(*val num_of_sop : Riscv_sequential_types.sop -> Num.integer*)

val _ = Define `
 ((num_of_sop:riscv_sequential_types$sop -> int) arg_=   
 ((case arg_ of   RISCV_SLLI => (( 0 : int):sail_values$ii) | RISCV_SRLI => (( 1 : int):sail_values$ii) | RISCV_SRAI => (( 2 : int):sail_values$ii) )))`;


(*val rop_of_num : Num.integer -> Riscv_sequential_types.rop*)

val _ = Define `
 ((rop_of_num:int -> riscv_sequential_types$rop) arg_=   
 (let l__21 = arg_ in
   if (((l__21 = (( 0 : int):sail_values$ii)))) then RISCV_ADD
   else if (((l__21 = (( 1 : int):sail_values$ii)))) then RISCV_SUB
   else if (((l__21 = (( 2 : int):sail_values$ii)))) then RISCV_SLL
   else if (((l__21 = (( 3 : int):sail_values$ii)))) then RISCV_SLT
   else if (((l__21 = (( 4 : int):sail_values$ii)))) then RISCV_SLTU
   else if (((l__21 = (( 5 : int):sail_values$ii)))) then RISCV_XOR
   else if (((l__21 = (( 6 : int):sail_values$ii)))) then RISCV_SRL
   else if (((l__21 = (( 7 : int):sail_values$ii)))) then RISCV_SRA
   else if (((l__21 = (( 8 : int):sail_values$ii)))) then RISCV_OR
   else RISCV_AND))`;


(*val num_of_rop : Riscv_sequential_types.rop -> Num.integer*)

val _ = Define `
 ((num_of_rop:riscv_sequential_types$rop -> int) arg_=   
 ((case arg_ of
     RISCV_ADD => (( 0 : int):sail_values$ii)
   | RISCV_SUB => (( 1 : int):sail_values$ii)
   | RISCV_SLL => (( 2 : int):sail_values$ii)
   | RISCV_SLT => (( 3 : int):sail_values$ii)
   | RISCV_SLTU => (( 4 : int):sail_values$ii)
   | RISCV_XOR => (( 5 : int):sail_values$ii)
   | RISCV_SRL => (( 6 : int):sail_values$ii)
   | RISCV_SRA => (( 7 : int):sail_values$ii)
   | RISCV_OR => (( 8 : int):sail_values$ii)
   | RISCV_AND => (( 9 : int):sail_values$ii)
   )))`;


(*val ropw_of_num : Num.integer -> Riscv_sequential_types.ropw*)

val _ = Define `
 ((ropw_of_num:int -> riscv_sequential_types$ropw) arg_=   
 (let l__17 = arg_ in
   if (((l__17 = (( 0 : int):sail_values$ii)))) then RISCV_ADDW
   else if (((l__17 = (( 1 : int):sail_values$ii)))) then RISCV_SUBW
   else if (((l__17 = (( 2 : int):sail_values$ii)))) then RISCV_SLLW
   else if (((l__17 = (( 3 : int):sail_values$ii)))) then RISCV_SRLW
   else RISCV_SRAW))`;


(*val num_of_ropw : Riscv_sequential_types.ropw -> Num.integer*)

val _ = Define `
 ((num_of_ropw:riscv_sequential_types$ropw -> int) arg_=   
 ((case arg_ of
     RISCV_ADDW => (( 0 : int):sail_values$ii)
   | RISCV_SUBW => (( 1 : int):sail_values$ii)
   | RISCV_SLLW => (( 2 : int):sail_values$ii)
   | RISCV_SRLW => (( 3 : int):sail_values$ii)
   | RISCV_SRAW => (( 4 : int):sail_values$ii)
   )))`;


(*val amoop_of_num : Num.integer -> Riscv_sequential_types.amoop*)

val _ = Define `
 ((amoop_of_num:int -> riscv_sequential_types$amoop) arg_=   
 (let l__9 = arg_ in
   if (((l__9 = (( 0 : int):sail_values$ii)))) then AMOSWAP
   else if (((l__9 = (( 1 : int):sail_values$ii)))) then AMOADD
   else if (((l__9 = (( 2 : int):sail_values$ii)))) then AMOXOR
   else if (((l__9 = (( 3 : int):sail_values$ii)))) then AMOAND
   else if (((l__9 = (( 4 : int):sail_values$ii)))) then AMOOR
   else if (((l__9 = (( 5 : int):sail_values$ii)))) then AMOMIN
   else if (((l__9 = (( 6 : int):sail_values$ii)))) then AMOMAX
   else if (((l__9 = (( 7 : int):sail_values$ii)))) then AMOMINU
   else AMOMAXU))`;


(*val num_of_amoop : Riscv_sequential_types.amoop -> Num.integer*)

val _ = Define `
 ((num_of_amoop:riscv_sequential_types$amoop -> int) arg_=   
 ((case arg_ of
     AMOSWAP => (( 0 : int):sail_values$ii)
   | AMOADD => (( 1 : int):sail_values$ii)
   | AMOXOR => (( 2 : int):sail_values$ii)
   | AMOAND => (( 3 : int):sail_values$ii)
   | AMOOR => (( 4 : int):sail_values$ii)
   | AMOMIN => (( 5 : int):sail_values$ii)
   | AMOMAX => (( 6 : int):sail_values$ii)
   | AMOMINU => (( 7 : int):sail_values$ii)
   | AMOMAXU => (( 8 : int):sail_values$ii)
   )))`;


(*val csrop_of_num : Num.integer -> Riscv_sequential_types.csrop*)

val _ = Define `
 ((csrop_of_num:int -> riscv_sequential_types$csrop) arg_=   
 (let l__7 = arg_ in
   if (((l__7 = (( 0 : int):sail_values$ii)))) then CSRRW
   else if (((l__7 = (( 1 : int):sail_values$ii)))) then CSRRS
   else CSRRC))`;


(*val num_of_csrop : Riscv_sequential_types.csrop -> Num.integer*)

val _ = Define `
 ((num_of_csrop:riscv_sequential_types$csrop -> int) arg_=  ((case arg_ of   CSRRW => (( 0 : int):sail_values$ii) | CSRRS => (( 1 : int):sail_values$ii) | CSRRC => (( 2 : int):sail_values$ii) )))`;


(*val word_width_of_num : Num.integer -> Riscv_sequential_types.word_width*)

val _ = Define `
 ((word_width_of_num:int -> riscv_sequential_types$word_width) arg_=   
 (let l__4 = arg_ in
   if (((l__4 = (( 0 : int):sail_values$ii)))) then BYTE
   else if (((l__4 = (( 1 : int):sail_values$ii)))) then HALF
   else if (((l__4 = (( 2 : int):sail_values$ii)))) then WORD
   else DOUBLE))`;


(*val num_of_word_width : Riscv_sequential_types.word_width -> Num.integer*)

val _ = Define `
 ((num_of_word_width:riscv_sequential_types$word_width -> int) arg_=   
 ((case arg_ of   BYTE => (( 0 : int):sail_values$ii) | HALF => (( 1 : int):sail_values$ii) | WORD => (( 2 : int):sail_values$ii) | DOUBLE => (( 3 : int):sail_values$ii) )))`;


(*val is_aligned_addr : Machine_word.mword Machine_word.ty64 -> Num.integer -> bool*)

val _ = Define `
 ((is_aligned_addr:(64)words$word -> int -> bool) (addr : riscv_sequential_types$xlenbits) (width : int)= 
   (((ex_int ((hardware_mod ((lem$w2ui addr)) width)))) = (( 0 : int):sail_values$ii)))`;


(*val checked_mem_read : forall 'int8_times_n. Size 'int8_times_n => Riscv_sequential_types.ReadType -> Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

val _ = Define `
 ((checked_mem_read:riscv_sequential_types$ReadType ->(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (t : riscv_sequential_types$ReadType) (addr : riscv_sequential_types$xlenbits) (width : int)=  (bindS
   (RISCV_read addr width  : ( ( 'int8_times_n words$word)option) riscv_sequential_types$M) (\ (w__0 :
      ( 'int8_times_n words$word)option) . 
   returnS ((case (t, w__0) of
              (Instruction, NONE) => MemException E_Fetch_Access_Fault
            | (Data, NONE) => MemException E_Load_Access_Fault
            | (_, SOME (v)) => MemValue v
            )))))`;


(*val MEMr : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

(*val MEMr_acquire : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

(*val MEMr_strong_acquire : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

(*val MEMr_reserved : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

(*val MEMr_reserved_acquire : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

(*val MEMr_reserved_strong_acquire : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

val _ = Define `
 ((MEMr:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=  ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)))`;


val _ = Define `
 ((MEMr_acquire:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=   
 ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)))`;


val _ = Define `
 ((MEMr_strong_acquire:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=   
 ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)))`;


val _ = Define `
 ((MEMr_reserved:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=   
 ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)))`;


val _ = Define `
 ((MEMr_reserved_acquire:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=   
 ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)))`;


val _ = Define `
 ((MEMr_reserved_strong_acquire:(64)words$word -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width=   
 ((checked_mem_read Data addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)))`;


(*val mem_read : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> bool -> bool -> bool -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n))*)

val _ = Define `
 ((mem_read:(64)words$word -> int -> bool -> bool -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((('int8_times_n words$word)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width aq rl res=   
 (if ((((((aq \/ res))) /\ ((~ ((is_aligned_addr addr width))))))) then
     returnS (MemException E_Load_Addr_Align)
   else
     (case (aq, rl, res) of
       (F, F, F) => (MEMr addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
     | (T, F, F) => (MEMr_acquire addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
     | (F, F, T) =>
        (MEMr_reserved addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
     | (T, F, T) =>
        (MEMr_reserved_acquire addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
     | (F, T, F) => throwS (Error_not_implemented "load.rl")
     | (T, T, F) =>
        (MEMr_strong_acquire addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
     | (F, T, T) => throwS (Error_not_implemented "lr.rl")
     | (T, T, T) =>
        (MEMr_reserved_strong_acquire addr width  : ( ( 'int8_times_n words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
     )))`;


(*val mem_write_ea : Machine_word.mword Machine_word.ty64 -> Num.integer -> bool -> bool -> bool -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

val _ = Define `
 ((mem_write_ea:(64)words$word -> int -> bool -> bool -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width aq rl con=   
 (if ((((((rl \/ con))) /\ ((~ ((is_aligned_addr addr width))))))) then
     returnS (MemException E_SAMO_Addr_Align)
   else
     (case (aq, rl, con) of
       (F, F, F) => seqS (MEMea addr width) (returnS (MemValue () ))
     | (F, T, F) => seqS (MEMea_release addr width) (returnS (MemValue () ))
     | (F, F, T) => seqS (MEMea_conditional addr width) (returnS (MemValue () ))
     | (F, T, T) => seqS (MEMea_conditional_release addr width) (returnS (MemValue () ))
     | (T, F, F) => throwS (Error_not_implemented "store.aq")
     | (T, T, F) => seqS (MEMea_strong_release addr width) (returnS (MemValue () ))
     | (T, F, T) => throwS (Error_not_implemented "sc.aq")
     | (T, T, T) => seqS (MEMea_conditional_strong_release addr width) (returnS (MemValue () ))
     )))`;


(*val checked_mem_write : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

val _ = Define `
 ((checked_mem_write:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (addr : riscv_sequential_types$xlenbits) (width : int) (data : 'int8_times_n riscv_sequential_types$bits)=  (bindS   
(RISCV_write addr width data) (\ (w__0 : bool) . 
   returnS (if w__0 then MemValue () 
            else MemException E_SAMO_Access_Fault))))`;


(*val MEMval : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

(*val MEMval_release : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

(*val MEMval_strong_release : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

(*val MEMval_conditional : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

(*val MEMval_conditional_release : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

(*val MEMval_conditional_strong_release : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

val _ = Define `
 ((MEMval:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_release:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_strong_release:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_conditional:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_conditional_release:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


val _ = Define `
 ((MEMval_conditional_strong_release:(64)words$word -> int -> 'int8_times_n words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width data=  (checked_mem_write addr width data))`;


(*val mem_write_value : forall 'int8_times_n. Size 'int8_times_n => Machine_word.mword Machine_word.ty64 -> Num.integer -> Machine_word.mword 'int8_times_n -> bool -> bool -> bool -> Riscv_sequential_types.M (Riscv_sequential_types.MemoryOpResult unit)*)

val _ = Define `
 ((mem_write_value:(64)words$word -> int -> 'int8_times_n words$word -> bool -> bool -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((unit)riscv_sequential_types$MemoryOpResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) addr width value aq rl con=   
 (if ((((((rl \/ con))) /\ ((~ ((is_aligned_addr addr width))))))) then
     returnS (MemException E_SAMO_Addr_Align)
   else
     (case (aq, rl, con) of
       (F, F, F) => MEMval addr width value
     | (F, T, F) => MEMval_release addr width value
     | (F, F, T) => MEMval_conditional addr width value
     | (F, T, T) => MEMval_conditional_release addr width value
     | (T, F, F) => throwS (Error_not_implemented "store.aq")
     | (T, T, F) => MEMval_strong_release addr width value
     | (T, F, T) => throwS (Error_not_implemented "sc.aq")
     | (T, T, T) => MEMval_conditional_strong_release addr width value
     )))`;


(*val _get_Misa : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Misa:riscv_sequential_types$Misa ->(64)words$word) (Mk_Misa (v))=  v)`;


(*val _set_Misa : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Misa v) in
   write_regS r_ref r)))`;


(*val _get_SV39_PTE : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty64*)

(*val _set_SV39_PTE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_MXL : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Misa_MXL:riscv_sequential_types$Misa ->(2)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 63 : int):sail_values$ii) (( 62 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Misa_MXL : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_MXL:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):sail_values$ii) (( 62 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_MXL : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_MXL:riscv_sequential_types$Misa ->(2)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 63 : int):sail_values$ii) (( 62 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_Z : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_Z:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 25 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_Z : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_Z:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 25 : int):sail_values$ii) (( 25 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_Z : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_Z:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 25 : int):sail_values$ii) (( 25 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_Y : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_Y:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 24 : int):sail_values$ii) (( 24 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_Y : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_Y:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 24 : int):sail_values$ii) (( 24 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_Y : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_Y:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 24 : int):sail_values$ii) (( 24 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_X : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_X:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 23 : int):sail_values$ii) (( 23 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_X : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_X:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 23 : int):sail_values$ii) (( 23 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_X : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_X:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 23 : int):sail_values$ii) (( 23 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_X : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_X : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_X : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_W : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_W:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 22 : int):sail_values$ii) (( 22 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_W : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_W:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 22 : int):sail_values$ii) (( 22 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_W : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_W:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 22 : int):sail_values$ii) (( 22 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_W : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_W : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_W : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_V : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_V:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 21 : int):sail_values$ii) (( 21 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_V : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_V:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 21 : int):sail_values$ii) (( 21 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_V : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_V:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 21 : int):sail_values$ii) (( 21 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_V : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_V : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_V : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_U : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_U:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 20 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_U : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_U:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 20 : int):sail_values$ii) (( 20 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_U : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_U:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 20 : int):sail_values$ii) (( 20 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_U : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_U : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_U : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_T : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_T:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_T : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_T:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_T : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_T:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_S : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_S:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_S : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_S:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_S : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_S:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_R : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_R:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 17 : int):sail_values$ii) (( 17 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_R : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_R:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 17 : int):sail_values$ii) (( 17 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_R : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_R:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 17 : int):sail_values$ii) (( 17 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_R : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_R : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_R : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_Q : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_Q:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 16 : int):sail_values$ii) (( 16 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_Q : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_Q:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 16 : int):sail_values$ii) (( 16 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_Q : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_Q:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 16 : int):sail_values$ii) (( 16 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_P : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_P:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 15 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_P : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_P:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 15 : int):sail_values$ii) (( 15 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_P : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_P:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 15 : int):sail_values$ii) (( 15 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_O : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_O:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 14 : int):sail_values$ii) (( 14 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_O : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_O:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 14 : int):sail_values$ii) (( 14 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_O : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_O:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 14 : int):sail_values$ii) (( 14 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_N : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_N:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 13 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_N : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_N:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 13 : int):sail_values$ii) (( 13 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_N : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_N:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 13 : int):sail_values$ii) (( 13 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_M : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_M:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_M : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_M:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_M : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_M:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_L : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_L:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_L : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_L:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_L : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_L:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_K : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_K:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 10 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_K : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_K:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 10 : int):sail_values$ii) (( 10 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_K : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_K:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 10 : int):sail_values$ii) (( 10 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_J : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_J:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_J : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_J:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_J : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_J:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_I : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_I:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_I : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_I:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_I : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_I:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_H : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_H:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_H : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_H:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_H : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_H:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_G : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_G:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_G : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_G:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_G : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_G:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_G : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_G : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_G : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_F : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_F:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_F : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_F:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_F : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_F:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_E : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_E:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_E : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_E:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_E : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_E:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_D : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_D:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_D : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_D:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_D : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_D:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_D : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_D : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_D : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Misa_C : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_C:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_C : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_C:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_C : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_C:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_B : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_B:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_B : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_B:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_B : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_B:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Misa_A : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Misa_A:riscv_sequential_types$Misa ->(1)words$word) (Mk_Misa (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Misa_A : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Misa_A:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Misa))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   let r = ((get_Misa w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Misa r))))`;


(*val _update_Misa_A : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((update_Misa_A:riscv_sequential_types$Misa ->(1)words$word -> riscv_sequential_types$Misa) (Mk_Misa (v)) x=   
 (Mk_Misa ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_PTE_Bits_A : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.PTE_Bits*)

(*val _get_PTE_Bits_A : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1*)

(*val _set_PTE_Bits_A : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val legalize_misa : Riscv_sequential_types.Misa -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Misa*)

val _ = Define `
 ((legalize_misa:riscv_sequential_types$Misa ->(64)words$word -> riscv_sequential_types$Misa) (m : riscv_sequential_types$Misa) (v : riscv_sequential_types$xlenbits)=  m)`;


(*val _get_Mstatus : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Mstatus:riscv_sequential_types$Mstatus ->(64)words$word) (Mk_Mstatus (v))=  v)`;


(*val _set_Mstatus : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Mstatus v) in
   write_regS r_ref r)))`;


(*val _get_Mstatus_SD : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_SD:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_SD : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_SD:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SD : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_SD:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SD : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_SD : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_SD : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_SXL : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Mstatus_SXL:riscv_sequential_types$Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 35 : int):sail_values$ii) (( 34 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Mstatus_SXL : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_SXL:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 35 : int):sail_values$ii) (( 34 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SXL : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_SXL:riscv_sequential_types$Mstatus ->(2)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 35 : int):sail_values$ii) (( 34 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_UXL : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Mstatus_UXL:riscv_sequential_types$Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 33 : int):sail_values$ii) (( 32 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Mstatus_UXL : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_UXL:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 33 : int):sail_values$ii) (( 32 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_UXL : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_UXL:riscv_sequential_types$Mstatus ->(2)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 33 : int):sail_values$ii) (( 32 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_UXL : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_UXL : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2*)

(*val _set_Sstatus_UXL : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_TSR : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_TSR:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 22 : int):sail_values$ii) (( 22 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_TSR : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_TSR:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 22 : int):sail_values$ii) (( 22 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_TSR : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_TSR:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 22 : int):sail_values$ii) (( 22 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_TW : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_TW:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 21 : int):sail_values$ii) (( 21 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_TW : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_TW:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 21 : int):sail_values$ii) (( 21 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_TW : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_TW:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 21 : int):sail_values$ii) (( 21 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_TVM : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_TVM:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 20 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_TVM : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_TVM:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 20 : int):sail_values$ii) (( 20 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_TVM : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_TVM:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 20 : int):sail_values$ii) (( 20 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_MXR : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_MXR:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_MXR : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_MXR:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MXR : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_MXR:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_MXR : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_MXR : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_MXR : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_SUM : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_SUM:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_SUM : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_SUM:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SUM : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_SUM:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SUM : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_SUM : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_SUM : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_MPRV : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_MPRV:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 17 : int):sail_values$ii) (( 17 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_MPRV : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_MPRV:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 17 : int):sail_values$ii) (( 17 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MPRV : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_MPRV:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 17 : int):sail_values$ii) (( 17 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_XS : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Mstatus_XS:riscv_sequential_types$Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 16 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Mstatus_XS : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_XS:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 16 : int):sail_values$ii) (( 15 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_XS : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_XS:riscv_sequential_types$Mstatus ->(2)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 16 : int):sail_values$ii) (( 15 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_XS : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_XS : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2*)

(*val _set_Sstatus_XS : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_FS : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Mstatus_FS:riscv_sequential_types$Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 14 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Mstatus_FS : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_FS:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 14 : int):sail_values$ii) (( 13 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_FS : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_FS:riscv_sequential_types$Mstatus ->(2)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 14 : int):sail_values$ii) (( 13 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_FS : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_FS : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2*)

(*val _set_Sstatus_FS : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_MPP : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Mstatus_MPP:riscv_sequential_types$Mstatus ->(2)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 12 : int):sail_values$ii) (( 11 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Mstatus_MPP : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_MPP:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 12 : int):sail_values$ii) (( 11 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MPP : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_MPP:riscv_sequential_types$Mstatus ->(2)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 12 : int):sail_values$ii) (( 11 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_SPP : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_SPP:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_SPP : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_SPP:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SPP : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_SPP:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SPP : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_SPP : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_SPP : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_MPIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_MPIE:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_MPIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_MPIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MPIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_MPIE:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_SPIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_SPIE:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_SPIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_SPIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SPIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_SPIE:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SPIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_SPIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_SPIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_UPIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_UPIE:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_UPIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_UPIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_UPIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_UPIE:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_UPIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_UPIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_UPIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_MIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_MIE:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_MIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_MIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_MIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_MIE:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mstatus_SIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_SIE:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_SIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_SIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_SIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_SIE:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_SIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_SIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_SIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Mstatus_UIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mstatus_UIE:riscv_sequential_types$Mstatus ->(1)words$word) (Mk_Mstatus (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mstatus_UIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mstatus_UIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   let r = ((get_Mstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mstatus r))))`;


(*val _update_Mstatus_UIE : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((update_Mstatus_UIE:riscv_sequential_types$Mstatus ->(1)words$word -> riscv_sequential_types$Mstatus) (Mk_Mstatus (v)) x=   
 (Mk_Mstatus ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sstatus_UIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sstatus*)

(*val _get_Sstatus_UIE : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sstatus_UIE : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val legalize_mstatus : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((legalize_mstatus:riscv_sequential_types$Mstatus ->(64)words$word -> riscv_sequential_types$Mstatus) (o1 : riscv_sequential_types$Mstatus) (v : riscv_sequential_types$xlenbits)=   
 (let (m : riscv_sequential_types$Mstatus) = (Mk_Mstatus v) in
   let m = (update_Mstatus_XS m ((extStatus_to_bits Off  :  2 words$word))) in
   let m =     
(update_Mstatus_SD m
       ((bool_to_bits
           ((((((((extStatus_to_bits ((extStatus_of_bits ((get_Mstatus_FS m  :  2 words$word))))
                      :  2 words$word)) = ((extStatus_to_bits Dirty  :  2 words$word))))) \/ (((((extStatus_to_bits ((extStatus_of_bits ((get_Mstatus_XS m  :  2 words$word))))
                      :  2 words$word)) = ((extStatus_to_bits Dirty  :  2 words$word))))))))
          :  1 words$word))) in
   let m = (update_Mstatus_SXL m ((get_Mstatus_SXL o1  :  2 words$word))) in
   let m = (update_Mstatus_UXL m ((get_Mstatus_UXL o1  :  2 words$word))) in
   let m = (update_Mstatus_UPIE m ((bool_to_bits F  :  1 words$word))) in
   update_Mstatus_UIE m ((bool_to_bits F  :  1 words$word))))`;


(*val cur_Architecture : unit -> Riscv_sequential_types.M Riscv_sequential_types.Architecture*)

val _ = Define `
 ((cur_Architecture:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$Architecture),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) .  bindS
   (case w__0 of
     Machine => bindS      
(read_regS misa_ref) (\ (w__1 : riscv_sequential_types$Misa) .  returnS ((get_Misa_MXL w__1  :  2 words$word)))
   | Supervisor => bindS      
(read_regS mstatus_ref) (\ (w__2 : riscv_sequential_types$Mstatus) . 
      returnS ((get_Mstatus_SXL w__2  :  2 words$word)))
   | User => bindS      
(read_regS mstatus_ref) (\ (w__3 : riscv_sequential_types$Mstatus) . 
      returnS ((get_Mstatus_UXL w__3  :  2 words$word)))
   ) (\ (a : riscv_sequential_types$arch_xlen) . 
   (case ((architecture a)) of
     SOME (a) => returnS a
   | NONE => internal_error "Invalid current architecture"
   )))))`;


(*val in32BitMode : unit -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((in32BitMode:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS (cur_Architecture () ) (\ (w__0 : riscv_sequential_types$Architecture) .  returnS (((w__0 = RV32))))))`;


(*val haveAtomics : unit -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((haveAtomics:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS   
(read_regS misa_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   returnS (((((get_Misa_A w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))`;


(*val haveRVC : unit -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((haveRVC:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS   
(read_regS misa_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   returnS (((((get_Misa_C w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))`;


(*val haveMulDiv : unit -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((haveMulDiv:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS   
(read_regS misa_ref) (\ (w__0 : riscv_sequential_types$Misa) . 
   returnS (((((get_Misa_M w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))`;


(*val haveFP : unit -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((haveFP:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS   
(read_regS misa_ref) (\ (w__0 : riscv_sequential_types$Misa) .  bindS   
(read_regS misa_ref) (\ (w__1 : riscv_sequential_types$Misa) . 
   returnS ((((((((get_Misa_F w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ (((((get_Misa_D w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))))))`;


(*val _get_Minterrupts : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Minterrupts:riscv_sequential_types$Minterrupts ->(64)words$word) (Mk_Minterrupts (v))=  v)`;


(*val _set_Minterrupts : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Minterrupts v) in
   write_regS r_ref r)))`;


(*val _get_Minterrupts_MEI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_MEI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_MEI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_MEI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_MEI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_MEI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Minterrupts_SEI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_SEI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_SEI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_SEI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_SEI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_SEI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_SEI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sinterrupts*)

(*val _get_Sinterrupts_SEI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sinterrupts_SEI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Minterrupts_UEI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_UEI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_UEI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_UEI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_UEI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_UEI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_UEI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sinterrupts*)

(*val _get_Sinterrupts_UEI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sinterrupts_UEI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Minterrupts_MTI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_MTI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_MTI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_MTI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_MTI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_MTI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Minterrupts_STI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_STI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_STI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_STI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_STI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_STI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_STI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sinterrupts*)

(*val _get_Sinterrupts_STI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sinterrupts_STI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Minterrupts_UTI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_UTI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_UTI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_UTI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_UTI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_UTI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_UTI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sinterrupts*)

(*val _get_Sinterrupts_UTI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sinterrupts_UTI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Minterrupts_MSI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_MSI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_MSI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_MSI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_MSI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_MSI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Minterrupts_SSI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_SSI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_SSI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_SSI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_SSI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_SSI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_SSI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sinterrupts*)

(*val _get_Sinterrupts_SSI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sinterrupts_SSI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Minterrupts_USI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Minterrupts_USI:riscv_sequential_types$Minterrupts ->(1)words$word) (Mk_Minterrupts (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Minterrupts_USI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Minterrupts_USI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Minterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) . 
   let r = ((get_Minterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Minterrupts r))))`;


(*val _update_Minterrupts_USI : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((update_Minterrupts_USI:riscv_sequential_types$Minterrupts ->(1)words$word -> riscv_sequential_types$Minterrupts) (Mk_Minterrupts (v)) x=   
 (Mk_Minterrupts ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sinterrupts_USI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sinterrupts*)

(*val _get_Sinterrupts_USI : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sinterrupts_USI : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val legalize_mip : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((legalize_mip:riscv_sequential_types$Minterrupts ->(64)words$word -> riscv_sequential_types$Minterrupts) (o1 : riscv_sequential_types$Minterrupts) (v : riscv_sequential_types$xlenbits)=   
 (let v = (Mk_Minterrupts v) in
   let m = (update_Minterrupts_SEI o1 ((get_Minterrupts_SEI v  :  1 words$word))) in
   let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  :  1 words$word))) in
   update_Minterrupts_SSI m ((get_Minterrupts_SSI v  :  1 words$word))))`;


(*val legalize_mie : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((legalize_mie:riscv_sequential_types$Minterrupts ->(64)words$word -> riscv_sequential_types$Minterrupts) (o1 : riscv_sequential_types$Minterrupts) (v : riscv_sequential_types$xlenbits)=   
 (let v = (Mk_Minterrupts v) in
   let m = (update_Minterrupts_MEI o1 ((get_Minterrupts_MEI v  :  1 words$word))) in
   let m = (update_Minterrupts_MTI m ((get_Minterrupts_MTI v  :  1 words$word))) in
   let m = (update_Minterrupts_MSI m ((get_Minterrupts_MSI v  :  1 words$word))) in
   let m = (update_Minterrupts_SEI m ((get_Minterrupts_SEI v  :  1 words$word))) in
   let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  :  1 words$word))) in
   update_Minterrupts_SSI m ((get_Minterrupts_SSI v  :  1 words$word))))`;


(*val legalize_mideleg : Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((legalize_mideleg:riscv_sequential_types$Minterrupts ->(64)words$word -> riscv_sequential_types$Minterrupts) (o1 : riscv_sequential_types$Minterrupts) (v : riscv_sequential_types$xlenbits)=   
 (let m = (Mk_Minterrupts v) in
   let m = (update_Minterrupts_MEI m ((bool_to_bits F  :  1 words$word))) in
   let m = (update_Minterrupts_MTI m ((bool_to_bits F  :  1 words$word))) in
   update_Minterrupts_MSI m ((bool_to_bits F  :  1 words$word))))`;


(*val _get_Medeleg : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Medeleg:riscv_sequential_types$Medeleg ->(64)words$word) (Mk_Medeleg (v))=  v)`;


(*val _set_Medeleg : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Medeleg v) in
   write_regS r_ref r)))`;


(*val _get_Medeleg_SAMO_Page_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_SAMO_Page_Fault:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=   
 ((subrange_vec_dec v (( 15 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_SAMO_Page_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_SAMO_Page_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 15 : int):sail_values$ii) (( 15 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SAMO_Page_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_SAMO_Page_Fault:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 15 : int):sail_values$ii) (( 15 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Medeleg_Load_Page_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Load_Page_Fault:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=   
 ((subrange_vec_dec v (( 13 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Load_Page_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Load_Page_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 13 : int):sail_values$ii) (( 13 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Load_Page_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Load_Page_Fault:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 13 : int):sail_values$ii) (( 13 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Medeleg_Fetch_Page_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Fetch_Page_Fault:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=   
 ((subrange_vec_dec v (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Fetch_Page_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Fetch_Page_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Fetch_Page_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Fetch_Page_Fault:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Medeleg_MEnvCall : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_MEnvCall:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 10 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_MEnvCall : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_MEnvCall:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 10 : int):sail_values$ii) (( 10 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_MEnvCall : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_MEnvCall:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 10 : int):sail_values$ii) (( 10 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Medeleg_SEnvCall : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_SEnvCall:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_SEnvCall : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_SEnvCall:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SEnvCall : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_SEnvCall:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Medeleg_UEnvCall : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_UEnvCall:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_UEnvCall : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_UEnvCall:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_UEnvCall : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_UEnvCall:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_UEnvCall : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_UEnvCall : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_UEnvCall : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_SAMO_Access_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_SAMO_Access_Fault:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=   
 ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_SAMO_Access_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_SAMO_Access_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SAMO_Access_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_SAMO_Access_Fault:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_SAMO_Access_Fault : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_SAMO_Access_Fault : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_SAMO_Access_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_SAMO_Addr_Align : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_SAMO_Addr_Align:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_SAMO_Addr_Align : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_SAMO_Addr_Align:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_SAMO_Addr_Align : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_SAMO_Addr_Align:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_SAMO_Addr_Align : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_SAMO_Addr_Align : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_SAMO_Addr_Align : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_Load_Access_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Load_Access_Fault:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=   
 ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Load_Access_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Load_Access_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Load_Access_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Load_Access_Fault:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Load_Access_Fault : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_Load_Access_Fault : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_Load_Access_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_Load_Addr_Align : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Load_Addr_Align:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Load_Addr_Align : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Load_Addr_Align:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Load_Addr_Align : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Load_Addr_Align:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Load_Addr_Align : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_Load_Addr_Align : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_Load_Addr_Align : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_Breakpoint : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Breakpoint:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Breakpoint : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Breakpoint:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Breakpoint : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Breakpoint:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Breakpoint : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_Breakpoint : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_Breakpoint : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_Illegal_Instr : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Illegal_Instr:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Illegal_Instr : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Illegal_Instr:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Illegal_Instr : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Illegal_Instr:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Illegal_Instr : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_Illegal_Instr : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_Illegal_Instr : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_Fetch_Access_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Fetch_Access_Fault:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=   
 ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Fetch_Access_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Fetch_Access_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Fetch_Access_Fault : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Fetch_Access_Fault:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Fetch_Access_Fault : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_Fetch_Access_Fault : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_Fetch_Access_Fault : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val _get_Medeleg_Fetch_Addr_Align : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Medeleg_Fetch_Addr_Align:riscv_sequential_types$Medeleg ->(1)words$word) (Mk_Medeleg (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Medeleg_Fetch_Addr_Align : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Medeleg_Fetch_Addr_Align:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Medeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let r = ((get_Medeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Medeleg r))))`;


(*val _update_Medeleg_Fetch_Addr_Align : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((update_Medeleg_Fetch_Addr_Align:riscv_sequential_types$Medeleg ->(1)words$word -> riscv_sequential_types$Medeleg) (Mk_Medeleg (v)) x=   
 (Mk_Medeleg ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Sedeleg_Fetch_Addr_Align : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Sedeleg*)

(*val _get_Sedeleg_Fetch_Addr_Align : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1*)

(*val _set_Sedeleg_Fetch_Addr_Align : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

(*val legalize_medeleg : Riscv_sequential_types.Medeleg -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Medeleg*)

val _ = Define `
 ((legalize_medeleg:riscv_sequential_types$Medeleg ->(64)words$word -> riscv_sequential_types$Medeleg) (o1 : riscv_sequential_types$Medeleg) (v : riscv_sequential_types$xlenbits)=   
 (let m = (Mk_Medeleg v) in
   update_Medeleg_MEnvCall m ((bool_to_bits F  :  1 words$word))))`;


(*val _get_Mtvec : Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Mtvec:riscv_sequential_types$Mtvec ->(64)words$word) (Mk_Mtvec (v))=  v)`;


(*val _set_Mtvec : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mtvec:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mtvec))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Mtvec v) in
   write_regS r_ref r)))`;


(*val _get_Mtvec_Base : Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty62*)

val _ = Define `
 ((get_Mtvec_Base:riscv_sequential_types$Mtvec ->(62)words$word) (Mk_Mtvec (v))=  ((subrange_vec_dec v (( 63 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  62 words$word)))`;


(*val _set_Mtvec_Base : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty62 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mtvec_Base:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mtvec))sail_values$register_ref ->(62)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mtvec) . 
   let r = ((get_Mtvec w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):sail_values$ii) (( 2 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mtvec r))))`;


(*val _update_Mtvec_Base : Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty62 -> Riscv_sequential_types.Mtvec*)

val _ = Define `
 ((update_Mtvec_Base:riscv_sequential_types$Mtvec ->(62)words$word -> riscv_sequential_types$Mtvec) (Mk_Mtvec (v)) x=   
 (Mk_Mtvec ((update_subrange_vec_dec v (( 63 : int):sail_values$ii) (( 2 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mtvec_Mode : Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_Mtvec_Mode:riscv_sequential_types$Mtvec ->(2)words$word) (Mk_Mtvec (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_Mtvec_Mode : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mtvec_Mode:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mtvec))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mtvec) . 
   let r = ((get_Mtvec w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mtvec r))))`;


(*val _update_Mtvec_Mode : Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Mtvec*)

val _ = Define `
 ((update_Mtvec_Mode:riscv_sequential_types$Mtvec ->(2)words$word -> riscv_sequential_types$Mtvec) (Mk_Mtvec (v)) x=   
 (Mk_Mtvec ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _update_Satp64_Mode : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty4 -> Riscv_sequential_types.Satp64*)

(*val _get_Satp64_Mode : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty4*)

(*val _set_Satp64_Mode : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty4 -> Riscv_sequential_types.M unit*)

(*val legalize_tvec : Riscv_sequential_types.Mtvec -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Mtvec*)

val _ = Define `
 ((legalize_tvec:riscv_sequential_types$Mtvec ->(64)words$word -> riscv_sequential_types$Mtvec) (o1 : riscv_sequential_types$Mtvec) (v : riscv_sequential_types$xlenbits)=   
 (let v = (Mk_Mtvec v) in
   (case ((trapVectorMode_of_bits ((get_Mtvec_Mode v  :  2 words$word)))) of
     TV_Direct => v
   | TV_Vector => v
   | _ => update_Mtvec_Mode v ((get_Mtvec_Mode o1  :  2 words$word))
   )))`;


(*val _get_Mcause : Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Mcause:riscv_sequential_types$Mcause ->(64)words$word) (Mk_Mcause (v))=  v)`;


(*val _set_Mcause : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mcause:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mcause))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Mcause v) in
   write_regS r_ref r)))`;


(*val _get_Mcause_IsInterrupt : Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty1*)

val _ = Define `
 ((get_Mcause_IsInterrupt:riscv_sequential_types$Mcause ->(1)words$word) (Mk_Mcause (v))=  ((subrange_vec_dec v (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii)  :  1 words$word)))`;


(*val _set_Mcause_IsInterrupt : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mcause_IsInterrupt:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mcause))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mcause) . 
   let r = ((get_Mcause w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mcause r))))`;


(*val _update_Mcause_IsInterrupt : Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty1 -> Riscv_sequential_types.Mcause*)

val _ = Define `
 ((update_Mcause_IsInterrupt:riscv_sequential_types$Mcause ->(1)words$word -> riscv_sequential_types$Mcause) (Mk_Mcause (v)) x=   
 (Mk_Mcause ((update_subrange_vec_dec v (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Mcause_Cause : Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty63*)

val _ = Define `
 ((get_Mcause_Cause:riscv_sequential_types$Mcause ->(63)words$word) (Mk_Mcause (v))=  ((subrange_vec_dec v (( 62 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  63 words$word)))`;


(*val _set_Mcause_Cause : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty63 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Mcause_Cause:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Mcause))sail_values$register_ref ->(63)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Mcause) . 
   let r = ((get_Mcause w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 62 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Mcause r))))`;


(*val _update_Mcause_Cause : Riscv_sequential_types.Mcause -> Machine_word.mword Machine_word.ty63 -> Riscv_sequential_types.Mcause*)

val _ = Define `
 ((update_Mcause_Cause:riscv_sequential_types$Mcause ->(63)words$word -> riscv_sequential_types$Mcause) (Mk_Mcause (v)) x=   
 (Mk_Mcause ((update_subrange_vec_dec v (( 62 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val tvec_addr : Riscv_sequential_types.Mtvec -> Riscv_sequential_types.Mcause -> Maybe.maybe (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((tvec_addr:riscv_sequential_types$Mtvec -> riscv_sequential_types$Mcause ->((64)words$word)option) (m : riscv_sequential_types$Mtvec) (c : riscv_sequential_types$Mcause)=   
 (let (base : riscv_sequential_types$xlenbits) =     
((concat_vec ((get_Mtvec_Base m  :  62 words$word)) (vec_of_bits [B0;B0]  :  2 words$word)
       :  64 words$word)) in
   (case ((trapVectorMode_of_bits ((get_Mtvec_Mode m  :  2 words$word)))) of
     TV_Direct => SOME base
   | TV_Vector =>
      if (((((get_Mcause_IsInterrupt c  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
      then
        SOME ((add_vec base
                 ((shift_bits_left
                     ((EXTZ (( 64 : int):sail_values$ii) ((get_Mcause_Cause c  :  63 words$word))  :  64 words$word))
                     (vec_of_bits [B1;B0]  :  2 words$word)
                    :  64 words$word))
                :  64 words$word))
      else SOME base
   | TV_Reserved => NONE
   )))`;


(*val legalize_xepc : Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((legalize_xepc:(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((64)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) v=  (bindS   
(haveRVC () ) (\ (w__0 : bool) . 
   returnS ((and_vec v
               ((EXTS (( 64 : int):sail_values$ii)
                   (if w__0 then (vec_of_bits [B1;B1;B0]  :  3 words$word)
                    else (vec_of_bits [B1;B0;B0]  :  3 words$word))
                  :  64 words$word))
              :  64 words$word)))))`;


(*val _get_Sstatus : Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Sstatus:riscv_sequential_types$Sstatus ->(64)words$word) (Mk_Sstatus (v))=  v)`;


(*val _set_Sstatus : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sstatus -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Sstatus:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Sstatus v) in
   write_regS r_ref r)))`;


val _ = Define `
 ((get_Sstatus_SD:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SD:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SD:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 63 : int):sail_values$ii) (( 63 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_UXL:riscv_sequential_types$Sstatus ->(2)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 33 : int):sail_values$ii) (( 32 : int):sail_values$ii)  :  2 words$word)))`;


val _ = Define `
 ((set_Sstatus_UXL:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 33 : int):sail_values$ii) (( 32 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_UXL:riscv_sequential_types$Sstatus ->(2)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 33 : int):sail_values$ii) (( 32 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_MXR:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_MXR:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_MXR:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 19 : int):sail_values$ii) (( 19 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SUM:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SUM:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SUM:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 18 : int):sail_values$ii) (( 18 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_XS:riscv_sequential_types$Sstatus ->(2)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 16 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  2 words$word)))`;


val _ = Define `
 ((set_Sstatus_XS:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 16 : int):sail_values$ii) (( 15 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_XS:riscv_sequential_types$Sstatus ->(2)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 16 : int):sail_values$ii) (( 15 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_FS:riscv_sequential_types$Sstatus ->(2)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 14 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  2 words$word)))`;


val _ = Define `
 ((set_Sstatus_FS:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 14 : int):sail_values$ii) (( 13 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_FS:riscv_sequential_types$Sstatus ->(2)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 14 : int):sail_values$ii) (( 13 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SPP:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SPP:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SPP:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SPIE:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SPIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SPIE:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_UPIE:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_UPIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_UPIE:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_SIE:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_SIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_SIE:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sstatus_UIE:riscv_sequential_types$Sstatus ->(1)words$word) (Mk_Sstatus (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sstatus_UIE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sstatus))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sstatus) . 
   let r = ((get_Sstatus w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sstatus r))))`;


val _ = Define `
 ((update_Sstatus_UIE:riscv_sequential_types$Sstatus ->(1)words$word -> riscv_sequential_types$Sstatus) (Mk_Sstatus (v)) x=   
 (Mk_Sstatus ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val lower_mstatus : Riscv_sequential_types.Mstatus -> Riscv_sequential_types.Sstatus*)

val _ = Define `
 ((lower_mstatus:riscv_sequential_types$Mstatus -> riscv_sequential_types$Sstatus) m=   
 (let s = (Mk_Sstatus ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))) in
   let s = (update_Sstatus_SD s ((get_Mstatus_SD m  :  1 words$word))) in
   let s = (update_Sstatus_UXL s ((get_Mstatus_UXL m  :  2 words$word))) in
   let s = (update_Sstatus_MXR s ((get_Mstatus_MXR m  :  1 words$word))) in
   let s = (update_Sstatus_SUM s ((get_Mstatus_SUM m  :  1 words$word))) in
   let s = (update_Sstatus_XS s ((get_Mstatus_XS m  :  2 words$word))) in
   let s = (update_Sstatus_FS s ((get_Mstatus_FS m  :  2 words$word))) in
   let s = (update_Sstatus_SPP s ((get_Mstatus_SPP m  :  1 words$word))) in
   let s = (update_Sstatus_SPIE s ((get_Mstatus_SPIE m  :  1 words$word))) in
   let s = (update_Sstatus_UPIE s ((get_Mstatus_UPIE m  :  1 words$word))) in
   let s = (update_Sstatus_SIE s ((get_Mstatus_SIE m  :  1 words$word))) in
   update_Sstatus_UIE s ((get_Mstatus_UIE m  :  1 words$word))))`;


(*val lift_sstatus : Riscv_sequential_types.Mstatus -> Riscv_sequential_types.Sstatus -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((lift_sstatus:riscv_sequential_types$Mstatus -> riscv_sequential_types$Sstatus -> riscv_sequential_types$Mstatus) (m : riscv_sequential_types$Mstatus) (s : riscv_sequential_types$Sstatus)=   
 (let m = (update_Mstatus_SD m ((get_Sstatus_SD s  :  1 words$word))) in
   let m = (update_Mstatus_UXL m ((get_Sstatus_UXL s  :  2 words$word))) in
   let m = (update_Mstatus_MXR m ((get_Sstatus_MXR s  :  1 words$word))) in
   let m = (update_Mstatus_SUM m ((get_Sstatus_SUM s  :  1 words$word))) in
   let m = (update_Mstatus_XS m ((get_Sstatus_XS s  :  2 words$word))) in
   let m = (update_Mstatus_FS m ((get_Sstatus_FS s  :  2 words$word))) in
   let m = (update_Mstatus_SPP m ((get_Sstatus_SPP s  :  1 words$word))) in
   let m = (update_Mstatus_SPIE m ((get_Sstatus_SPIE s  :  1 words$word))) in
   let m = (update_Mstatus_UPIE m ((get_Sstatus_UPIE s  :  1 words$word))) in
   let m = (update_Mstatus_SIE m ((get_Sstatus_SIE s  :  1 words$word))) in
   update_Mstatus_UIE m ((get_Sstatus_UIE s  :  1 words$word))))`;


(*val legalize_sstatus : Riscv_sequential_types.Mstatus -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Mstatus*)

val _ = Define `
 ((legalize_sstatus:riscv_sequential_types$Mstatus ->(64)words$word -> riscv_sequential_types$Mstatus) (m : riscv_sequential_types$Mstatus) (v : riscv_sequential_types$xlenbits)=  (lift_sstatus m (Mk_Sstatus v)))`;


(*val _get_Sedeleg : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Sedeleg:riscv_sequential_types$Sedeleg ->(64)words$word) (Mk_Sedeleg (v))=  v)`;


(*val _set_Sedeleg : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Sedeleg:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Sedeleg v) in
   write_regS r_ref r)))`;


val _ = Define `
 ((get_Sedeleg_UEnvCall:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_UEnvCall:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_UEnvCall:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_SAMO_Access_Fault:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=   
 ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_SAMO_Access_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_SAMO_Access_Fault:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_SAMO_Addr_Align:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_SAMO_Addr_Align:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_SAMO_Addr_Align:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Load_Access_Fault:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=   
 ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Load_Access_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Load_Access_Fault:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Load_Addr_Align:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Load_Addr_Align:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Load_Addr_Align:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Breakpoint:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Breakpoint:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Breakpoint:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Illegal_Instr:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Illegal_Instr:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Illegal_Instr:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Fetch_Access_Fault:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=   
 ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Fetch_Access_Fault:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Fetch_Access_Fault:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sedeleg_Fetch_Addr_Align:riscv_sequential_types$Sedeleg ->(1)words$word) (Mk_Sedeleg (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sedeleg_Fetch_Addr_Align:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sedeleg))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sedeleg) . 
   let r = ((get_Sedeleg w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sedeleg r))))`;


val _ = Define `
 ((update_Sedeleg_Fetch_Addr_Align:riscv_sequential_types$Sedeleg ->(1)words$word -> riscv_sequential_types$Sedeleg) (Mk_Sedeleg (v)) x=   
 (Mk_Sedeleg ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val legalize_sedeleg : Riscv_sequential_types.Sedeleg -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Sedeleg*)

val _ = Define `
 ((legalize_sedeleg:riscv_sequential_types$Sedeleg ->(64)words$word -> riscv_sequential_types$Sedeleg) (s : riscv_sequential_types$Sedeleg) (v : riscv_sequential_types$xlenbits)=   
 (Mk_Sedeleg ((EXTZ (( 64 : int):sail_values$ii) ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  9 words$word))  :  64 words$word))))`;


(*val _get_Sinterrupts : Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Sinterrupts:riscv_sequential_types$Sinterrupts ->(64)words$word) (Mk_Sinterrupts (v))=  v)`;


(*val _set_Sinterrupts : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Sinterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Sinterrupts:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Sinterrupts v) in
   write_regS r_ref r)))`;


val _ = Define `
 ((get_Sinterrupts_SEI:riscv_sequential_types$Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_SEI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_SEI:riscv_sequential_types$Sinterrupts ->(1)words$word -> riscv_sequential_types$Sinterrupts) (Mk_Sinterrupts (v)) x=   
 (Mk_Sinterrupts ((update_subrange_vec_dec v (( 9 : int):sail_values$ii) (( 9 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_UEI:riscv_sequential_types$Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_UEI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_UEI:riscv_sequential_types$Sinterrupts ->(1)words$word -> riscv_sequential_types$Sinterrupts) (Mk_Sinterrupts (v)) x=   
 (Mk_Sinterrupts ((update_subrange_vec_dec v (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_STI:riscv_sequential_types$Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_STI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_STI:riscv_sequential_types$Sinterrupts ->(1)words$word -> riscv_sequential_types$Sinterrupts) (Mk_Sinterrupts (v)) x=   
 (Mk_Sinterrupts ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_UTI:riscv_sequential_types$Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_UTI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_UTI:riscv_sequential_types$Sinterrupts ->(1)words$word -> riscv_sequential_types$Sinterrupts) (Mk_Sinterrupts (v)) x=   
 (Mk_Sinterrupts ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_SSI:riscv_sequential_types$Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_SSI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_SSI:riscv_sequential_types$Sinterrupts ->(1)words$word -> riscv_sequential_types$Sinterrupts) (Mk_Sinterrupts (v)) x=   
 (Mk_Sinterrupts ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  64 words$word))))`;


val _ = Define `
 ((get_Sinterrupts_USI:riscv_sequential_types$Sinterrupts ->(1)words$word) (Mk_Sinterrupts (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_Sinterrupts_USI:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Sinterrupts))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Sinterrupts) . 
   let r = ((get_Sinterrupts w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Sinterrupts r))))`;


val _ = Define `
 ((update_Sinterrupts_USI:riscv_sequential_types$Sinterrupts ->(1)words$word -> riscv_sequential_types$Sinterrupts) (Mk_Sinterrupts (v)) x=   
 (Mk_Sinterrupts ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val lower_mip : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Sinterrupts*)

val _ = Define `
 ((lower_mip:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts -> riscv_sequential_types$Sinterrupts) (m : riscv_sequential_types$Minterrupts) (d : riscv_sequential_types$Minterrupts)=   
 (let (s : riscv_sequential_types$Sinterrupts) =     
(Mk_Sinterrupts ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))) in
   let s =     
(update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  :  1 words$word)) ((get_Minterrupts_SEI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  :  1 words$word)) ((get_Minterrupts_STI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  :  1 words$word)) ((get_Minterrupts_SSI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  :  1 words$word)) ((get_Minterrupts_UEI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  :  1 words$word)) ((get_Minterrupts_UTI d  :  1 words$word))
          :  1 words$word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  :  1 words$word)) ((get_Minterrupts_USI d  :  1 words$word))
        :  1 words$word))))`;


(*val lower_mie : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Sinterrupts*)

val _ = Define `
 ((lower_mie:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts -> riscv_sequential_types$Sinterrupts) (m : riscv_sequential_types$Minterrupts) (d : riscv_sequential_types$Minterrupts)=   
 (let (s : riscv_sequential_types$Sinterrupts) =     
(Mk_Sinterrupts ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))) in
   let s =     
(update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  :  1 words$word)) ((get_Minterrupts_SEI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  :  1 words$word)) ((get_Minterrupts_STI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  :  1 words$word)) ((get_Minterrupts_SSI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  :  1 words$word)) ((get_Minterrupts_UEI d  :  1 words$word))
          :  1 words$word))) in
   let s =     
(update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  :  1 words$word)) ((get_Minterrupts_UTI d  :  1 words$word))
          :  1 words$word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  :  1 words$word)) ((get_Minterrupts_USI d  :  1 words$word))
        :  1 words$word))))`;


(*val lift_sip : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Sinterrupts -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((lift_sip:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts -> riscv_sequential_types$Sinterrupts -> riscv_sequential_types$Minterrupts) (o1 : riscv_sequential_types$Minterrupts) (d : riscv_sequential_types$Minterrupts) (s : riscv_sequential_types$Sinterrupts)=   
 (let (m : riscv_sequential_types$Minterrupts) = o1 in
   let m =     
(update_Minterrupts_SSI m
       ((and_vec ((get_Sinterrupts_SSI s  :  1 words$word)) ((get_Minterrupts_SSI d  :  1 words$word))
          :  1 words$word))) in
   let m =     
(update_Minterrupts_UEI m
       ((and_vec ((get_Minterrupts_UEI m  :  1 words$word)) ((get_Minterrupts_UEI d  :  1 words$word))
          :  1 words$word))) in
   update_Minterrupts_USI m
     ((and_vec ((get_Minterrupts_USI m  :  1 words$word)) ((get_Minterrupts_USI d  :  1 words$word))
        :  1 words$word))))`;


(*val legalize_sip : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((legalize_sip:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts ->(64)words$word -> riscv_sequential_types$Minterrupts) (m : riscv_sequential_types$Minterrupts) (d : riscv_sequential_types$Minterrupts) (v : riscv_sequential_types$xlenbits)=   
 (lift_sip m d (Mk_Sinterrupts v)))`;


(*val lift_sie : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Sinterrupts -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((lift_sie:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts -> riscv_sequential_types$Sinterrupts -> riscv_sequential_types$Minterrupts) (o1 : riscv_sequential_types$Minterrupts) (d : riscv_sequential_types$Minterrupts) (s : riscv_sequential_types$Sinterrupts)=   
 (let (m : riscv_sequential_types$Minterrupts) = o1 in
   let m =     
(if (((((get_Minterrupts_SEI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_SEI m ((get_Sinterrupts_SEI s  :  1 words$word))
     else m) in
   let m =     
(if (((((get_Minterrupts_STI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_STI m ((get_Sinterrupts_STI s  :  1 words$word))
     else m) in
   let m =     
(if (((((get_Minterrupts_SSI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_SSI m ((get_Sinterrupts_SSI s  :  1 words$word))
     else m) in
   let m =     
(if (((((get_Minterrupts_UEI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  :  1 words$word))
     else m) in
   let m =     
(if (((((get_Minterrupts_UTI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
       update_Minterrupts_UTI m ((get_Sinterrupts_UTI s  :  1 words$word))
     else m) in
   if (((((get_Minterrupts_USI d  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
     update_Minterrupts_USI m ((get_Sinterrupts_USI s  :  1 words$word))
   else m))`;


(*val legalize_sie : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.Minterrupts*)

val _ = Define `
 ((legalize_sie:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts ->(64)words$word -> riscv_sequential_types$Minterrupts) (m : riscv_sequential_types$Minterrupts) (d : riscv_sequential_types$Minterrupts) (v : riscv_sequential_types$xlenbits)=   
 (lift_sie m d (Mk_Sinterrupts v)))`;


(*val _get_Satp64 : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((get_Satp64:riscv_sequential_types$Satp64 ->(64)words$word) (Mk_Satp64 (v))=  v)`;


(*val _set_Satp64 : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Satp64:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Satp64))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_Satp64 v) in
   write_regS r_ref r)))`;


val _ = Define `
 ((get_Satp64_Mode:riscv_sequential_types$Satp64 ->(4)words$word) (Mk_Satp64 (v))=  ((subrange_vec_dec v (( 63 : int):sail_values$ii) (( 60 : int):sail_values$ii)  :  4 words$word)))`;


val _ = Define `
 ((set_Satp64_Mode:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Satp64))sail_values$register_ref ->(4)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Satp64) . 
   let r = ((get_Satp64 w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 63 : int):sail_values$ii) (( 60 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Satp64 r))))`;


val _ = Define `
 ((update_Satp64_Mode:riscv_sequential_types$Satp64 ->(4)words$word -> riscv_sequential_types$Satp64) (Mk_Satp64 (v)) x=   
 (Mk_Satp64 ((update_subrange_vec_dec v (( 63 : int):sail_values$ii) (( 60 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Satp64_Asid : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty16*)

val _ = Define `
 ((get_Satp64_Asid:riscv_sequential_types$Satp64 ->(16)words$word) (Mk_Satp64 (v))=  ((subrange_vec_dec v (( 59 : int):sail_values$ii) (( 44 : int):sail_values$ii)  :  16 words$word)))`;


(*val _set_Satp64_Asid : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty16 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Satp64_Asid:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Satp64))sail_values$register_ref ->(16)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Satp64) . 
   let r = ((get_Satp64 w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 59 : int):sail_values$ii) (( 44 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Satp64 r))))`;


(*val _update_Satp64_Asid : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty16 -> Riscv_sequential_types.Satp64*)

val _ = Define `
 ((update_Satp64_Asid:riscv_sequential_types$Satp64 ->(16)words$word -> riscv_sequential_types$Satp64) (Mk_Satp64 (v)) x=   
 (Mk_Satp64 ((update_subrange_vec_dec v (( 59 : int):sail_values$ii) (( 44 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_Satp64_PPN : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty44*)

val _ = Define `
 ((get_Satp64_PPN:riscv_sequential_types$Satp64 ->(44)words$word) (Mk_Satp64 (v))=  ((subrange_vec_dec v (( 43 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  44 words$word)))`;


(*val _set_Satp64_PPN : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty44 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_Satp64_PPN:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$Satp64))sail_values$register_ref ->(44)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$Satp64) . 
   let r = ((get_Satp64 w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 43 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_Satp64 r))))`;


(*val _update_Satp64_PPN : Riscv_sequential_types.Satp64 -> Machine_word.mword Machine_word.ty44 -> Riscv_sequential_types.Satp64*)

val _ = Define `
 ((update_Satp64_PPN:riscv_sequential_types$Satp64 ->(44)words$word -> riscv_sequential_types$Satp64) (Mk_Satp64 (v)) x=   
 (Mk_Satp64 ((update_subrange_vec_dec v (( 43 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val legalize_satp : Riscv_sequential_types.Architecture -> Machine_word.mword Machine_word.ty64 -> Machine_word.mword Machine_word.ty64 -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((legalize_satp:riscv_sequential_types$Architecture ->(64)words$word ->(64)words$word ->(64)words$word) (a : riscv_sequential_types$Architecture) (o1 : riscv_sequential_types$xlenbits) (v : riscv_sequential_types$xlenbits)=   
 (let s = (Mk_Satp64 v) in
   (case ((satpMode_of_bits a ((get_Satp64_Mode s  :  4 words$word)))) of
     NONE => o1
   | SOME (Sv32) => o1
   | SOME (_) => (get_Satp64 s  :  64 words$word)
   )))`;


(*val csr_name : Machine_word.mword Machine_word.ty12 -> string*)

val _ = Define `
 ((csr_name:(12)words$word -> string) csr=   
 (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "ustatus"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "uie"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     "utvec"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "fflags"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "frm"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "fcsr"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "cycle"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "time"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "instret"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "cycleh"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "timeh"
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "instreth"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "sstatus"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "sedeleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "sideleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "sie"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     "stvec"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     "scounteren"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "sscratch"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "sepc"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "scause"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "stval"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "sip"
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "satp"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  :  12 words$word)))) then
     "mvendorid"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  :  12 words$word)))) then
     "marchid"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  :  12 words$word)))) then
     "mimpid"
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  :  12 words$word)))) then
     "mhartid"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mstatus"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "misa"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "medeleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "mideleg"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "mie"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     "mtvec"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     "mcounteren"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mscratch"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     "mepc"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "mcause"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     "mtval"
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     "mip"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mcycle"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "minstret"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     "mcycleh"
   else if (((b__0 = (vec_of_bits [B1;B0;B1;B1;B1;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     "minstreth"
   else "UNKNOWN"))`;


(*val csrAccess : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((csrAccess:(12)words$word ->(2)words$word) csr=  ((subrange_vec_dec csr (( 11 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  2 words$word)))`;


(*val csrPriv : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((csrPriv:(12)words$word ->(2)words$word) csr=  ((subrange_vec_dec csr (( 9 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  2 words$word)))`;


(*val is_CSR_defined : Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.Privilege -> bool*)

val _ = Define `
 ((is_CSR_defined:(12)words$word -> riscv_sequential_types$Privilege -> bool) (csr : 12 riscv_sequential_types$bits) (p : riscv_sequential_types$Privilege)=   
 (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     (((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B1;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     ((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word))))) \/ (((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))))
   else F))`;


(*val check_CSR_access : Machine_word.mword Machine_word.ty2 -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.Privilege -> bool -> bool*)

val _ = Define `
 ((check_CSR_access:(2)words$word ->(2)words$word -> riscv_sequential_types$Privilege -> bool -> bool) csrrw csrpr p isWrite= 
   (((~ ((((((((bool_to_bits isWrite  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((csrrw = (vec_of_bits [B1;B1]  :  2 words$word))))))))) /\ ((((lem$w2ui ((privLevel_to_bits p  :  2 words$word))) >= (lem$w2ui csrpr))))))`;


(*val check_TVM_SATP : Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.Privilege -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((check_TVM_SATP:(12)words$word -> riscv_sequential_types$Privilege ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (csr : riscv_sequential_types$csreg) (p : riscv_sequential_types$Privilege)=  (bindS   
(read_regS mstatus_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
   returnS ((~ ((((((csr = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) /\ ((((((((privLevel_to_bits p  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))) /\ (((((get_Mstatus_TVM w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))))))))))`;


(*val check_CSR : Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.Privilege -> bool -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((check_CSR:(12)words$word -> riscv_sequential_types$Privilege -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (csr : riscv_sequential_types$csreg) (p : riscv_sequential_types$Privilege) (isWrite : bool)=  (bindS   
(check_TVM_SATP csr p) (\ (w__0 : bool) . 
   returnS (((((is_CSR_defined csr p)) /\ (((((check_CSR_access ((csrAccess csr  :  2 words$word)) ((csrPriv csr  :  2 words$word)) p
                       isWrite)) /\ w__0)))))))))`;


(*val exception_delegatee : Riscv_sequential_types.ExceptionType -> Riscv_sequential_types.Privilege -> Riscv_sequential_types.M Riscv_sequential_types.Privilege*)

val _ = Define `
 ((exception_delegatee:riscv_sequential_types$ExceptionType -> riscv_sequential_types$Privilege ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$Privilege),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (e : riscv_sequential_types$ExceptionType) (p : riscv_sequential_types$Privilege)=   
 (let idx = (num_of_ExceptionType e) in bindS   
(read_regS medeleg_ref) (\ (w__0 : riscv_sequential_types$Medeleg) . 
   let super = (access_vec_dec ((get_Medeleg w__0  :  64 words$word)) idx) in bindS   
(read_regS sedeleg_ref) (\ (w__1 : riscv_sequential_types$Sedeleg) . 
   let user = (access_vec_dec ((get_Sedeleg w__1  :  64 words$word)) idx) in bindS   
(read_regS misa_ref) (\ (w__2 : riscv_sequential_types$Misa) . 
   let deleg =     
(if ((((((((get_Misa_S w__2  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((bit_to_bool super))))) then
       Supervisor
     else Machine) in
   returnS (if ((((lem$w2ui ((privLevel_to_bits deleg  :  2 words$word))) < (lem$w2ui ((privLevel_to_bits p  :  2 words$word)))))) then
              p
            else deleg))))))`;


(*val findPendingInterrupt : Machine_word.mword Machine_word.ty64 -> Maybe.maybe Riscv_sequential_types.InterruptType*)

val _ = Define `
 ((findPendingInterrupt:(64)words$word ->(riscv_sequential_types$InterruptType)option) ip=   
 (let ip = (Mk_Minterrupts ip) in
   if (((((get_Minterrupts_MEI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
     SOME I_M_External
   else if (((((get_Minterrupts_MSI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_M_Software
   else if (((((get_Minterrupts_MTI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_M_Timer
   else if (((((get_Minterrupts_SEI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_S_External
   else if (((((get_Minterrupts_SSI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_S_Software
   else if (((((get_Minterrupts_STI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_S_Timer
   else if (((((get_Minterrupts_UEI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_U_External
   else if (((((get_Minterrupts_USI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_U_Software
   else if (((((get_Minterrupts_UTI ip  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
   then
     SOME I_U_Timer
   else NONE))`;


(*val curInterrupt : Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.Minterrupts -> Riscv_sequential_types.M (Maybe.maybe ((Riscv_sequential_types.InterruptType * Riscv_sequential_types.Privilege)))*)

val _ = Define `
 ((curInterrupt:riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts -> riscv_sequential_types$Minterrupts ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((riscv_sequential_types$InterruptType#riscv_sequential_types$Privilege)option),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (pend : riscv_sequential_types$Minterrupts) (enbl : riscv_sequential_types$Minterrupts) (delg : riscv_sequential_types$Minterrupts)=   
 (let (en_mip : riscv_sequential_types$xlenbits) =     
((and_vec ((get_Minterrupts pend  :  64 words$word)) ((get_Minterrupts enbl  :  64 words$word))
       :  64 words$word)) in
   if (((en_mip = ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))))) then
     returnS NONE
   else
     let eff_mip =       
((and_vec en_mip ((not_vec ((get_Minterrupts delg  :  64 words$word))  :  64 words$word))
         :  64 words$word)) in
     let eff_sip = ((and_vec en_mip ((get_Minterrupts delg  :  64 words$word))  :  64 words$word)) in bindS     
(read_regS mstatus_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
     if ((((((((get_Mstatus_MIE w__0  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((eff_mip <> ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word)))))))) then
       returnS ((case ((findPendingInterrupt eff_mip)) of
                  SOME (i) =>
                   let r = (i, Machine) in
                   SOME r
                | NONE => NONE
                ))
     else bindS       
(read_regS mstatus_ref) (\ (w__1 : riscv_sequential_types$Mstatus) .  bindS       
(read_regS cur_privilege_ref) (\ (w__2 : riscv_sequential_types$Privilege) .  bindS       
(read_regS cur_privilege_ref) (\ (w__3 : riscv_sequential_types$Privilege) . 
       returnS (if ((((((((get_Mstatus_SIE w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((eff_sip <> ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word))))) /\ ((((((((privLevel_to_bits w__2  :  2 words$word)) = ((privLevel_to_bits Supervisor  :  2 words$word))))) \/ (((((privLevel_to_bits w__3  :  2 words$word)) = ((privLevel_to_bits User  :  2 words$word)))))))))))))) then
                  (case ((findPendingInterrupt eff_sip)) of
                    SOME (i) =>
                     let r = (i, Supervisor) in
                     SOME r
                  | NONE => NONE
                  )
                else NONE)))))))`;


(*val tval : Maybe.maybe (Machine_word.mword Machine_word.ty64) -> Machine_word.mword Machine_word.ty64*)

val _ = Define `
 ((tval:((64)words$word)option ->(64)words$word) excinfo=   
 ((case excinfo of
     SOME (e) => e
   | NONE => (EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word)
   )))`;


(*val handle_trap : Riscv_sequential_types.Privilege -> bool -> Machine_word.mword Machine_word.ty4 -> Machine_word.mword Machine_word.ty64 -> Maybe.maybe (Machine_word.mword Machine_word.ty64) -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((handle_trap:riscv_sequential_types$Privilege -> bool ->(4)words$word ->(64)words$word ->(riscv_sequential_types$xlenbits)option ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((64)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (del_priv : riscv_sequential_types$Privilege) (intr : bool) (c : riscv_sequential_types$exc_code) (pc : riscv_sequential_types$xlenbits) (info :
   riscv_sequential_types$xlenbits option)=   
 (let (_ : unit) =     
(prerr_endline
       ((STRCAT "handling "
           ((STRCAT (if intr then "int#" else "exc#")
               ((STRCAT ((string_of_vec c))
                   ((STRCAT " at priv " ((privLevel_to_str del_priv))))))))))) in
   (case del_priv of
     Machine => bindS (seqS (seqS      
(set_Mcause_IsInterrupt mcause_ref ((bool_to_bits intr  :  1 words$word)))      
(set_Mcause_Cause mcause_ref ((EXTZ (( 63 : int):sail_values$ii) c  :  63 words$word))))      
(read_regS mstatus_ref)) (\ (w__0 : riscv_sequential_types$Mstatus) .  bindS (seqS (seqS      
(set_Mstatus_MPIE mstatus_ref ((get_Mstatus_MIE w__0  :  1 words$word)))      
(set_Mstatus_MIE mstatus_ref ((bool_to_bits F  :  1 words$word))))      
(read_regS cur_privilege_ref)) (\ (w__1 : riscv_sequential_types$Privilege) .  bindS (seqS (seqS (seqS (seqS      
(set_Mstatus_MPP mstatus_ref ((privLevel_to_bits w__1  :  2 words$word)))      
(write_regS mtval_ref ((tval info  :  64 words$word))))      
(write_regS mepc_ref pc))      
(write_regS cur_privilege_ref del_priv))      
(read_regS mtvec_ref)) (\ (w__2 : riscv_sequential_types$Mtvec) .  bindS      
(read_regS mcause_ref) (\ (w__3 : riscv_sequential_types$Mcause) . 
      (case ((tvec_addr w__2 w__3  :  ( 64 words$word)option)) of
        SOME (epc) => returnS epc
      | NONE => (internal_error "Invalid mtvec mode"  : ( 64 words$word) riscv_sequential_types$M)
      )))))
   | Supervisor => bindS (seqS (seqS      
(set_Mcause_IsInterrupt scause_ref ((bool_to_bits intr  :  1 words$word)))      
(set_Mcause_Cause scause_ref ((EXTZ (( 63 : int):sail_values$ii) c  :  63 words$word))))      
(read_regS mstatus_ref)) (\ (w__6 : riscv_sequential_types$Mstatus) .  bindS (seqS (seqS      
(set_Mstatus_SPIE mstatus_ref ((get_Mstatus_SIE w__6  :  1 words$word)))      
(set_Mstatus_SIE mstatus_ref ((bool_to_bits F  :  1 words$word))))      
(read_regS cur_privilege_ref)) (\ (w__7 : riscv_sequential_types$Privilege) .  bindS
      (case w__7 of
        User => returnS ((bool_to_bits F  :  1 words$word))
      | Supervisor => returnS ((bool_to_bits T  :  1 words$word))
      | Machine => (internal_error "invalid privilege for s-mode trap"  : ( 1 words$word) riscv_sequential_types$M)
      ) (\ (w__9 :  1 words$word) .  bindS (seqS (seqS (seqS (seqS      
(set_Mstatus_SPP mstatus_ref w__9)      
(write_regS stval_ref ((tval info  :  64 words$word))))      
(write_regS sepc_ref pc))      
(write_regS cur_privilege_ref del_priv))      
(read_regS stvec_ref)) (\ (w__10 : riscv_sequential_types$Mtvec) .  bindS      
(read_regS scause_ref) (\ (w__11 : riscv_sequential_types$Mcause) . 
      (case ((tvec_addr w__10 w__11  :  ( 64 words$word)option)) of
        SOME (epc) => returnS epc
      | NONE => (internal_error "Invalid stvec mode"  : ( 64 words$word) riscv_sequential_types$M)
      ))))))
   | User => (internal_error "the N extension is currently unsupported"  : ( 64 words$word) riscv_sequential_types$M)
   )))`;


(*val handle_exception : Riscv_sequential_types.Privilege -> Riscv_sequential_types.ctl_result -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((handle_exception:riscv_sequential_types$Privilege -> riscv_sequential_types$ctl_result ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((64)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (cur_priv : riscv_sequential_types$Privilege) (ctl : riscv_sequential_types$ctl_result) (pc : riscv_sequential_types$xlenbits)=   
 ((case (cur_priv, ctl) of
     (_, CTL_TRAP (e)) => bindS      
(exception_delegatee e.sync_exception_trap cur_priv) (\ del_priv . 
      let (_ : unit) =        
(prerr_endline
          ((STRCAT "trapping from "
              ((STRCAT ((privLevel_to_str cur_priv))
                  ((STRCAT " to "
                      ((STRCAT ((privLevel_to_str del_priv))
                          ((STRCAT " to handle "
                              ((exceptionType_to_str e.sync_exception_trap))))))))))))) in
      (handle_trap del_priv F ((exceptionType_to_bits e.sync_exception_trap  :  4 words$word)) pc
         e.sync_exception_excinfo
        : ( 64 words$word) riscv_sequential_types$M))
   | (_, CTL_MRET (_)) => bindS      
(read_regS cur_privilege_ref) (\ prev_priv .  bindS      
(read_regS mstatus_ref) (\ (w__1 : riscv_sequential_types$Mstatus) .  bindS (seqS (seqS      
(set_Mstatus_MIE mstatus_ref ((get_Mstatus_MPIE w__1  :  1 words$word)))      
(set_Mstatus_MPIE mstatus_ref ((bool_to_bits T  :  1 words$word))))      
(read_regS mstatus_ref)) (\ (w__2 : riscv_sequential_types$Mstatus) .  bindS (seqS (seqS      
(write_regS cur_privilege_ref ((privLevel_of_bits ((get_Mstatus_MPP w__2  :  2 words$word)))))      
(set_Mstatus_MPP mstatus_ref ((privLevel_to_bits User  :  2 words$word))))      
(read_regS cur_privilege_ref)) (\ (w__3 : riscv_sequential_types$Privilege) . 
      let (_ : unit) =        
(prerr_endline
          ((STRCAT "ret-ing from "
              ((STRCAT ((privLevel_to_str prev_priv))
                  ((STRCAT " to " ((privLevel_to_str w__3))))))))) in
      (read_regS mepc_ref  : ( 64 words$word) riscv_sequential_types$M)))))
   | (_, CTL_SRET (_)) => bindS      
(read_regS cur_privilege_ref) (\ prev_priv .  bindS      
(read_regS mstatus_ref) (\ (w__5 : riscv_sequential_types$Mstatus) .  bindS (seqS (seqS      
(set_Mstatus_SIE mstatus_ref ((get_Mstatus_SPIE w__5  :  1 words$word)))      
(set_Mstatus_SPIE mstatus_ref ((bool_to_bits T  :  1 words$word))))      
(read_regS mstatus_ref)) (\ (w__6 : riscv_sequential_types$Mstatus) .  bindS (seqS (seqS      
(write_regS
        cur_privilege_ref
        (if (((((get_Mstatus_SPP w__6  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))
         then
           Supervisor
         else User))      
(set_Mstatus_SPP mstatus_ref ((bool_to_bits F  :  1 words$word))))      
(read_regS cur_privilege_ref)) (\ (w__7 : riscv_sequential_types$Privilege) . 
      let (_ : unit) =        
(prerr_endline
          ((STRCAT "ret-ing from "
              ((STRCAT ((privLevel_to_str prev_priv))
                  ((STRCAT " to " ((privLevel_to_str w__7))))))))) in
      (read_regS sepc_ref  : ( 64 words$word) riscv_sequential_types$M)))))
   )))`;


(*val handle_mem_exception : Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.ExceptionType -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((handle_mem_exception:(64)words$word -> riscv_sequential_types$ExceptionType ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (addr : riscv_sequential_types$xlenbits) (e : riscv_sequential_types$ExceptionType)=   
 (let (t : riscv_sequential_types$sync_exception) = (<| sync_exception_trap := e;  sync_exception_excinfo := (SOME addr) |>) in bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) .  bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) .  bindS
   (handle_exception w__0 (CTL_TRAP t) w__1  : ( 64 words$word) riscv_sequential_types$M) (\ (w__2 : riscv_sequential_types$xlenbits) . 
   write_regS nextPC_ref w__2)))))`;


(*val handle_decode_exception : Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((handle_decode_exception:(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) instbits=   
 (let (t : riscv_sequential_types$sync_exception) =     
(<| sync_exception_trap := E_Illegal_Instr; 
        sync_exception_excinfo := (SOME instbits) |>) in bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) .  bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) .  bindS
   (handle_exception w__0 (CTL_TRAP t) w__1  : ( 64 words$word) riscv_sequential_types$M) (\ (w__2 : riscv_sequential_types$xlenbits) . 
   write_regS nextPC_ref w__2)))))`;


(*val handle_interrupt : Riscv_sequential_types.InterruptType -> Riscv_sequential_types.Privilege -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((handle_interrupt:riscv_sequential_types$InterruptType -> riscv_sequential_types$Privilege ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (i : riscv_sequential_types$InterruptType) (del_priv : riscv_sequential_types$Privilege)=  (bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) .  bindS
   (handle_trap del_priv T ((interruptType_to_bits i  :  4 words$word)) w__0 NONE
     : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 : riscv_sequential_types$xlenbits) . 
   write_regS nextPC_ref w__1))))`;


(*val handle_illegal : unit -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((handle_illegal:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =   
 (let (t : riscv_sequential_types$sync_exception) =     
(<| sync_exception_trap := E_Illegal_Instr; 
        sync_exception_excinfo := NONE |>) in bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) .  bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) .  bindS
   (handle_exception w__0 (CTL_TRAP t) w__1  : ( 64 words$word) riscv_sequential_types$M) (\ (w__2 : riscv_sequential_types$xlenbits) . 
   write_regS nextPC_ref w__2)))))`;


(*val init_sys : unit -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((init_sys:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS (seqS (seqS (seqS (seqS (seqS   
(write_regS cur_privilege_ref Machine)   
(set_Misa_MXL misa_ref ((arch_to_bits RV64  :  2 words$word))))   
(set_Misa_C misa_ref ((bool_to_bits T  :  1 words$word))))   
(set_Misa_U misa_ref ((bool_to_bits T  :  1 words$word))))   
(set_Misa_S misa_ref ((bool_to_bits T  :  1 words$word))))   
(read_regS misa_ref)) (\ (w__0 : riscv_sequential_types$Misa) .  bindS (seqS   
(set_Mstatus_SXL mstatus_ref ((get_Misa_MXL w__0  :  2 words$word)))   
(read_regS misa_ref)) (\ (w__1 : riscv_sequential_types$Misa) .  seqS (seqS   
(set_Mstatus_UXL mstatus_ref ((get_Misa_MXL w__1  :  2 words$word)))   
(set_Mstatus_SD mstatus_ref ((bool_to_bits F  :  1 words$word))))   
(write_regS mhartid_ref ((EXTZ (( 64 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  64 words$word)))))))`;


(*val tick_clock : unit -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((tick_clock:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS
   (read_regS mcycle_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   write_regS mcycle_ref ((add_vec_int w__0 (( 1 : int):sail_values$ii)  :  64 words$word)))))`;


val _ = Define `
 ((PAGESIZE_BITS:int)=  ((( 12 : int):sail_values$ii)))`;


(*val _get_PTE_Bits : Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty8*)

val _ = Define `
 ((get_PTE_Bits:riscv_sequential_types$PTE_Bits ->(8)words$word) (Mk_PTE_Bits (v))=  v)`;


(*val _set_PTE_Bits : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.PTE_Bits -> Machine_word.mword Machine_word.ty8 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_PTE_Bits:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(8)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_PTE_Bits v) in
   write_regS r_ref r)))`;


val _ = Define `
 ((get_PTE_Bits_D:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_D:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_D:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_A:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_A:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_A:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_G:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_G:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_G:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_U:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_U:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_U:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 4 : int):sail_values$ii) (( 4 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_X:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_X:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_X:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 3 : int):sail_values$ii) (( 3 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_W:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_W:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_W:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_R:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_R:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_R:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 1 : int):sail_values$ii) (( 1 : int):sail_values$ii) x  :  8 words$word))))`;


val _ = Define `
 ((get_PTE_Bits_V:riscv_sequential_types$PTE_Bits ->(1)words$word) (Mk_PTE_Bits (v))=  ((subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  1 words$word)))`;


val _ = Define `
 ((set_PTE_Bits_V:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$PTE_Bits))sail_values$register_ref ->(1)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$PTE_Bits) . 
   let r = ((get_PTE_Bits w__0  :  8 words$word)) in
   let r = ((update_subrange_vec_dec r (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  8 words$word)) in
   write_regS r_ref (Mk_PTE_Bits r))))`;


val _ = Define `
 ((update_PTE_Bits_V:riscv_sequential_types$PTE_Bits ->(1)words$word -> riscv_sequential_types$PTE_Bits) (Mk_PTE_Bits (v)) x=   
 (Mk_PTE_Bits ((update_subrange_vec_dec v (( 0 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  8 words$word))))`;


(*val isPTEPtr : Machine_word.mword Machine_word.ty8 -> bool*)

val _ = Define `
 ((isPTEPtr:(8)words$word -> bool) p=   
 (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_R a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) /\ ((((((((get_PTE_Bits_W a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) /\ (((((get_PTE_Bits_X a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word)))))))))))`;


(*val isInvalidPTE : Machine_word.mword Machine_word.ty8 -> bool*)

val _ = Define `
 ((isInvalidPTE:(8)words$word -> bool) p=   
 (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_V a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ ((((((((get_PTE_Bits_W a  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((((get_PTE_Bits_R a  :  1 words$word)) = ((bool_to_bits F  :  1 words$word)))))))))))`;


(*val checkPTEPermission : Riscv_sequential_types.AccessType -> Riscv_sequential_types.Privilege -> bool -> bool -> Riscv_sequential_types.PTE_Bits -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((checkPTEPermission:riscv_sequential_types$AccessType -> riscv_sequential_types$Privilege -> bool -> bool -> riscv_sequential_types$PTE_Bits ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (ac : riscv_sequential_types$AccessType) (priv : riscv_sequential_types$Privilege) (mxr : bool) (sum : bool) (p : riscv_sequential_types$PTE_Bits)=   
 ((case (ac, priv) of
     (Read, User) =>
      returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr)))))))))
   | (Write, User) =>
      returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (ReadWrite, User) =>
      returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr))))))))))))
   | (Execute, User) =>
      returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ (((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (Read, Supervisor) =>
      returnS (((((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ sum))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr)))))))))
   | (Write, Supervisor) =>
      returnS (((((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ sum))) /\ (((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (ReadWrite, Supervisor) =>
      returnS (((((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) \/ sum))) /\ ((((((((get_PTE_Bits_W p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ ((((((((get_PTE_Bits_R p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) \/ ((((((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) /\ mxr))))))))))))
   | (Execute, Supervisor) =>
      returnS ((((((((get_PTE_Bits_U p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))))) /\ (((((get_PTE_Bits_X p  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))))))
   | (_, Machine) => internal_error "m-mode mem perm check"
   )))`;


(*val update_PTE_Bits : Riscv_sequential_types.PTE_Bits -> Riscv_sequential_types.AccessType -> Maybe.maybe Riscv_sequential_types.PTE_Bits*)

val _ = Define `
 ((update_PTE_Bits:riscv_sequential_types$PTE_Bits -> riscv_sequential_types$AccessType ->(riscv_sequential_types$PTE_Bits)option) (p : riscv_sequential_types$PTE_Bits) (a : riscv_sequential_types$AccessType)=   
 (let update_d =
     (((((((a = Write))) \/ (((a = ReadWrite)))))) /\ (((((get_PTE_Bits_D p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word)))))) in
   let update_a = (((get_PTE_Bits_A p  :  1 words$word)) = ((bool_to_bits F  :  1 words$word))) in
   if (((update_d \/ update_a))) then
     let np = (update_PTE_Bits_A p ((bool_to_bits T  :  1 words$word))) in
     let np = (if update_d then update_PTE_Bits_D p ((bool_to_bits T  :  1 words$word)) else np) in
     SOME np
   else NONE))`;


(*val PTW_Error_of_num : Num.integer -> Riscv_sequential_types.PTW_Error*)

val _ = Define `
 ((PTW_Error_of_num:int -> riscv_sequential_types$PTW_Error) arg_=   
 (let l__0 = arg_ in
   if (((l__0 = (( 0 : int):sail_values$ii)))) then PTW_Access
   else if (((l__0 = (( 1 : int):sail_values$ii)))) then PTW_Invalid_PTE
   else if (((l__0 = (( 2 : int):sail_values$ii)))) then PTW_No_Permission
   else if (((l__0 = (( 3 : int):sail_values$ii)))) then PTW_Misaligned
   else PTW_PTE_Update))`;


(*val num_of_PTW_Error : Riscv_sequential_types.PTW_Error -> Num.integer*)

val _ = Define `
 ((num_of_PTW_Error:riscv_sequential_types$PTW_Error -> int) arg_=   
 ((case arg_ of
     PTW_Access => (( 0 : int):sail_values$ii)
   | PTW_Invalid_PTE => (( 1 : int):sail_values$ii)
   | PTW_No_Permission => (( 2 : int):sail_values$ii)
   | PTW_Misaligned => (( 3 : int):sail_values$ii)
   | PTW_PTE_Update => (( 4 : int):sail_values$ii)
   )))`;


(*val translationException : Riscv_sequential_types.AccessType -> Riscv_sequential_types.PTW_Error -> Riscv_sequential_types.ExceptionType*)

val _ = Define `
 ((translationException:riscv_sequential_types$AccessType -> riscv_sequential_types$PTW_Error -> riscv_sequential_types$ExceptionType) (a : riscv_sequential_types$AccessType) (f : riscv_sequential_types$PTW_Error)= 
  ((case (a, f) of
         (Read, PTW_Access) => E_Load_Access_Fault
     | (Read, _) => E_Load_Page_Fault
     | (Write, PTW_Access) => E_SAMO_Access_Fault
     | (Write, _) => E_SAMO_Page_Fault
     | (Fetch, PTW_Access) => E_Fetch_Access_Fault
     | (Fetch, _) => E_Fetch_Page_Fault
   )))`;


val _ = Define `
 ((SV39_LEVEL_BITS:int)=  ((( 9 : int):sail_values$ii)))`;


val _ = Define `
 ((SV39_LEVELS:int)=  ((( 3 : int):sail_values$ii)))`;


val _ = Define `
 ((PTE39_LOG_SIZE:int)=  ((( 3 : int):sail_values$ii)))`;


val _ = Define `
 ((PTE39_SIZE:int)=  ((( 8 : int):sail_values$ii)))`;


(*val _get_SV39_Vaddr : Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty39*)

val _ = Define `
 ((get_SV39_Vaddr:riscv_sequential_types$SV39_Vaddr ->(39)words$word) (Mk_SV39_Vaddr (v))=  v)`;


(*val _set_SV39_Vaddr : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty39 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_Vaddr:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_Vaddr))sail_values$register_ref ->(39)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_SV39_Vaddr v) in
   write_regS r_ref r)))`;


(*val _get_SV39_Vaddr_VPNi : Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty27*)

val _ = Define `
 ((get_SV39_Vaddr_VPNi:riscv_sequential_types$SV39_Vaddr ->(27)words$word) (Mk_SV39_Vaddr (v))=  ((subrange_vec_dec v (( 38 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  27 words$word)))`;


(*val _set_SV39_Vaddr_VPNi : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty27 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_Vaddr_VPNi:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_Vaddr))sail_values$register_ref ->(27)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_Vaddr) . 
   let r = ((get_SV39_Vaddr w__0  :  39 words$word)) in
   let r = ((update_subrange_vec_dec r (( 38 : int):sail_values$ii) (( 12 : int):sail_values$ii) v  :  39 words$word)) in
   write_regS r_ref (Mk_SV39_Vaddr r))))`;


(*val _update_SV39_Vaddr_VPNi : Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty27 -> Riscv_sequential_types.SV39_Vaddr*)

val _ = Define `
 ((update_SV39_Vaddr_VPNi:riscv_sequential_types$SV39_Vaddr ->(27)words$word -> riscv_sequential_types$SV39_Vaddr) (Mk_SV39_Vaddr (v)) x=   
 (Mk_SV39_Vaddr ((update_subrange_vec_dec v (( 38 : int):sail_values$ii) (( 12 : int):sail_values$ii) x  :  39 words$word))))`;


(*val _get_SV39_Vaddr_PgOfs : Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty12*)

val _ = Define `
 ((get_SV39_Vaddr_PgOfs:riscv_sequential_types$SV39_Vaddr ->(12)words$word) (Mk_SV39_Vaddr (v))=  ((subrange_vec_dec v (( 11 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  12 words$word)))`;


(*val _set_SV39_Vaddr_PgOfs : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_Vaddr_PgOfs:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_Vaddr))sail_values$register_ref ->(12)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_Vaddr) . 
   let r = ((get_SV39_Vaddr w__0  :  39 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  39 words$word)) in
   write_regS r_ref (Mk_SV39_Vaddr r))))`;


(*val _update_SV39_Vaddr_PgOfs : Riscv_sequential_types.SV39_Vaddr -> Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.SV39_Vaddr*)

val _ = Define `
 ((update_SV39_Vaddr_PgOfs:riscv_sequential_types$SV39_Vaddr ->(12)words$word -> riscv_sequential_types$SV39_Vaddr) (Mk_SV39_Vaddr (v)) x=   
 (Mk_SV39_Vaddr ((update_subrange_vec_dec v (( 11 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  39 words$word))))`;


(*val _update_SV39_Paddr_PgOfs : Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.SV39_Paddr*)

(*val _get_SV39_Paddr_PgOfs : Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty12*)

(*val _set_SV39_Paddr_PgOfs : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.M unit*)

(*val _get_SV39_Paddr : Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty56*)

val _ = Define `
 ((get_SV39_Paddr:riscv_sequential_types$SV39_Paddr ->(56)words$word) (Mk_SV39_Paddr (v))=  v)`;


(*val _set_SV39_Paddr : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty56 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_Paddr:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_Paddr))sail_values$register_ref ->(56)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_SV39_Paddr v) in
   write_regS r_ref r)))`;


(*val _get_SV39_Paddr_PPNi : Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty44*)

val _ = Define `
 ((get_SV39_Paddr_PPNi:riscv_sequential_types$SV39_Paddr ->(44)words$word) (Mk_SV39_Paddr (v))=  ((subrange_vec_dec v (( 55 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  44 words$word)))`;


(*val _set_SV39_Paddr_PPNi : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty44 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_Paddr_PPNi:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_Paddr))sail_values$register_ref ->(44)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_Paddr) . 
   let r = ((get_SV39_Paddr w__0  :  56 words$word)) in
   let r = ((update_subrange_vec_dec r (( 55 : int):sail_values$ii) (( 12 : int):sail_values$ii) v  :  56 words$word)) in
   write_regS r_ref (Mk_SV39_Paddr r))))`;


(*val _update_SV39_Paddr_PPNi : Riscv_sequential_types.SV39_Paddr -> Machine_word.mword Machine_word.ty44 -> Riscv_sequential_types.SV39_Paddr*)

val _ = Define `
 ((update_SV39_Paddr_PPNi:riscv_sequential_types$SV39_Paddr ->(44)words$word -> riscv_sequential_types$SV39_Paddr) (Mk_SV39_Paddr (v)) x=   
 (Mk_SV39_Paddr ((update_subrange_vec_dec v (( 55 : int):sail_values$ii) (( 12 : int):sail_values$ii) x  :  56 words$word))))`;


(*val _update_SV39_PTE_PPNi : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty44 -> Riscv_sequential_types.SV39_PTE*)

(*val _get_SV39_PTE_PPNi : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty44*)

(*val _set_SV39_PTE_PPNi : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty44 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((get_SV39_Paddr_PgOfs:riscv_sequential_types$SV39_Paddr ->(12)words$word) (Mk_SV39_Paddr (v))=  ((subrange_vec_dec v (( 11 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  12 words$word)))`;


val _ = Define `
 ((set_SV39_Paddr_PgOfs:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_Paddr))sail_values$register_ref ->(12)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_Paddr) . 
   let r = ((get_SV39_Paddr w__0  :  56 words$word)) in
   let r = ((update_subrange_vec_dec r (( 11 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  56 words$word)) in
   write_regS r_ref (Mk_SV39_Paddr r))))`;


val _ = Define `
 ((update_SV39_Paddr_PgOfs:riscv_sequential_types$SV39_Paddr ->(12)words$word -> riscv_sequential_types$SV39_Paddr) (Mk_SV39_Paddr (v)) x=   
 (Mk_SV39_Paddr ((update_subrange_vec_dec v (( 11 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  56 words$word))))`;


val _ = Define `
 ((get_SV39_PTE:riscv_sequential_types$SV39_PTE ->(64)words$word) (Mk_SV39_PTE (v))=  v)`;


val _ = Define `
 ((set_SV39_PTE:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_PTE))sail_values$register_ref ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ r . 
   let r = (Mk_SV39_PTE v) in
   write_regS r_ref r)))`;


val _ = Define `
 ((get_SV39_PTE_PPNi:riscv_sequential_types$SV39_PTE ->(44)words$word) (Mk_SV39_PTE (v))=  ((subrange_vec_dec v (( 53 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  44 words$word)))`;


val _ = Define `
 ((set_SV39_PTE_PPNi:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_PTE))sail_values$register_ref ->(44)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_PTE) . 
   let r = ((get_SV39_PTE w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 53 : int):sail_values$ii) (( 10 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_SV39_PTE r))))`;


val _ = Define `
 ((update_SV39_PTE_PPNi:riscv_sequential_types$SV39_PTE ->(44)words$word -> riscv_sequential_types$SV39_PTE) (Mk_SV39_PTE (v)) x=   
 (Mk_SV39_PTE ((update_subrange_vec_dec v (( 53 : int):sail_values$ii) (( 10 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_SV39_PTE_RSW : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty2*)

val _ = Define `
 ((get_SV39_PTE_RSW:riscv_sequential_types$SV39_PTE ->(2)words$word) (Mk_SV39_PTE (v))=  ((subrange_vec_dec v (( 9 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  2 words$word)))`;


(*val _set_SV39_PTE_RSW : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_PTE_RSW:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_PTE))sail_values$register_ref ->(2)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_PTE) . 
   let r = ((get_SV39_PTE w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 9 : int):sail_values$ii) (( 8 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_SV39_PTE r))))`;


(*val _update_SV39_PTE_RSW : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty2 -> Riscv_sequential_types.SV39_PTE*)

val _ = Define `
 ((update_SV39_PTE_RSW:riscv_sequential_types$SV39_PTE ->(2)words$word -> riscv_sequential_types$SV39_PTE) (Mk_SV39_PTE (v)) x=   
 (Mk_SV39_PTE ((update_subrange_vec_dec v (( 9 : int):sail_values$ii) (( 8 : int):sail_values$ii) x  :  64 words$word))))`;


(*val _get_SV39_PTE_BITS : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty8*)

val _ = Define `
 ((get_SV39_PTE_BITS:riscv_sequential_types$SV39_PTE ->(8)words$word) (Mk_SV39_PTE (v))=  ((subrange_vec_dec v (( 7 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  8 words$word)))`;


(*val _set_SV39_PTE_BITS : Sail_values.register_ref Riscv_sequential_types.regstate Riscv_sequential_types.register_value Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty8 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((set_SV39_PTE_BITS:((riscv_sequential_types$regstate),(riscv_sequential_types$register_value),(riscv_sequential_types$SV39_PTE))sail_values$register_ref ->(8)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) r_ref v=  (bindS   
(reg_deref0 r_ref) (\ (w__0 : riscv_sequential_types$SV39_PTE) . 
   let r = ((get_SV39_PTE w__0  :  64 words$word)) in
   let r = ((update_subrange_vec_dec r (( 7 : int):sail_values$ii) (( 0 : int):sail_values$ii) v  :  64 words$word)) in
   write_regS r_ref (Mk_SV39_PTE r))))`;


(*val _update_SV39_PTE_BITS : Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty8 -> Riscv_sequential_types.SV39_PTE*)

val _ = Define `
 ((update_SV39_PTE_BITS:riscv_sequential_types$SV39_PTE ->(8)words$word -> riscv_sequential_types$SV39_PTE) (Mk_SV39_PTE (v)) x=   
 (Mk_SV39_PTE ((update_subrange_vec_dec v (( 7 : int):sail_values$ii) (( 0 : int):sail_values$ii) x  :  64 words$word))))`;


(*val curAsid64 : unit -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty16)*)

val _ = Define `
 ((curAsid64:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((16)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS
   (read_regS satp_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let satp64 = (Mk_Satp64 w__0) in
   returnS ((get_Satp64_Asid satp64  :  16 words$word)))))`;


(*val curPTB39 : unit -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty56)*)

val _ = Define `
 ((curPTB39:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((56)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS
   (read_regS satp_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let satp64 = (Mk_Satp64 w__0) in
   returnS ((EXTZ (( 56 : int):sail_values$ii)
               ((shiftl ((get_Satp64_PPN satp64  :  44 words$word)) PAGESIZE_BITS  :  44 words$word))
              :  56 words$word)))))`;


(*val walk39 : Machine_word.mword Machine_word.ty39 -> Riscv_sequential_types.AccessType -> Riscv_sequential_types.Privilege -> bool -> bool -> Machine_word.mword Machine_word.ty56 -> Sail_values.ii -> bool -> Riscv_sequential_types.M Riscv_sequential_types.PTW_Result*)

 val walk39_defn = Hol_defn "walk39" `
 ((walk39:(39)words$word -> riscv_sequential_types$AccessType -> riscv_sequential_types$Privilege -> bool -> bool ->(56)words$word -> int -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$PTW_Result),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) vaddr ac priv mxr sum ptb level global=   
 (let va = (Mk_SV39_Vaddr vaddr) in
   let (pt_ofs : riscv_sequential_types$paddr39) =     
((shiftl
        ((EXTZ (( 56 : int):sail_values$ii)
            ((subrange_vec_dec
                ((shiftr ((get_SV39_Vaddr_VPNi va  :  27 words$word))
                    ((level * SV39_LEVEL_BITS))
                   :  27 words$word)) SV39_LEVEL_BITS (( 0 : int):sail_values$ii)
               :  10 words$word))
           :  56 words$word)) PTE39_LOG_SIZE
       :  56 words$word)) in
   let pte_addr = ((add_vec ptb pt_ofs  :  56 words$word)) in bindS
   (checked_mem_read Data ((EXTZ (( 64 : int):sail_values$ii) pte_addr  :  64 words$word)) (( 8 : int):sail_values$ii)
     : ( ( 64 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__0 : ( 64 words$word) riscv_sequential_types$MemoryOpResult) . 
   (case w__0 of
     MemException (_) => returnS (PTW_Failure PTW_Access)
   | MemValue (v) =>
      let pte = (Mk_SV39_PTE v) in
      let pbits = ((get_SV39_PTE_BITS pte  :  8 words$word)) in
      let pattr = (Mk_PTE_Bits pbits) in
      let is_global =
        (global \/ (((((get_PTE_Bits_G pattr  :  1 words$word)) = ((bool_to_bits T  :  1 words$word)))))) in
      if ((isInvalidPTE pbits)) then returnS (PTW_Failure PTW_Invalid_PTE)
      else if ((isPTEPtr pbits)) then
        if (((level = (( 0 : int):sail_values$ii)))) then returnS (PTW_Failure PTW_Invalid_PTE)
        else
          walk39 vaddr ac priv mxr sum
            ((EXTZ (( 56 : int):sail_values$ii) ((get_SV39_PTE_PPNi pte  :  44 words$word))  :  56 words$word))
            ((level - (( 1 : int):sail_values$ii))) is_global
      else bindS        
(checkPTEPermission ac priv mxr sum pattr) (\ (w__3 : bool) . 
        returnS (if ((~ w__3)) then PTW_Failure PTW_No_Permission
                 else if ((level > (( 0 : int):sail_values$ii))) then
                   let masked =                     
((and_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                        ((EXTZ (( 44 : int):sail_values$ii)
                            ((sub_vec_int
                                ((shiftl (vec_of_bits [B1]  :  1 words$word)
                                    ((level * SV39_LEVEL_BITS))
                                   :  1 words$word)) (( 1 : int):sail_values$ii)
                               :  1 words$word))
                           :  44 words$word))
                       :  44 words$word)) in
                   if (((masked <> ((EXTZ (( 44 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  44 words$word)))))
                   then
                     PTW_Failure PTW_Misaligned
                   else
                     let ppn =                       
((or_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                          ((and_vec
                              ((EXTZ (( 44 : int):sail_values$ii) ((get_SV39_Vaddr_VPNi va  :  27 words$word))  :  44 words$word))
                              ((EXTZ (( 44 : int):sail_values$ii)
                                  ((sub_vec_int
                                      ((shiftl (vec_of_bits [B1]  :  1 words$word)
                                          ((level * SV39_LEVEL_BITS))
                                         :  1 words$word)) (( 1 : int):sail_values$ii)
                                     :  1 words$word))
                                 :  44 words$word))
                             :  44 words$word))
                         :  44 words$word)) in
                     PTW_Success ((concat_vec ppn ((get_SV39_Vaddr_PgOfs va  :  12 words$word))
                                    :  56 words$word),pte,pte_addr,level,is_global)
                 else
                   PTW_Success ((concat_vec ((get_SV39_PTE_PPNi pte  :  44 words$word))
                                   ((get_SV39_Vaddr_PgOfs va  :  12 words$word))
                                  :  56 words$word),pte,pte_addr,level,is_global)))
   ))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn walk39_defn;

(*val make_TLB39_Entry : Machine_word.mword Machine_word.ty16 -> bool -> Machine_word.mword Machine_word.ty39 -> Machine_word.mword Machine_word.ty56 -> Riscv_sequential_types.SV39_PTE -> Sail_values.ii -> Machine_word.mword Machine_word.ty56 -> Riscv_sequential_types.M Riscv_sequential_types.TLB39_Entry*)

val _ = Define `
 ((make_TLB39_Entry:(16)words$word -> bool ->(39)words$word ->(56)words$word -> riscv_sequential_types$SV39_PTE -> int ->(56)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$TLB39_Entry),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) asid global vAddr pAddr pte level pteAddr=   
 (let (shift : sail_values$ii) = (PAGESIZE_BITS + ((level * SV39_LEVEL_BITS))) in
   let (vAddrMask : riscv_sequential_types$vaddr39) =     
((sub_vec_int
        ((shiftl ((EXTZ (( 39 : int):sail_values$ii) (vec_of_bits [B1]  :  1 words$word)  :  39 words$word)) shift  :  39 words$word))
        (( 1 : int):sail_values$ii)
       :  39 words$word)) in
   let (vMatchMask : riscv_sequential_types$vaddr39) = ((not_vec vAddrMask  :  39 words$word)) in bindS
   (read_regS mcycle_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 : riscv_sequential_types$xlenbits) . 
   returnS (<| TLB39_Entry_asid := asid; 
               TLB39_Entry_global := global; 
               TLB39_Entry_pte := pte; 
               TLB39_Entry_pteAddr := pteAddr; 
               TLB39_Entry_vAddrMask := vAddrMask; 
               TLB39_Entry_vMatchMask := vMatchMask; 
               TLB39_Entry_vAddr := ((and_vec vAddr vMatchMask  :  39 words$word)); 
               TLB39_Entry_pAddr :=
                 ((shiftl ((shiftr pAddr shift  :  56 words$word)) shift  :  56 words$word)); 
               TLB39_Entry_age := w__0 |>))))`;


val _ = Define `
 ((TLBEntries:int)=  ((( 32 : int):sail_values$ii)))`;


(*val lookupTLB39 : Machine_word.mword Machine_word.ty16 -> Machine_word.mword Machine_word.ty39 -> Riscv_sequential_types.M (Maybe.maybe ((Sail_values.ii * Riscv_sequential_types.TLB39_Entry)))*)

val _ = Define `
 ((lookupTLB39:(16)words$word ->(39)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((int#riscv_sequential_types$TLB39_Entry)option),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) asid vaddr=  (bindS   
(read_regS tlb39_ref) (\ (w__0 :  riscv_sequential_types$TLB39_Entry option) . 
   returnS ((case w__0 of
              NONE => NONE
            | SOME (e) =>
               if ((((((e.TLB39_Entry_global \/ (((e.TLB39_Entry_asid = asid)))))) /\ (((e.TLB39_Entry_vAddr = ((and_vec e.TLB39_Entry_vMatchMask vaddr  :  39 words$word)))))))) then
                 SOME ((( 0 : int):sail_values$ii), e)
               else NONE
            )))))`;


(*val addToTLB39 : Machine_word.mword Machine_word.ty16 -> Machine_word.mword Machine_word.ty39 -> Machine_word.mword Machine_word.ty56 -> Riscv_sequential_types.SV39_PTE -> Machine_word.mword Machine_word.ty56 -> Sail_values.ii -> bool -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((addToTLB39:(16)words$word ->(39)words$word ->(56)words$word -> riscv_sequential_types$SV39_PTE ->(56)words$word -> int -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) asid vAddr pAddr pte pteAddr level global=  (bindS   
(make_TLB39_Entry asid global vAddr pAddr pte level pteAddr) (\ ent . 
   write_regS tlb39_ref (SOME ent))))`;


(*val writeTLB39 : Sail_values.ii -> Riscv_sequential_types.TLB39_Entry -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((writeTLB39:int -> riscv_sequential_types$TLB39_Entry ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (idx : sail_values$ii) (ent : riscv_sequential_types$TLB39_Entry)=  (write_regS tlb39_ref (SOME ent)))`;


(*val flushTLB : Maybe.maybe (Machine_word.mword Machine_word.ty16) -> Maybe.maybe (Machine_word.mword Machine_word.ty39) -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((flushTLB:((16)words$word)option ->((39)words$word)option ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) asid addr=  (bindS   
(read_regS tlb39_ref) (\ (w__0 :  riscv_sequential_types$TLB39_Entry option) . 
   let (ent :  riscv_sequential_types$TLB39_Entry option) =     
((case (w__0, asid, addr) of
       (NONE, _, _) => NONE
     | (SOME (e), NONE, NONE) => NONE
     | (SOME (e), NONE, SOME (a)) =>
        if (((e.TLB39_Entry_vAddr = ((and_vec e.TLB39_Entry_vMatchMask a  :  39 words$word))))) then
          NONE
        else SOME e
     | (SOME (e), SOME (i), NONE) =>
        if ((((((e.TLB39_Entry_asid = i))) /\ ((~ e.TLB39_Entry_global))))) then NONE
        else SOME e
     | (SOME (e), SOME (i), SOME (a)) =>
        if ((((((e.TLB39_Entry_asid = i))) /\ ((((((e.TLB39_Entry_vAddr = ((and_vec a e.TLB39_Entry_vMatchMask  :  39 words$word))))) /\ ((~ e.TLB39_Entry_global)))))))) then
          NONE
        else SOME e
     )) in
   write_regS tlb39_ref ent)))`;


val _ = Define `
 ((enable_dirty_update:bool)=  T)`;


(*val translate39 : Machine_word.mword Machine_word.ty39 -> Riscv_sequential_types.AccessType -> Riscv_sequential_types.Privilege -> bool -> bool -> Sail_values.ii -> Riscv_sequential_types.M Riscv_sequential_types.TR39_Result*)

val _ = Define `
 ((translate39:(39)words$word -> riscv_sequential_types$AccessType -> riscv_sequential_types$Privilege -> bool -> bool -> int ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$TR39_Result),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) vAddr ac priv mxr sum level=  (bindS
   (curAsid64 ()   : ( 16 words$word) riscv_sequential_types$M) (\ asid .  bindS   
(lookupTLB39 asid vAddr) (\ (w__0 :  ((sail_values$ii # riscv_sequential_types$TLB39_Entry))option) . 
   (case w__0 of
     SOME (idx,ent) =>
      let pteBits = (Mk_PTE_Bits ((get_SV39_PTE_BITS ent.TLB39_Entry_pte  :  8 words$word))) in bindS      
(checkPTEPermission ac priv mxr sum pteBits) (\ (w__1 : bool) . 
      if ((~ w__1)) then returnS (TR39_Failure PTW_No_Permission)
      else
        (case ((update_PTE_Bits pteBits ac)) of
          NONE =>
           returnS (TR39_Address ((or_vec ent.TLB39_Entry_pAddr
                                     ((EXTZ (( 56 : int):sail_values$ii)
                                         ((and_vec vAddr ent.TLB39_Entry_vAddrMask  :  39 words$word))
                                        :  56 words$word))
                                    :  56 words$word)))
        | SOME (pbits) =>
           if ((~ enable_dirty_update)) then returnS (TR39_Failure PTW_PTE_Update)
           else
             let (n_ent : riscv_sequential_types$TLB39_Entry) = ent in
             let n_ent =               
((n_ent with<|
                 TLB39_Entry_pte :=
                   ((update_SV39_PTE_BITS ent.TLB39_Entry_pte ((get_PTE_Bits pbits  :  8 words$word))))|>)) in bindS (seqS             
(writeTLB39 idx n_ent)             
(checked_mem_write ((EXTZ (( 64 : int):sail_values$ii) ent.TLB39_Entry_pteAddr  :  64 words$word)) (( 8 : int):sail_values$ii)
               ((get_SV39_PTE ent.TLB39_Entry_pte  :  64 words$word)))) (\ (w__2 : unit
               riscv_sequential_types$MemoryOpResult) .  seqS
             (case w__2 of
               MemValue (_) => returnS () 
             | MemException (e) => internal_error "invalid physical address in TLB"
             )             
(returnS (TR39_Address ((or_vec ent.TLB39_Entry_pAddr
                                       ((EXTZ (( 56 : int):sail_values$ii)
                                           ((and_vec vAddr ent.TLB39_Entry_vAddrMask  :  39 words$word))
                                          :  56 words$word))
                                      :  56 words$word)))))
        ))
   | NONE => bindS
      (curPTB39 ()   : ( 56 words$word) riscv_sequential_types$M) (\ (w__6 :  56 words$word) .  bindS      
(walk39 vAddr ac priv mxr sum w__6 level F) (\ (w__7 : riscv_sequential_types$PTW_Result) . 
      (case w__7 of
        PTW_Failure (f) => returnS (TR39_Failure f)
      | PTW_Success (pAddr,pte,pteAddr,level,global) =>
         (case ((update_PTE_Bits (Mk_PTE_Bits ((get_SV39_PTE_BITS pte  :  8 words$word))) ac)) of
           NONE => seqS            
(addToTLB39 asid vAddr pAddr pte pteAddr level global) (returnS (TR39_Address pAddr))
         | SOME (pbits) =>
            if ((~ enable_dirty_update)) then returnS (TR39_Failure PTW_PTE_Update)
            else
              let (w_pte : riscv_sequential_types$SV39_PTE) =                
(update_SV39_PTE_BITS pte ((get_PTE_Bits pbits  :  8 words$word))) in bindS              
(checked_mem_write ((EXTZ (( 64 : int):sail_values$ii) pteAddr  :  64 words$word)) (( 8 : int):sail_values$ii)
                ((get_SV39_PTE w_pte  :  64 words$word))) (\ (w__8 : unit riscv_sequential_types$MemoryOpResult) . 
              (case w__8 of
                MemValue (_) => seqS                 
(addToTLB39 asid vAddr pAddr w_pte pteAddr level global)                 
(returnS (TR39_Address pAddr))
              | MemException (e) => returnS (TR39_Failure PTW_Access)
              ))
         )
      )))
   )))))`;


(*val translationMode : Riscv_sequential_types.Privilege -> Riscv_sequential_types.M Riscv_sequential_types.SATPMode*)

val _ = Define `
 ((translationMode:riscv_sequential_types$Privilege ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$SATPMode),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) priv=   
 (if (((((privLevel_to_bits priv  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))))
   then
     returnS Sbare
   else bindS     
(read_regS mstatus_ref) (\ (w__0 : riscv_sequential_types$Mstatus) . 
     let arch = (architecture ((get_Mstatus_SXL w__0  :  2 words$word))) in
     (case arch of
       SOME (RV64) => bindS
        (read_regS satp_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) . 
        let (mbits : riscv_sequential_types$satp_mode) = ((get_Satp64_Mode (Mk_Satp64 w__1)  :  4 words$word)) in
        (case ((satpMode_of_bits RV64 mbits)) of
          SOME (m) => returnS m
        | NONE => internal_error "invalid RV64 translation mode in satp"
        ))
     | _ => internal_error "unsupported address translation arch"
     ))))`;


(*val translateAddr : Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.AccessType -> Riscv_sequential_types.ReadType -> Riscv_sequential_types.M Riscv_sequential_types.TR_Result*)

val _ = Define `
 ((translateAddr:(64)words$word -> riscv_sequential_types$AccessType -> riscv_sequential_types$ReadType ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$TR_Result),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) vAddr ac rt=  (bindS
   (case rt of
     Instruction => read_regS cur_privilege_ref
   | Data => bindS      
(read_regS mstatus_ref) (\ (w__1 : riscv_sequential_types$Mstatus) . 
      if (((((get_Mstatus_MPRV w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then bindS        
(read_regS mstatus_ref) (\ (w__2 : riscv_sequential_types$Mstatus) . 
        returnS ((privLevel_of_bits ((get_Mstatus_MPP w__2  :  2 words$word)))))
      else read_regS cur_privilege_ref)
   ) (\ (effPriv : riscv_sequential_types$Privilege) .  bindS   
(read_regS mstatus_ref) (\ (w__5 : riscv_sequential_types$Mstatus) . 
   let (mxr : bool) =
     (((get_Mstatus_MXR w__5  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))) in bindS   
(read_regS mstatus_ref) (\ (w__6 : riscv_sequential_types$Mstatus) . 
   let (sum : bool) =
     (((get_Mstatus_SUM w__6  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))) in bindS   
(translationMode effPriv) (\ (mode : riscv_sequential_types$SATPMode) .  
  (case mode of
        Sbare => returnS (TR_Address vAddr)
    | SV39 => bindS
                (translate39
                   ((subrange_vec_dec vAddr (( 38 : int): sail_values$ii)
                       (( 0 : int): sail_values$ii) : 39 words$word)) 
                 ac effPriv mxr sum
                   ((SV39_LEVELS - (( 1 : int): sail_values$ii))))
                (\ (w__7 : riscv_sequential_types$TR39_Result) . 
                 returnS
                   ((case w__7 of
                          TR39_Address (pa) => TR_Address
                                                 ((EXTZ
                                                     (( 64 : int): sail_values$ii)
                                                     pa : 64 words$word))
                      | TR39_Failure (f) => TR_Failure
                                              ((translationException ac f))
                    )))
  )))))))`;


(*val decode : Machine_word.mword Machine_word.ty32 -> Maybe.maybe Riscv_sequential_types.ast*)

(*val decodeCompressed : Machine_word.mword Machine_word.ty16 -> Maybe.maybe Riscv_sequential_types.ast*)

(*val execute : Riscv_sequential_types.ast -> Riscv_sequential_types.M unit*)

(*val print_insn : Riscv_sequential_types.ast -> string*)

(*val extend_value : forall 'int8_times_n . Size 'int8_times_n => bool -> Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n) -> Riscv_sequential_types.MemoryOpResult (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((extend_value:bool ->('int8_times_n words$word)riscv_sequential_types$MemoryOpResult ->((64)words$word)riscv_sequential_types$MemoryOpResult) is_unsigned value=   
 ((case value of
     MemValue (v) =>
      MemValue (if is_unsigned then (EXTZ (( 64 : int):sail_values$ii) v  :  64 words$word)
                else (EXTS (( 64 : int):sail_values$ii) v  :  64 words$word))
   | MemException (e) => MemException e
   )))`;


(*val process_load : forall 'int8_times_n . Size 'int8_times_n => Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.MemoryOpResult (Machine_word.mword 'int8_times_n) -> bool -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((process_load:(5)words$word ->(64)words$word ->('int8_times_n words$word)riscv_sequential_types$MemoryOpResult -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rd addr value is_unsigned=   
 ((case ((extend_value is_unsigned value  : ( 64 words$word) riscv_sequential_types$MemoryOpResult)) of
     MemValue (result) => wX ((regbits_to_regno rd)) result
   | MemException (e) => handle_mem_exception addr e
   )))`;


(*val process_loadres : forall 'int8_times_n . Riscv_sequential_types.regbits -> Riscv_sequential_types.xlenbits -> Riscv_sequential_types.MemoryOpResult (Riscv_sequential_types.bits 'int8_times_n) -> bool -> unit*)

(*val readCSR : Machine_word.mword Machine_word.ty12 -> Riscv_sequential_types.M (Machine_word.mword Machine_word.ty64)*)

val _ = Define `
 ((readCSR:(12)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->((((64)words$word),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) csr=   
 (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B0;B1]  :  12 words$word)))) then
     (read_regS mvendorid_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B0]  :  12 words$word)))) then
     (read_regS marchid_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B0;B1;B1]  :  12 words$word)))) then
     (read_regS mimpid_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B1;B1;B1;B1;B0;B0;B0;B1;B0;B1;B0;B0]  :  12 words$word)))) then
     (read_regS mhartid_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS     
(read_regS mstatus_ref) (\ (w__4 : riscv_sequential_types$Mstatus) .  returnS ((get_Mstatus w__4  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS     
(read_regS medeleg_ref) (\ (w__5 : riscv_sequential_types$Medeleg) .  returnS ((get_Medeleg w__5  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then bindS     
(read_regS mideleg_ref) (\ (w__6 : riscv_sequential_types$Minterrupts) . 
     returnS ((get_Minterrupts w__6  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS     
(read_regS mie_ref) (\ (w__7 : riscv_sequential_types$Minterrupts) . 
     returnS ((get_Minterrupts w__7  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then bindS     
(read_regS mtvec_ref) (\ (w__8 : riscv_sequential_types$Mtvec) .  returnS ((get_Mtvec w__8  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (read_regS mscratch_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (read_regS mepc_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS     
(read_regS mcause_ref) (\ (w__11 : riscv_sequential_types$Mcause) .  returnS ((get_Mcause w__11  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (read_regS mtval_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS     
(read_regS mip_ref) (\ (w__13 : riscv_sequential_types$Minterrupts) . 
     returnS ((get_Minterrupts w__13  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS     
(read_regS mstatus_ref) (\ (w__14 : riscv_sequential_types$Mstatus) . 
     returnS ((get_Mstatus w__14  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS     
(read_regS sedeleg_ref) (\ (w__15 : riscv_sequential_types$Sedeleg) . 
     returnS ((get_Sedeleg w__15  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then bindS     
(read_regS sideleg_ref) (\ (w__16 : riscv_sequential_types$Sinterrupts) . 
     returnS ((get_Sinterrupts w__16  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS     
(read_regS mie_ref) (\ (w__17 : riscv_sequential_types$Minterrupts) .  bindS     
(read_regS mideleg_ref) (\ (w__18 : riscv_sequential_types$Minterrupts) . 
     returnS ((get_Sinterrupts ((lower_mie w__17 w__18))  :  64 words$word))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then bindS     
(read_regS stvec_ref) (\ (w__19 : riscv_sequential_types$Mtvec) .  returnS ((get_Mtvec w__19  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (read_regS sscratch_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (read_regS sepc_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS     
(read_regS scause_ref) (\ (w__22 : riscv_sequential_types$Mcause) .  returnS ((get_Mcause w__22  :  64 words$word)))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then
     (read_regS stval_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS     
(read_regS mip_ref) (\ (w__24 : riscv_sequential_types$Minterrupts) .  bindS     
(read_regS mideleg_ref) (\ (w__25 : riscv_sequential_types$Minterrupts) . 
     returnS ((get_Sinterrupts ((lower_mip w__24 w__25))  :  64 words$word))))
   else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (read_regS satp_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then
     (read_regS mcycle_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then
     (read_regS mtime_ref  : ( 64 words$word) riscv_sequential_types$M)
   else if (((b__0 = (vec_of_bits [B1;B1;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then
     (read_regS minstret_ref  : ( 64 words$word) riscv_sequential_types$M)
   else
     let (_ : unit) = (print_bits "unhandled read to CSR " csr) in
     returnS (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                           B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                           B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                           B0]
               :  64 words$word)))`;


(*val writeCSR : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty64 -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((writeCSR:(12)words$word ->(64)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) (csr : riscv_sequential_types$csreg) (value : riscv_sequential_types$xlenbits)=   
 (let b__0 = csr in bindS
   (if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS      
(read_regS mstatus_ref) (\ (w__0 : riscv_sequential_types$Mstatus) .  bindS (seqS      
(write_regS mstatus_ref ((legalize_mstatus w__0 value)))      
(read_regS mstatus_ref)) (\ (w__1 : riscv_sequential_types$Mstatus) . 
      returnS (SOME ((get_Mstatus w__1  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS      
(read_regS medeleg_ref) (\ (w__2 : riscv_sequential_types$Medeleg) .  bindS (seqS      
(write_regS medeleg_ref ((legalize_medeleg w__2 value)))      
(read_regS medeleg_ref)) (\ (w__3 : riscv_sequential_types$Medeleg) . 
      returnS (SOME ((get_Medeleg w__3  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then bindS      
(read_regS mideleg_ref) (\ (w__4 : riscv_sequential_types$Minterrupts) .  bindS (seqS      
(write_regS mideleg_ref ((legalize_mideleg w__4 value)))      
(read_regS mideleg_ref)) (\ (w__5 : riscv_sequential_types$Minterrupts) . 
      returnS (SOME ((get_Minterrupts w__5  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS      
(read_regS mie_ref) (\ (w__6 : riscv_sequential_types$Minterrupts) .  bindS (seqS      
(write_regS mie_ref ((legalize_mie w__6 value)))      
(read_regS mie_ref)) (\ (w__7 : riscv_sequential_types$Minterrupts) . 
      returnS (SOME ((get_Minterrupts w__7  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then bindS      
(read_regS mtvec_ref) (\ (w__8 : riscv_sequential_types$Mtvec) .  bindS (seqS      
(write_regS mtvec_ref ((legalize_tvec w__8 value)))      
(read_regS mtvec_ref)) (\ (w__9 : riscv_sequential_types$Mtvec) . 
      returnS (SOME ((get_Mtvec w__9  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS (seqS      
(write_regS mscratch_ref value)
      (read_regS mscratch_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__10 :  64 words$word) . 
      returnS (SOME w__10))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then bindS
      (legalize_xepc value  : ( 64 words$word) riscv_sequential_types$M) (\ (w__11 : riscv_sequential_types$xlenbits) .  bindS (seqS      
(write_regS mepc_ref w__11)
      (read_regS mepc_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__12 :  64 words$word) .  returnS (SOME w__12)))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS (seqS      
(set_Mcause mcause_ref value)      
(read_regS mcause_ref)) (\ (w__13 : riscv_sequential_types$Mcause) . 
      returnS (SOME ((get_Mcause w__13  :  64 words$word))))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then bindS (seqS      
(write_regS mtval_ref value)
      (read_regS mtval_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__14 :  64 words$word) .  returnS (SOME w__14))
    else if (((b__0 = (vec_of_bits [B0;B0;B1;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS      
(read_regS mip_ref) (\ (w__15 : riscv_sequential_types$Minterrupts) .  bindS (seqS      
(write_regS mip_ref ((legalize_mip w__15 value)))      
(read_regS mip_ref)) (\ (w__16 : riscv_sequential_types$Minterrupts) . 
      returnS (SOME ((get_Minterrupts w__16  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS      
(read_regS mstatus_ref) (\ (w__17 : riscv_sequential_types$Mstatus) .  bindS (seqS      
(write_regS mstatus_ref ((legalize_sstatus w__17 value)))      
(read_regS mstatus_ref)) (\ (w__18 : riscv_sequential_types$Mstatus) . 
      returnS (SOME ((get_Mstatus w__18  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS      
(read_regS sedeleg_ref) (\ (w__19 : riscv_sequential_types$Sedeleg) .  bindS (seqS      
(write_regS sedeleg_ref ((legalize_sedeleg w__19 value)))      
(read_regS sedeleg_ref)) (\ (w__20 : riscv_sequential_types$Sedeleg) . 
      returnS (SOME ((get_Sedeleg w__20  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then bindS (seqS      
(set_Sinterrupts sideleg_ref value)      
(read_regS sideleg_ref)) (\ (w__21 : riscv_sequential_types$Sinterrupts) . 
      returnS (SOME ((get_Sinterrupts w__21  :  64 words$word))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS      
(read_regS mie_ref) (\ (w__22 : riscv_sequential_types$Minterrupts) .  bindS      
(read_regS mideleg_ref) (\ (w__23 : riscv_sequential_types$Minterrupts) .  bindS (seqS      
(write_regS mie_ref ((legalize_sie w__22 w__23 value)))      
(read_regS mie_ref)) (\ (w__24 : riscv_sequential_types$Minterrupts) . 
      returnS (SOME ((get_Minterrupts w__24  :  64 words$word))))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1]  :  12 words$word)))) then bindS      
(read_regS stvec_ref) (\ (w__25 : riscv_sequential_types$Mtvec) .  bindS (seqS      
(write_regS stvec_ref ((legalize_tvec w__25 value)))      
(read_regS stvec_ref)) (\ (w__26 : riscv_sequential_types$Mtvec) . 
      returnS (SOME ((get_Mtvec w__26  :  64 words$word)))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS (seqS      
(write_regS sscratch_ref value)
      (read_regS sscratch_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__27 :  64 words$word) . 
      returnS (SOME w__27))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B1]  :  12 words$word)))) then bindS
      (legalize_xepc value  : ( 64 words$word) riscv_sequential_types$M) (\ (w__28 : riscv_sequential_types$xlenbits) .  bindS (seqS      
(write_regS sepc_ref w__28)
      (read_regS sepc_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__29 :  64 words$word) .  returnS (SOME w__29)))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B0]  :  12 words$word)))) then bindS (seqS      
(set_Mcause scause_ref value)      
(read_regS scause_ref)) (\ (w__30 : riscv_sequential_types$Mcause) . 
      returnS (SOME ((get_Mcause w__30  :  64 words$word))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B1;B1]  :  12 words$word)))) then bindS (seqS      
(write_regS stval_ref value)
      (read_regS stval_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__31 :  64 words$word) .  returnS (SOME w__31))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B0;B1;B0;B0;B0;B1;B0;B0]  :  12 words$word)))) then bindS      
(read_regS mip_ref) (\ (w__32 : riscv_sequential_types$Minterrupts) .  bindS      
(read_regS mideleg_ref) (\ (w__33 : riscv_sequential_types$Minterrupts) .  bindS (seqS      
(write_regS mip_ref ((legalize_sip w__32 w__33 value)))      
(read_regS mip_ref)) (\ (w__34 : riscv_sequential_types$Minterrupts) . 
      returnS (SOME ((get_Minterrupts w__34  :  64 words$word))))))
    else if (((b__0 = (vec_of_bits [B0;B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)))) then bindS      
(cur_Architecture () ) (\ (w__35 : riscv_sequential_types$Architecture) .  bindS
      (read_regS satp_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__36 :  64 words$word) .  bindS (seqS      
(write_regS satp_ref ((legalize_satp w__35 w__36 value  :  64 words$word)))
      (read_regS satp_ref  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__37 :  64 words$word) .  returnS (SOME w__37))))
    else returnS NONE) (\ (res :  riscv_sequential_types$xlenbits option) . 
   returnS ((case res of
              SOME (v) =>
               prerr_endline
                 ((STRCAT "CSR "
                     ((STRCAT ((csr_name csr))
                         ((STRCAT " <- "
                             ((STRCAT ((string_of_vec v))
                                 ((STRCAT " (input: "
                                     ((STRCAT ((string_of_vec value)) ")"))))))))))))
            | NONE => print_bits "unhandled write to CSR " csr
            )))))`;


(*val signalIllegalInstruction : unit -> Riscv_sequential_types.M unit*)

val _ = Define `
 ((signalIllegalInstruction:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (not_implemented "illegal instruction"))`;


val _ = Define `
 ((decode:(32)words$word ->(riscv_sequential_types$ast)option) v__0=   
 (if (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B1;B1;B1]  :  7 words$word)))) then
     let (imm : 20 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  20 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (UTYPE (imm,rd,RISCV_LUI))
   else if (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B1;B1;B1]  :  7 words$word)))) then
     let (imm : 20 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  20 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (UTYPE (imm,rd,RISCV_AUIPC))
   else if (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B1;B1;B1;B1]  :  7 words$word)))) then
     let (imm : 20 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  20 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RISCV_JAL ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm (( 19 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm (( 7 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  8 words$word))
                             ((concat_vec
                                 ((cast_unit_vec0 ((access_vec_dec imm (( 8 : int):sail_values$ii)))  :  1 words$word))
                                 ((concat_vec ((subrange_vec_dec imm (( 18 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  6 words$word))
                                     ((concat_vec
                                         ((subrange_vec_dec imm (( 12 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  4 words$word))
                                         (vec_of_bits [B0]  :  1 words$word)
                                        :  5 words$word))
                                    :  11 words$word))
                                :  12 words$word))
                            :  20 words$word))
                        :  21 words$word),rd))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B1;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RISCV_JALR (imm,rs1,rd))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):sail_values$ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BEQ))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):sail_values$ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BNE))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):sail_values$ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BLT))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):sail_values$ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BGE))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):sail_values$ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BLTU))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 : int):sail_values$ii)))  :  1 words$word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 : int):sail_values$ii)))  :  1 words$word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  4 words$word))
                                 (vec_of_bits [B0]  :  1 words$word)
                                :  5 words$word))
                            :  11 words$word))
                        :  12 words$word))
                    :  13 words$word),rs2,rs1,RISCV_BGEU))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_ADDI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_SLTI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_SLTIU))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_XORI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_ORI))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ITYPE (imm,rs1,rd,RISCV_ANDI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 26 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 6 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 25 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  6 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SHIFTIOP (shamt,rs1,rd,RISCV_SLLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 26 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 6 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 25 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  6 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SHIFTIOP (shamt,rs1,rd,RISCV_SRLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 26 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 6 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 25 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  6 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SHIFTIOP (shamt,rs1,rd,RISCV_SRAI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_ADD))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SUB))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SLL))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SLT))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SLTU))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_XOR))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SRL))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_SRA))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_OR))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPE (rs2,rs1,rd,RISCV_AND))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,BYTE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,HALF,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,WORD,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,F,DOUBLE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,T,BYTE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,T,HALF,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOAD (imm,rs1,rd,T,WORD,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,BYTE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,HALF,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,WORD,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (imm7 : 7 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (imm5 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (STORE ((concat_vec imm7 imm5  :  12 words$word),rs2,rs1,DOUBLE,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word))))))) then
     let (imm : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (ADDIW (imm,rs1,rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SHIFTW (shamt,rs1,rd,RISCV_SLLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SHIFTW (shamt,rs1,rd,RISCV_SRLI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (shamt : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SHIFTW (shamt,rs1,rd,RISCV_SRAI))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_ADDW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SUBW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SLLW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SRLW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B0;B0;B0;B0]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (RTYPEW (rs2,rs1,rd,RISCV_SRAW))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,F,T,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,T,T,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,T,T,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (MUL (rs2,rs1,rd,T,F,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (DIV0 (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (DIV0 (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (REM (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B0;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (REM (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (MULW (rs2,rs1,rd))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (DIVW (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (DIVW (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (REMW (rs2,rs1,rd,T))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B1]  :  7 words$word)))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B1;B1;B0;B1;B1]  :  7 words$word)))))))))) then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (REMW (rs2,rs1,rd,F))
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 28 : int):sail_values$ii)  :  4 words$word)) = (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  20 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                     :  20 words$word))))))) then
     let (pred : 4 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 27 : int):sail_values$ii) (( 24 : int):sail_values$ii)  :  4 words$word)) in
     let (succ : 4 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 23 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  4 words$word)) in
     SOME (FENCE (pred,succ))
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;
                             B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B1]
                 :  32 words$word)))) then
     SOME (FENCEI () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (ECALL () )
   else if (((v__0 = (vec_of_bits [B0;B0;B1;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (MRET () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (SRET () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (EBREAK () )
   else if (((v__0 = (vec_of_bits [B0;B0;B0;B1;B0;B0;B0;B0;B0;B1;B0;B1;B0;B0;B0;B0;B0;B0;B0;B0;B0;
                             B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]
                 :  32 words$word)))) then
     SOME (WFI () )
   else if ((((((((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 25 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B1;B0;B0;B1]  :  7 words$word)))) /\ (((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  15 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B1;B1;B1;B0;B0;B1;B1]  :  15 words$word)))))))
   then
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     SOME (SFENCE_VMA (rs1,rs2))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word))))))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOADRES (bit_to_bool aq,bit_to_bool rl,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word))))))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (LOADRES (bit_to_bool aq,bit_to_bool rl,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (STORECON (bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (STORECON (bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOSWAP,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B1]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOSWAP,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOADD,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOADD,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOXOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOXOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOAND,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOAND,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMIN,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMIN,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMAX,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B0;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMAX,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMINU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B0;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMINU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMAXU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 27 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B1;B1;B1;B0;B0]  :  5 words$word)))))) /\ ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B1;B0;B1;B1;B1;B1]  :  7 words$word)))))))))) then
     let aq = (access_vec_dec v__0 (( 26 : int):sail_values$ii)) in
     let rl = (access_vec_dec v__0 (( 25 : int):sail_values$ii)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 24 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  5 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (AMO (AMOMAXU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,F,CSRRW))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,F,CSRRS))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,F,CSRRC))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,T,CSRRW))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,T,CSRRS))
   else if ((((((((subrange_vec_dec v__0 (( 14 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__0 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B1;B1;B1;B0;B0;B1;B1]  :  7 words$word))))))) then
     let (csr : 12 riscv_sequential_types$bits) = ((subrange_vec_dec v__0 (( 31 : int):sail_values$ii) (( 20 : int):sail_values$ii)  :  12 words$word)) in
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 19 : int):sail_values$ii) (( 15 : int):sail_values$ii)  :  5 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__0 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     SOME (CSR (csr,rs1,rd,T,CSRRC))
   else NONE))`;


val _ = Define `
 ((decodeCompressed:(16)words$word ->(riscv_sequential_types$ast)option) v__418=   
 (if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word)))))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzi1 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (nzi0 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     if ((((((nzi1 = (vec_of_bits [B0]  :  1 words$word)))) /\ (((((regbits_to_regno nzi0)) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B0;B0]  :  5 words$word))))))))) then
       SOME (NOP () )
     else NONE
   else if (((v__418 = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  16 words$word)))) then
     SOME (ILLEGAL () )
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (nz54 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 11 : int):sail_values$ii)  :  2 words$word)) in
     let (nz96 : 4 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 10 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  4 words$word)) in
     let (nz2 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)) in
     let (nz3 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)) in
     let (rd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     let nzimm =       
((concat_vec nz96 ((concat_vec nz54 ((concat_vec nz3 nz2  :  2 words$word))  :  4 words$word))
         :  8 words$word)) in
     if (((nzimm = (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0]  :  8 words$word)))) then NONE
     else SOME (C_ADDI4SPN (rd,nzimm))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  3 words$word)) in
     let (rs1 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (ui2 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)) in
     let (ui6 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)) in
     let (rd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui6 ((concat_vec ui53 ui2  :  4 words$word))  :  5 words$word)) in
     SOME (C_LW (uimm,rs1,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  3 words$word)) in
     let (rs1 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (ui76 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) in
     let (rd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui76 ui53  :  5 words$word)) in
     SOME (C_LD (uimm,rs1,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  3 words$word)) in
     let (rs1 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (ui2 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)) in
     let (ui6 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui6 ((concat_vec ui53 ui2  :  4 words$word))  :  5 words$word)) in
     SOME (C_SW (uimm,rs1,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word))))))) then
     let (ui53 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  3 words$word)) in
     let (rs1 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (ui76 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) in
     let (rs2 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     let uimm = ((concat_vec ui76 ui53  :  5 words$word)) in
     SOME (C_SD (uimm,rs1,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (nzi5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rsd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (nzi40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     let nzi = ((concat_vec nzi5 nzi40  :  6 words$word)) in
     if ((((((nzi = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) \/ (((((regbits_to_regno rsd)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_ADDI (nzi,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (imm5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rsd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (imm40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     SOME (C_ADDIW ((concat_vec imm5 imm40  :  6 words$word),rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (imm5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (imm40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_LI ((concat_vec imm5 imm40  :  6 words$word),rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ ((((((((regbits_to_regno ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)))) = ((regbits_to_regno (vec_of_bits [B0;B0;B0;B1;B0]  :  5 words$word)))))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzi9 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (nzi4 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)) in
     let (nzi6 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 5 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  1 words$word)) in
     let (nzi87 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  2 words$word)) in
     let (nzi5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)) in
     let nzimm =       
((concat_vec nzi9
          ((concat_vec nzi87 ((concat_vec nzi6 ((concat_vec nzi5 nzi4  :  2 words$word))  :  3 words$word))
             :  5 words$word))
         :  6 words$word)) in
     if (((nzimm = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) then NONE
     else SOME (C_ADDI16SP nzimm)
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (imm17 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (imm1612 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     if ((((((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) \/ (((((regbits_to_regno rd)) = ((regbits_to_regno sp)))))))) then
       NONE
     else SOME (C_LUI ((concat_vec imm17 imm1612  :  6 words$word),rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzui5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (nzui40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     let (shamt : 6 riscv_sequential_types$bits) = ((concat_vec nzui5 nzui40  :  6 words$word)) in
     if (((shamt = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) then NONE
     else SOME (C_SRLI (shamt,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (nzui5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (nzui40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     let (shamt : 6 riscv_sequential_types$bits) = ((concat_vec nzui5 nzui40  :  6 words$word)) in
     if (((shamt = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) then NONE
     else SOME (C_SRAI (shamt,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B0]  :  3 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (i5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (i40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     SOME (C_ANDI ((concat_vec i5 i40  :  6 words$word),rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     SOME (C_SUB (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     SOME (C_XOR (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     SOME (C_OR (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B0;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     SOME (C_AND (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B0]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     SOME (C_SUBW (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  6 words$word)) = (vec_of_bits [B1;B0;B0;B1;B1;B1]  :  6 words$word)))) /\ ((((((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word)))))))))) then
     let (rsd : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     SOME (C_ADDW (rsd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B0;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (i11 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (i4 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 11 : int):sail_values$ii)  :  1 words$word)) in
     let (i98 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 10 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  2 words$word)) in
     let (i10 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 8 : int):sail_values$ii) (( 8 : int):sail_values$ii)  :  1 words$word)) in
     let (i6 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 7 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  1 words$word)) in
     let (i7 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 6 : int):sail_values$ii)  :  1 words$word)) in
     let (i31 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 5 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  3 words$word)) in
     let (i5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)) in
     SOME (C_J ((concat_vec i11
                   ((concat_vec i10
                       ((concat_vec i98
                           ((concat_vec i7
                               ((concat_vec i6
                                   ((concat_vec i5 ((concat_vec i4 i31  :  4 words$word))  :  5 words$word))
                                  :  6 words$word))
                              :  7 words$word))
                          :  9 words$word))
                      :  10 words$word))
                  :  11 words$word)))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (i8 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (i43 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  2 words$word)) in
     let (rs : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (i76 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) in
     let (i21 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  2 words$word)) in
     let (i5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)) in
     SOME (C_BEQZ ((concat_vec i8
                      ((concat_vec i76
                          ((concat_vec i5 ((concat_vec i43 i21  :  4 words$word))  :  5 words$word))
                         :  7 words$word))
                     :  8 words$word),rs))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B0;B1]  :  2 words$word))))))) then
     let (i8 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (i43 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  2 words$word)) in
     let (rs : riscv_sequential_types$cregbits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (i76 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) in
     let (i21 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 3 : int):sail_values$ii)  :  2 words$word)) in
     let (i5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 2 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  1 words$word)) in
     SOME (C_BNEZ ((concat_vec i8
                      ((concat_vec i76
                          ((concat_vec i5 ((concat_vec i43 i21  :  4 words$word))  :  5 words$word))
                         :  7 words$word))
                     :  8 words$word),rs))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B0;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (nzui5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rsd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (nzui40 : 5 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     let (shamt : 6 riscv_sequential_types$bits) = ((concat_vec nzui5 nzui40  :  6 words$word)) in
     if ((((((shamt = (vec_of_bits [B0;B0;B0;B0;B0;B0]  :  6 words$word)))) \/ (((((regbits_to_regno rsd)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_SLLI (shamt,rsd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (ui42 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 4 : int):sail_values$ii)  :  3 words$word)) in
     let (ui76 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 3 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  2 words$word)) in
     let (uimm : 6 riscv_sequential_types$bits) = ((concat_vec ui76 ((concat_vec ui5 ui42  :  4 words$word))  :  6 words$word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_LWSP (uimm,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B0;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui5 : 1 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  1 words$word)) in
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (ui43 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 5 : int):sail_values$ii)  :  2 words$word)) in
     let (ui86 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 4 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  3 words$word)) in
     let (uimm : 6 riscv_sequential_types$bits) = ((concat_vec ui86 ((concat_vec ui5 ui43  :  3 words$word))  :  6 words$word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_LDSP (uimm,rd))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B0]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui52 : 4 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 9 : int):sail_values$ii)  :  4 words$word)) in
     let (ui76 : 2 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 8 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  2 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     let (uimm : 6 riscv_sequential_types$bits) = ((concat_vec ui76 ui52  :  6 words$word)) in
     SOME (C_SWSP (uimm,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 13 : int):sail_values$ii)  :  3 words$word)) = (vec_of_bits [B1;B1;B1]  :  3 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (ui53 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 12 : int):sail_values$ii) (( 10 : int):sail_values$ii)  :  3 words$word)) in
     let (ui86 : 3 riscv_sequential_types$bits) = ((subrange_vec_dec v__418 (( 9 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  3 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     let (uimm : 6 riscv_sequential_types$bits) = ((concat_vec ui86 ui53  :  6 words$word)) in
     SOME (C_SDSP (uimm,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  :  7 words$word))))))) then
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     if (((((regbits_to_regno rs1)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_JR rs1)
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  7 words$word)) = (vec_of_bits [B0;B0;B0;B0;B0;B1;B0]  :  7 words$word))))))) then
     let (rs1 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     if (((((regbits_to_regno rs1)) = ((regbits_to_regno zreg))))) then NONE
     else SOME (C_JALR rs1)
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B0]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (rd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     if ((((((((regbits_to_regno rs2)) = ((regbits_to_regno zreg))))) \/ (((((regbits_to_regno rd)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_MV (rd,rs2))
   else if ((((((((subrange_vec_dec v__418 (( 15 : int):sail_values$ii) (( 12 : int):sail_values$ii)  :  4 words$word)) = (vec_of_bits [B1;B0;B0;B1]  :  4 words$word)))) /\ (((((subrange_vec_dec v__418 (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B0]  :  2 words$word))))))) then
     let (rsd : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 11 : int):sail_values$ii) (( 7 : int):sail_values$ii)  :  5 words$word)) in
     let (rs2 : riscv_sequential_types$regbits) = ((subrange_vec_dec v__418 (( 6 : int):sail_values$ii) (( 2 : int):sail_values$ii)  :  5 words$word)) in
     if ((((((((regbits_to_regno rsd)) = ((regbits_to_regno zreg))))) \/ (((((regbits_to_regno rs2)) = ((regbits_to_regno zreg)))))))) then
       NONE
     else SOME (C_ADD (rsd,rs2))
   else NONE))`;


(*val execute_WFI : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_WFI:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__110=  (bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) . 
   (case w__0 of
     Machine => returnS () 
   | Supervisor => bindS      
(read_regS mstatus_ref) (\ (w__1 : riscv_sequential_types$Mstatus) . 
      if (((((get_Mstatus_TW w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
        handle_illegal () 
      else returnS () )
   | User => handle_illegal () 
   ))))`;


(*val execute_UTYPE : Machine_word.mword Machine_word.ty20 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.uop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_UTYPE:(20)words$word ->(5)words$word -> riscv_sequential_types$uop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rd op=   
 (let (off : riscv_sequential_types$xlenbits) =     
((EXTS (( 64 : int):sail_values$ii)
        ((concat_vec imm (vec_of_bits [B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0;B0]  :  12 words$word)
           :  32 words$word))
       :  64 words$word)) in bindS
   (case op of
     RISCV_LUI => returnS off
   | RISCV_AUIPC => bindS
      (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
      returnS ((add_vec w__0 off  :  64 words$word)))
   ) (\ (ret : riscv_sequential_types$xlenbits) . 
   wX ((regbits_to_regno rd)) ret)))`;


(*val execute_STORECON : bool -> bool -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.word_width -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_STORECON:bool -> bool ->(5)words$word ->(5)words$word -> riscv_sequential_types$word_width ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) aq rl rs2 rs1 width rd=  (bindS   
(speculate_conditional_success () ) (\ (w__0 : bool) . 
   let (status : 1 riscv_sequential_types$bits) =     
(if w__0 then (vec_of_bits [B0]  :  1 words$word)
     else (vec_of_bits [B1]  :  1 words$word)) in seqS   
(wX ((regbits_to_regno rd)) ((EXTZ (( 64 : int):sail_values$ii) status  :  64 words$word)))   
(if (((status = (vec_of_bits [B1]  :  1 words$word)))) then returnS () 
   else bindS
     (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (vaddr : riscv_sequential_types$xlenbits) .  bindS     
(translateAddr vaddr Write Data) (\ (w__1 : riscv_sequential_types$TR_Result) . 
     (case w__1 of
       TR_Failure (e) => handle_mem_exception vaddr e
     | TR_Address (addr) => bindS
        (case width of
          WORD => mem_write_ea addr (( 4 : int):sail_values$ii) aq rl T
        | DOUBLE => mem_write_ea addr (( 8 : int):sail_values$ii) aq rl T
        | _ => internal_error "STORECON expected word or double"
        ) (\ (eares : unit riscv_sequential_types$MemoryOpResult) . 
        (case eares of
          MemException (e) => handle_mem_exception addr e
        | MemValue (_) => bindS
           (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val .  bindS
           (case width of
             WORD =>
              mem_write_value addr (( 4 : int):sail_values$ii) ((subrange_vec_dec rs2_val (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word))
                aq rl T
           | DOUBLE => mem_write_value addr (( 8 : int):sail_values$ii) rs2_val aq rl T
           | _ => internal_error "STORECON expected word or double"
           ) (\ (res : unit riscv_sequential_types$MemoryOpResult) . 
           (case res of
             MemValue (_) => returnS () 
           | MemException (e) => handle_mem_exception addr e
           )))
        ))
     )))))))`;


(*val execute_STORE : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.word_width -> bool -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_STORE:(12)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$word_width -> bool -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rs2 rs1 width aq rl=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let (vaddr : riscv_sequential_types$xlenbits) = ((add_vec w__0 ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word))  :  64 words$word)) in bindS   
(translateAddr vaddr Write Data) (\ (w__1 : riscv_sequential_types$TR_Result) . 
   (case w__1 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) => bindS
      (case width of
        BYTE => mem_write_ea addr (( 1 : int):sail_values$ii) aq rl F
      | HALF => mem_write_ea addr (( 2 : int):sail_values$ii) aq rl F
      | WORD => mem_write_ea addr (( 4 : int):sail_values$ii) aq rl F
      | DOUBLE => mem_write_ea addr (( 8 : int):sail_values$ii) aq rl F
      ) (\ (eares : unit riscv_sequential_types$MemoryOpResult) . 
      (case eares of
        MemException (e) => handle_mem_exception addr e
      | MemValue (_) => bindS
         (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val .  bindS
         (case width of
           BYTE =>
            mem_write_value addr (( 1 : int):sail_values$ii) ((subrange_vec_dec rs2_val (( 7 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  8 words$word)) aq
              rl F
         | HALF =>
            mem_write_value addr (( 2 : int):sail_values$ii) ((subrange_vec_dec rs2_val (( 15 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  16 words$word)) aq
              rl F
         | WORD =>
            mem_write_value addr (( 4 : int):sail_values$ii) ((subrange_vec_dec rs2_val (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) aq
              rl F
         | DOUBLE => mem_write_value addr (( 8 : int):sail_values$ii) rs2_val aq rl F
         ) (\ (res : unit riscv_sequential_types$MemoryOpResult) . 
         (case res of
           MemValue (_) => returnS () 
         | MemException (e) => handle_mem_exception addr e
         )))
      ))
   )))))`;


(*val execute_SRET : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_SRET:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__108=  (bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) . 
   (case w__0 of
     User => handle_illegal () 
   | Supervisor => bindS      
(read_regS mstatus_ref) (\ (w__1 : riscv_sequential_types$Mstatus) . 
      if (((((get_Mstatus_TSR w__1  :  1 words$word)) = ((bool_to_bits T  :  1 words$word))))) then
        handle_illegal () 
      else bindS        
(read_regS cur_privilege_ref) (\ (w__2 : riscv_sequential_types$Privilege) .  bindS
        (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__3 :  64 words$word) .  bindS
        (handle_exception w__2 (CTL_SRET () ) w__3  : ( 64 words$word) riscv_sequential_types$M) (\ (w__4 : riscv_sequential_types$xlenbits) . 
        write_regS nextPC_ref w__4))))
   | Machine => bindS      
(read_regS cur_privilege_ref) (\ (w__5 : riscv_sequential_types$Privilege) .  bindS
      (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__6 :  64 words$word) .  bindS
      (handle_exception w__5 (CTL_SRET () ) w__6  : ( 64 words$word) riscv_sequential_types$M) (\ (w__7 : riscv_sequential_types$xlenbits) . 
      write_regS nextPC_ref w__7)))
   ))))`;


(*val execute_SHIFTW : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.sop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_SHIFTW:(5)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$sop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) shamt rs1 rd op=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in
   let (result : 32 riscv_sequential_types$bits) =     
((case op of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  :  32 words$word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  :  32 words$word)
     | RISCV_SRAI => (shift_right_arith32 rs1_val shamt  :  32 words$word)
     )) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):sail_values$ii) result  :  64 words$word)))))`;


(*val execute_SHIFTIOP : Machine_word.mword Machine_word.ty6 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.sop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_SHIFTIOP:(6)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$sop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) shamt rs1 rd op=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val . 
   let (result : riscv_sequential_types$xlenbits) =     
((case op of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  :  64 words$word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  :  64 words$word)
     | RISCV_SRAI => (shift_right_arith64 rs1_val shamt  :  64 words$word)
     )) in
   wX ((regbits_to_regno rd)) result)))`;


(*val execute_SFENCE_VMA : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_SFENCE_VMA:(5)words$word ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs1 rs2=  (bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) . 
   if (((((privLevel_to_bits w__0  :  2 words$word)) = ((privLevel_to_bits User  :  2 words$word)))))
   then
     handle_illegal () 
   else bindS     
(read_regS mstatus_ref) (\ (w__1 : riscv_sequential_types$Mstatus) .  bindS     
(read_regS mstatus_ref) (\ (w__2 : riscv_sequential_types$Mstatus) . 
     let p__104 =
       (architecture ((get_Mstatus_SXL w__1  :  2 words$word)), (get_Mstatus_TVM w__2  :  1 words$word)) in
     (case p__104 of
       (SOME (RV64), v_0) =>
        if (((v_0 = ((bool_to_bits T  :  1 words$word))))) then handle_illegal () 
        else bindS
          (if (((((regbits_to_regno rs1)) = (( 0 : int):sail_values$ii)))) then returnS NONE
           else bindS
             (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__3 :  64 words$word) . 
             returnS (SOME ((subrange_vec_dec w__3 (( 38 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  39 words$word))))) (\ (addr :
             riscv_sequential_types$vaddr39 option) .  bindS
          (if (((((regbits_to_regno rs2)) = (( 0 : int):sail_values$ii)))) then returnS NONE
           else bindS
             (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__4 :  64 words$word) . 
             returnS (SOME ((subrange_vec_dec w__4 (( 15 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  16 words$word))))) (\ (asid :
             riscv_sequential_types$asid64 option) . 
          flushTLB asid addr))
     | (g__102, g__103) => internal_error "unimplemented sfence architecture"
     ))))))`;


(*val execute_RTYPEW : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.ropw -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_RTYPEW:(5)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$ropw ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd op=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in
   let (result : 32 riscv_sequential_types$bits) =     
((case op of
       RISCV_ADDW => (add_vec rs1_val rs2_val  :  32 words$word)
     | RISCV_SUBW => (sub_vec rs1_val rs2_val  :  32 words$word)
     | RISCV_SLLW =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 4 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  5 words$word))
          :  32 words$word)
     | RISCV_SRLW =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 4 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  5 words$word))
          :  32 words$word)
     | RISCV_SRAW =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec rs2_val (( 4 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  5 words$word))
          :  32 words$word)
     )) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):sail_values$ii) result  :  64 words$word))))))`;


(*val execute_RTYPE : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.rop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_RTYPE:(5)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$rop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd op=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val .  bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val . 
   let (result : riscv_sequential_types$xlenbits) =     
((case op of
       RISCV_ADD => (add_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_SUB => (sub_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_SLL =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
          :  64 words$word)
     | RISCV_SLT =>
        (EXTZ (( 64 : int):sail_values$ii) ((bool_to_bits ((((integer_word$w2i rs1_val) < (integer_word$w2i rs2_val))))  :  1 words$word))  :  64 words$word)
     | RISCV_SLTU =>
        (EXTZ (( 64 : int):sail_values$ii) ((bool_to_bits ((((lem$w2ui rs1_val) < (lem$w2ui rs2_val))))  :  1 words$word))  :  64 words$word)
     | RISCV_XOR => (xor_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_SRL =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
          :  64 words$word)
     | RISCV_SRA =>
        (shift_right_arith64 rs1_val ((subrange_vec_dec rs2_val (( 5 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  6 words$word))
          :  64 words$word)
     | RISCV_OR => (or_vec rs1_val rs2_val  :  64 words$word)
     | RISCV_AND => (and_vec rs1_val rs2_val  :  64 words$word)
     )) in
   wX ((regbits_to_regno rd)) result))))`;


(*val execute_RISCV_JALR : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_RISCV_JALR:(12)words$word ->(5)words$word ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rs1 rd=  (bindS
   (read_regS nextPC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) .  bindS (seqS   
(wX ((regbits_to_regno rd)) w__0)
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M)) (\ (w__1 :  64 words$word) . 
   let (newPC : riscv_sequential_types$xlenbits) = ((add_vec w__1 ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word))  :  64 words$word)) in
   write_regS
     nextPC_ref
     ((concat_vec ((subrange_vec_dec newPC (( 63 : int):sail_values$ii) (( 1 : int):sail_values$ii)  :  63 words$word))
         (vec_of_bits [B0]  :  1 words$word)
        :  64 words$word))))))`;


(*val execute_RISCV_JAL : Machine_word.mword Machine_word.ty21 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_RISCV_JAL:(21)words$word ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rd=  (bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (pc : riscv_sequential_types$xlenbits) .  bindS
   (read_regS nextPC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) .  seqS   
(wX ((regbits_to_regno rd)) w__0)   
(let (offset : riscv_sequential_types$xlenbits) = ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word)) in
   write_regS nextPC_ref ((add_vec pc offset  :  64 words$word)))))))`;


(*val execute_REMW : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_REMW:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in
   let (rs1_int : sail_values$ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : sail_values$ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (r : sail_values$ii) = (if (((rs2_int = (( 0 : int):sail_values$ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):sail_values$ii) ((to_bits (( 32 : int):sail_values$ii) r  :  32 words$word))  :  64 words$word))))))`;


(*val execute_REM : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_REM:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val .  bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val . 
   let (rs1_int : sail_values$ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : sail_values$ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (r : sail_values$ii) = (if (((rs2_int = (( 0 : int):sail_values$ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
   wX ((regbits_to_regno rd)) ((to_bits xlen r  :  64 words$word))))))`;


(*val execute_NOP : unit -> unit*)

 val _ = Define `
 ((execute_NOP:unit -> unit) g__111=  () )`;


(*val execute_MULW : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_MULW:(5)words$word ->(5)words$word ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in
   let (rs1_int : sail_values$ii) = (integer_word$w2i rs1_val) in
   let (rs2_int : sail_values$ii) = (integer_word$w2i rs2_val) in
   let result32 =     
((subrange_vec_dec ((to_bits (( 64 : int):sail_values$ii) ((rs1_int * rs2_int))  :  64 words$word)) (( 31 : int):sail_values$ii)
        (( 0 : int):sail_values$ii)
       :  32 words$word)) in
   let (result : riscv_sequential_types$xlenbits) = ((EXTS (( 64 : int):sail_values$ii) result32  :  64 words$word)) in
   wX ((regbits_to_regno rd)) result))))`;


(*val execute_MUL : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> bool -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_MUL:(5)words$word ->(5)words$word ->(5)words$word -> bool -> bool -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd high signed1 signed2=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val .  bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val . 
   let (rs1_int : sail_values$ii) = (if signed1 then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : sail_values$ii) = (if signed2 then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let result128 = ((to_bits (( 128 : int):sail_values$ii) ((rs1_int * rs2_int))  :  128 words$word)) in
   let result =     
(if high then (subrange_vec_dec result128 (( 127 : int):sail_values$ii) (( 64 : int):sail_values$ii)  :  64 words$word)
     else (subrange_vec_dec result128 (( 63 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  64 words$word)) in
   wX ((regbits_to_regno rd)) result))))`;


(*val execute_MRET : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_MRET:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__107=  (bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) . 
   if (((((privLevel_to_bits w__0  :  2 words$word)) = ((privLevel_to_bits Machine  :  2 words$word)))))
   then bindS     
(read_regS cur_privilege_ref) (\ (w__1 : riscv_sequential_types$Privilege) .  bindS
     (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__2 :  64 words$word) .  bindS
     (handle_exception w__1 (CTL_MRET () ) w__2  : ( 64 words$word) riscv_sequential_types$M) (\ (w__3 : riscv_sequential_types$xlenbits) . 
     write_regS nextPC_ref w__3)))
   else handle_illegal () )))`;


(*val execute_LOADRES : bool -> bool -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.word_width -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_LOADRES:bool -> bool ->(5)words$word -> riscv_sequential_types$word_width ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) aq rl rs1 width rd=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (vaddr : riscv_sequential_types$xlenbits) .  bindS   
(translateAddr vaddr Read Data) (\ (w__0 : riscv_sequential_types$TR_Result) . 
   (case w__0 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case width of
        WORD => bindS
         (mem_read addr (( 4 : int):sail_values$ii) aq rl T  : ( ( 32 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__1 : ( 32 words$word)
           riscv_sequential_types$MemoryOpResult) . 
         process_load rd addr w__1 F)
      | DOUBLE => bindS
         (mem_read addr (( 8 : int):sail_values$ii) aq rl T  : ( ( 64 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__2 : ( 64 words$word)
           riscv_sequential_types$MemoryOpResult) . 
         process_load rd addr w__2 F)
      | _ => internal_error "LOADRES expected WORD or DOUBLE"
      )
   )))))`;


(*val execute_LOAD : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> Riscv_sequential_types.word_width -> bool -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_LOAD:(12)words$word ->(5)words$word ->(5)words$word -> bool -> riscv_sequential_types$word_width -> bool -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rs1 rd is_unsigned width aq rl=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let (vaddr : riscv_sequential_types$xlenbits) = ((add_vec w__0 ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word))  :  64 words$word)) in bindS   
(translateAddr vaddr Read Data) (\ (w__1 : riscv_sequential_types$TR_Result) . 
   (case w__1 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case width of
        BYTE => bindS
         (mem_read addr (( 1 : int):sail_values$ii) aq rl F  : ( ( 8 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__2 : ( 8 words$word)
           riscv_sequential_types$MemoryOpResult) . 
         process_load rd vaddr w__2 is_unsigned)
      | HALF => bindS
         (mem_read addr (( 2 : int):sail_values$ii) aq rl F  : ( ( 16 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__3 : ( 16 words$word)
           riscv_sequential_types$MemoryOpResult) . 
         process_load rd vaddr w__3 is_unsigned)
      | WORD => bindS
         (mem_read addr (( 4 : int):sail_values$ii) aq rl F  : ( ( 32 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__4 : ( 32 words$word)
           riscv_sequential_types$MemoryOpResult) . 
         process_load rd vaddr w__4 is_unsigned)
      | DOUBLE => bindS
         (mem_read addr (( 8 : int):sail_values$ii) aq rl F  : ( ( 64 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__5 : ( 64 words$word)
           riscv_sequential_types$MemoryOpResult) . 
         process_load rd vaddr w__5 is_unsigned)
      )
   )))))`;


(*val execute_ITYPE : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.iop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_ITYPE:(12)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$iop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rs1 rd op=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val . 
   let (immext : riscv_sequential_types$xlenbits) = ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word)) in
   let (result : riscv_sequential_types$xlenbits) =     
((case op of
       RISCV_ADDI => (add_vec rs1_val immext  :  64 words$word)
     | RISCV_SLTI =>
        (EXTZ (( 64 : int):sail_values$ii) ((bool_to_bits ((((integer_word$w2i rs1_val) < (integer_word$w2i immext))))  :  1 words$word))  :  64 words$word)
     | RISCV_SLTIU =>
        (EXTZ (( 64 : int):sail_values$ii) ((bool_to_bits ((((lem$w2ui rs1_val) < (lem$w2ui immext))))  :  1 words$word))  :  64 words$word)
     | RISCV_XORI => (xor_vec rs1_val immext  :  64 words$word)
     | RISCV_ORI => (or_vec rs1_val immext  :  64 words$word)
     | RISCV_ANDI => (and_vec rs1_val immext  :  64 words$word)
     )) in
   wX ((regbits_to_regno rd)) result)))`;


(*val execute_ILLEGAL : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_ILLEGAL:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__112=  (handle_illegal () ))`;


(*val execute_FENCEI : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_FENCEI:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__105=  (MEM_fence_i () ))`;


(*val execute_FENCE : Machine_word.mword Machine_word.ty4 -> Machine_word.mword Machine_word.ty4 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_FENCE:(4)words$word ->(4)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) pred succ= 
  ((case (pred, succ) of
         (b__0, b__1) =>
   if ((((((b__0 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word)))) /\
           (((b__1 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word))))))) then
     MEM_fence_rw_rw ()  else
     if ((((((b__0 = (vec_of_bits [B0;B0;B1;B0] : 4 words$word)))) /\
             (((b__1 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word))))))) then
       MEM_fence_r_rw ()  else
       if ((((((b__0 = (vec_of_bits [B0;B0;B1;B0] : 4 words$word)))) /\
               (((b__1 = (vec_of_bits [B0;B0;B1;B0] : 4 words$word))))))) then
         MEM_fence_r_r ()  else
         if ((((((b__0 = (vec_of_bits [B0;B0;B1;B1] : 4 words$word)))) /\
                 (((b__1 = (vec_of_bits [B0;B0;B0;B1] : 4 words$word))))))) then
           MEM_fence_rw_w ()  else MEM_fence_w_w () 
   )))`;


(*val execute_ECALL : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_ECALL:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__106=  (bindS   
(read_regS cur_privilege_ref) (\ (w__0 : riscv_sequential_types$Privilege) . 
   let (t : riscv_sequential_types$sync_exception) =     
(<| sync_exception_trap :=
          ((case w__0 of
             User => E_U_EnvCall
           | Supervisor => E_S_EnvCall
           | Machine => E_M_EnvCall
           )); 
        sync_exception_excinfo := NONE |>) in bindS   
(read_regS cur_privilege_ref) (\ (w__1 : riscv_sequential_types$Privilege) .  bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__2 :  64 words$word) .  bindS
   (handle_exception w__1 (CTL_TRAP t) w__2  : ( 64 words$word) riscv_sequential_types$M) (\ (w__3 : riscv_sequential_types$xlenbits) . 
   write_regS nextPC_ref w__3))))))`;


(*val execute_EBREAK : unit -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_EBREAK:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) g__109=  (throwS (Error_EBREAK () )))`;


(*val execute_DIVW : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_DIVW:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let rs1_val = ((subrange_vec_dec w__0 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 :  64 words$word) . 
   let rs2_val = ((subrange_vec_dec w__1 (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) in
   let (rs1_int : sail_values$ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : sail_values$ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (q : sail_values$ii) = (if (((rs2_int = (( 0 : int):sail_values$ii)))) then ((( 0 : int)-( 1 : int)):sail_values$ii) else hardware_quot rs1_int rs2_int) in
   let (q' : sail_values$ii) =     
(if (((s /\ ((q > ((((pow2 (( 31 : int):sail_values$ii))) - (( 1 : int):sail_values$ii)))))))) then
       (( 0 : int):sail_values$ii) - ((ex_int ((pow0 (( 2 : int):sail_values$ii) (( 31 : int):sail_values$ii)))))
     else q) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 : int):sail_values$ii) ((to_bits (( 32 : int):sail_values$ii) q'  :  32 words$word))  :  64 words$word))))))`;


(*val execute_DIV : Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_DIV:(5)words$word ->(5)words$word ->(5)words$word -> bool ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) rs2 rs1 rd s=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val .  bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val . 
   let (rs1_int : sail_values$ii) = (if s then integer_word$w2i rs1_val else lem$w2ui rs1_val) in
   let (rs2_int : sail_values$ii) = (if s then integer_word$w2i rs2_val else lem$w2ui rs2_val) in
   let (q : sail_values$ii) = (if (((rs2_int = (( 0 : int):sail_values$ii)))) then ((( 0 : int)-( 1 : int)):sail_values$ii) else hardware_quot rs1_int rs2_int) in
   let (q' : sail_values$ii) = (if (((s /\ ((q > xlen_max_signed))))) then xlen_min_signed else q) in
   wX ((regbits_to_regno rd)) ((to_bits xlen q'  :  64 words$word))))))`;


(*val execute_C_ADDIW : Machine_word.mword Machine_word.ty6 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_C_ADDIW:(6)words$word ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rsd=   
 (let (imm : 32 riscv_sequential_types$bits) = ((EXTS (( 32 : int):sail_values$ii) imm  :  32 words$word)) in bindS
   (rX ((regbits_to_regno rsd))  : ( 64 words$word) riscv_sequential_types$M) (\ rs_val . 
   let (res : 32 riscv_sequential_types$bits) =     
((add_vec ((subrange_vec_dec rs_val (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word)) imm  :  32 words$word)) in
   wX ((regbits_to_regno rsd)) ((EXTS (( 64 : int):sail_values$ii) res  :  64 words$word)))))`;


(*val execute_CSR : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> bool -> Riscv_sequential_types.csrop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_CSR:(12)words$word ->(5)words$word ->(5)words$word -> bool -> riscv_sequential_types$csrop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) csr rs1 rd is_imm op=  (bindS
   (if is_imm then returnS ((EXTZ (( 64 : int):sail_values$ii) rs1  :  64 words$word))
    else (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M)) (\ (rs1_val : riscv_sequential_types$xlenbits) . 
   let (isWrite : bool) =     
((case op of
       CSRRW => T
     | _ => if is_imm then (((lem$w2ui rs1_val)) <> (( 0 : int):sail_values$ii)) else (((lem$w2ui rs1)) <> (( 0 : int):sail_values$ii))
     )) in bindS   
(read_regS cur_privilege_ref) (\ (w__1 : riscv_sequential_types$Privilege) .  bindS   
(check_CSR csr w__1 isWrite) (\ (w__2 : bool) . 
   if ((~ w__2)) then handle_illegal () 
   else bindS
     (readCSR csr  : ( 64 words$word) riscv_sequential_types$M) (\ csr_val .  seqS
     (if isWrite then
        let (new_val : riscv_sequential_types$xlenbits) =          
((case op of
            CSRRW => rs1_val
          | CSRRS => (or_vec csr_val rs1_val  :  64 words$word)
          | CSRRC => (and_vec csr_val ((not_vec rs1_val  :  64 words$word))  :  64 words$word)
          )) in
        writeCSR csr new_val
      else returnS () )     
(wX ((regbits_to_regno rd)) csr_val)))))))`;


(*val execute_BTYPE : Machine_word.mword Machine_word.ty13 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.bop -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_BTYPE:(13)words$word ->(5)words$word ->(5)words$word -> riscv_sequential_types$bop ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rs2 rs1 op=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ rs1_val .  bindS
   (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ rs2_val . 
   let (taken : bool) =     
((case op of
       RISCV_BEQ => (rs1_val = rs2_val)
     | RISCV_BNE => (rs1_val <> rs2_val)
     | RISCV_BLT => ((integer_word$w2i rs1_val) < (integer_word$w2i rs2_val))
     | RISCV_BGE => ((integer_word$w2i rs1_val) >= (integer_word$w2i rs2_val))
     | RISCV_BLTU => ((lem$w2ui rs1_val) < (lem$w2ui rs2_val))
     | RISCV_BGEU => ((lem$w2ui rs1_val) >= (lem$w2ui rs2_val))
     )) in
   if taken then bindS
     (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
     write_regS nextPC_ref ((add_vec w__0 ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word))  :  64 words$word)))
   else returnS () ))))`;


(*val execute_AMO : Riscv_sequential_types.amoop -> bool -> bool -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.word_width -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_AMO:riscv_sequential_types$amoop -> bool -> bool ->(5)words$word ->(5)words$word -> riscv_sequential_types$word_width ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) op aq rl rs2 rs1 width rd=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (vaddr : riscv_sequential_types$xlenbits) .  bindS   
(translateAddr vaddr ReadWrite Data) (\ (w__0 : riscv_sequential_types$TR_Result) . 
   (case w__0 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) => bindS
      (case width of
        WORD => mem_write_ea addr (( 4 : int):sail_values$ii) (((aq /\ rl))) rl T
      | DOUBLE => mem_write_ea addr (( 8 : int):sail_values$ii) (((aq /\ rl))) rl T
      | _ => internal_error "AMO expected WORD or DOUBLE"
      ) (\ (eares : unit riscv_sequential_types$MemoryOpResult) . 
      (case eares of
        MemException (e) => handle_mem_exception addr e
      | MemValue (_) => bindS
         (case width of
           WORD => bindS
            (mem_read addr (( 4 : int):sail_values$ii) aq (((aq /\ rl))) T  : ( ( 32 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__4 : ( 32 words$word)
              riscv_sequential_types$MemoryOpResult) . 
            returnS ((extend_value F w__4  : ( 64 words$word) riscv_sequential_types$MemoryOpResult)))
         | DOUBLE => bindS
            (mem_read addr (( 8 : int):sail_values$ii) aq (((aq /\ rl))) T  : ( ( 64 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__5 : ( 64 words$word)
              riscv_sequential_types$MemoryOpResult) . 
            returnS ((extend_value F w__5  : ( 64 words$word) riscv_sequential_types$MemoryOpResult)))
         | _ => (internal_error "AMO expected WORD or DOUBLE"  : ( ( 64 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M)
         ) (\ (rval : riscv_sequential_types$xlenbits riscv_sequential_types$MemoryOpResult) . 
         (case rval of
           MemException (e) => handle_mem_exception addr e
         | MemValue (loaded) => bindS
            (rX ((regbits_to_regno rs2))  : ( 64 words$word) riscv_sequential_types$M) (\ (rs2_val : riscv_sequential_types$xlenbits) . 
            let (result : riscv_sequential_types$xlenbits) =              
((case op of
                AMOSWAP => rs2_val
              | AMOADD => (add_vec rs2_val loaded  :  64 words$word)
              | AMOXOR => (xor_vec rs2_val loaded  :  64 words$word)
              | AMOAND => (and_vec rs2_val loaded  :  64 words$word)
              | AMOOR => (or_vec rs2_val loaded  :  64 words$word)
              | AMOMIN => (vector64 ((int_min ((integer_word$w2i rs2_val)) ((integer_word$w2i loaded))))  :  64 words$word)
              | AMOMAX => (vector64 ((int_max ((integer_word$w2i rs2_val)) ((integer_word$w2i loaded))))  :  64 words$word)
              | AMOMINU => (vector64 ((int_min ((lem$w2ui rs2_val)) ((lem$w2ui loaded))))  :  64 words$word)
              | AMOMAXU => (vector64 ((int_max ((lem$w2ui rs2_val)) ((lem$w2ui loaded))))  :  64 words$word)
              )) in bindS
            (case width of
              WORD =>
               mem_write_value addr (( 4 : int):sail_values$ii) ((subrange_vec_dec result (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word))
                 (((aq /\ rl))) rl T
            | DOUBLE => mem_write_value addr (( 8 : int):sail_values$ii) result (((aq /\ rl))) rl T
            | _ => internal_error "AMO expected WORD or DOUBLE"
            ) (\ (wval : unit riscv_sequential_types$MemoryOpResult) . 
            (case wval of
              MemValue (_) => wX ((regbits_to_regno rd)) loaded
            | MemException (e) => handle_mem_exception addr e
            )))
         ))
      ))
   )))))`;


(*val execute_ADDIW : Machine_word.mword Machine_word.ty12 -> Machine_word.mword Machine_word.ty5 -> Machine_word.mword Machine_word.ty5 -> Riscv_sequential_types.M unit*)

 val _ = Define `
 ((execute_ADDIW:(12)words$word ->(5)words$word ->(5)words$word ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) imm rs1 rd=  (bindS
   (rX ((regbits_to_regno rs1))  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 :  64 words$word) . 
   let (result : riscv_sequential_types$xlenbits) = ((add_vec ((EXTS (( 64 : int):sail_values$ii) imm  :  64 words$word)) w__0  :  64 words$word)) in
   wX ((regbits_to_regno rd))
     ((EXTS (( 64 : int):sail_values$ii) ((subrange_vec_dec result (( 31 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  32 words$word))  :  64 words$word)))))`;


 val execute_defn = Hol_defn "execute" `
 ((execute:riscv_sequential_types$ast ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((unit),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) merge_var=   
 ((case merge_var of
     C_ADDI4SPN (rdc,nzimm) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((concat_vec (vec_of_bits [B0;B0]  :  2 words$word)
           ((concat_vec nzimm (vec_of_bits [B0;B0]  :  2 words$word)  :  10 words$word))
          :  12 words$word)) in
      let rd = ((creg2reg_bits rdc  :  5 words$word)) in
      execute (ITYPE (imm,sp,rd,RISCV_ADDI))
   | C_LW (uimm,rsc,rdc) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  7 words$word))
          :  12 words$word)) in
      let rd = ((creg2reg_bits rdc  :  5 words$word)) in
      let rs = ((creg2reg_bits rsc  :  5 words$word)) in
      execute (LOAD (imm,rs,rd,F,WORD,F,F))
   | C_LD (uimm,rsc,rdc) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  8 words$word))
          :  12 words$word)) in
      let rd = ((creg2reg_bits rdc  :  5 words$word)) in
      let rs = ((creg2reg_bits rsc  :  5 words$word)) in
      execute (LOAD (imm,rs,rd,F,DOUBLE,F,F))
   | C_SW (uimm,rsc1,rsc2) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  7 words$word))
          :  12 words$word)) in
      let rs1 = ((creg2reg_bits rsc1  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rsc2  :  5 words$word)) in
      execute (STORE (imm,rs2,rs1,WORD,F,F))
   | C_SD (uimm,rsc1,rsc2) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  8 words$word))
          :  12 words$word)) in
      let rs1 = ((creg2reg_bits rsc1  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rsc2  :  5 words$word)) in
      execute (STORE (imm,rs2,rs1,DOUBLE,F,F))
   | C_ADDI (nzi,rsd) =>
      let (imm : 12 riscv_sequential_types$bits) = ((EXTS (( 12 : int):sail_values$ii) nzi  :  12 words$word)) in
      execute (ITYPE (imm,rsd,rsd,RISCV_ADDI))
   | C_JAL (imm) =>
      execute
        (RISCV_JAL ((EXTS (( 21 : int):sail_values$ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  12 words$word))
                      :  21 words$word),ra))
   | C_LI (imm,rd) =>
      let (imm : 12 riscv_sequential_types$bits) = ((EXTS (( 12 : int):sail_values$ii) imm  :  12 words$word)) in
      execute (ITYPE (imm,zreg,rd,RISCV_ADDI))
   | C_ADDI16SP (imm) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTS (( 12 : int):sail_values$ii) ((concat_vec imm (vec_of_bits [B0;B0;B0;B0]  :  4 words$word)  :  10 words$word))
          :  12 words$word)) in
      execute (ITYPE (imm,sp,sp,RISCV_ADDI))
   | C_LUI (imm,rd) =>
      let (res : 20 riscv_sequential_types$bits) = ((EXTS (( 20 : int):sail_values$ii) imm  :  20 words$word)) in
      execute (UTYPE (res,rd,RISCV_LUI))
   | C_SRLI (shamt,rsd) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SRLI))
   | C_SRAI (shamt,rsd) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SRAI))
   | C_ANDI (imm,rsd) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      execute (ITYPE ((EXTS (( 12 : int):sail_values$ii) imm  :  12 words$word),rsd,rsd,RISCV_ANDI))
   | C_SUB (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_SUB))
   | C_XOR (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_XOR))
   | C_OR (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_OR))
   | C_AND (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_AND))
   | C_SUBW (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPEW (rs2,rsd,rsd,RISCV_SUBW))
   | C_ADDW (rsd,rs2) =>
      let rsd = ((creg2reg_bits rsd  :  5 words$word)) in
      let rs2 = ((creg2reg_bits rs2  :  5 words$word)) in
      execute (RTYPEW (rs2,rsd,rsd,RISCV_ADDW))
   | C_J (imm) =>
      execute
        (RISCV_JAL ((EXTS (( 21 : int):sail_values$ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  12 words$word))
                      :  21 words$word),zreg))
   | C_BEQZ (imm,rs) =>
      execute
        (BTYPE ((EXTS (( 13 : int):sail_values$ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  9 words$word))
                  :  13 words$word),zreg,(creg2reg_bits rs  :  5 words$word),RISCV_BEQ))
   | C_BNEZ (imm,rs) =>
      execute
        (BTYPE ((EXTS (( 13 : int):sail_values$ii) ((concat_vec imm (vec_of_bits [B0]  :  1 words$word)  :  9 words$word))
                  :  13 words$word),zreg,(creg2reg_bits rs  :  5 words$word),RISCV_BNE))
   | C_SLLI (shamt,rsd) => execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SLLI))
   | C_LWSP (uimm,rd) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  8 words$word))
          :  12 words$word)) in
      execute (LOAD (imm,sp,rd,F,WORD,F,F))
   | C_LDSP (uimm,rd) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  9 words$word))
          :  12 words$word)) in
      execute (LOAD (imm,sp,rd,F,DOUBLE,F,F))
   | C_SWSP (uimm,rs2) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0]  :  2 words$word)  :  8 words$word))
          :  12 words$word)) in
      execute (STORE (imm,rs2,sp,WORD,F,F))
   | C_SDSP (uimm,rs2) =>
      let (imm : 12 riscv_sequential_types$bits) =        
((EXTZ (( 12 : int):sail_values$ii) ((concat_vec uimm (vec_of_bits [B0;B0;B0]  :  3 words$word)  :  9 words$word))
          :  12 words$word)) in
      execute (STORE (imm,rs2,sp,DOUBLE,F,F))
   | C_JR (rs1) =>
      execute (RISCV_JALR ((EXTZ (( 12 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  12 words$word),rs1,zreg))
   | C_JALR (rs1) =>
      execute (RISCV_JALR ((EXTZ (( 12 : int):sail_values$ii) (vec_of_bits [B0]  :  1 words$word)  :  12 words$word),rs1,ra))
   | C_MV (rd,rs2) => execute (RTYPE (rs2,zreg,rd,RISCV_ADD))
   | C_ADD (rsd,rs2) => execute (RTYPE (rs2,rsd,rsd,RISCV_ADD))
   | UTYPE (imm,rd,op) => execute_UTYPE imm rd op
   | RISCV_JAL (imm,rd) => execute_RISCV_JAL imm rd
   | RISCV_JALR (imm,rs1,rd) => execute_RISCV_JALR imm rs1 rd
   | BTYPE (imm,rs2,rs1,op) => execute_BTYPE imm rs2 rs1 op
   | ITYPE (imm,rs1,rd,op) => execute_ITYPE imm rs1 rd op
   | SHIFTIOP (shamt,rs1,rd,op) => execute_SHIFTIOP shamt rs1 rd op
   | RTYPE (rs2,rs1,rd,op) => execute_RTYPE rs2 rs1 rd op
   | LOAD (imm,rs1,rd,is_unsigned,width,aq,rl) => execute_LOAD imm rs1 rd is_unsigned width aq rl
   | STORE (imm,rs2,rs1,width,aq,rl) => execute_STORE imm rs2 rs1 width aq rl
   | ADDIW (imm,rs1,rd) => execute_ADDIW imm rs1 rd
   | SHIFTW (shamt,rs1,rd,op) => execute_SHIFTW shamt rs1 rd op
   | RTYPEW (rs2,rs1,rd,op) => execute_RTYPEW rs2 rs1 rd op
   | MUL (rs2,rs1,rd,high,signed1,signed2) => execute_MUL rs2 rs1 rd high signed1 signed2
   | DIV0 (rs2,rs1,rd,s) => execute_DIV rs2 rs1 rd s
   | REM (rs2,rs1,rd,s) => execute_REM rs2 rs1 rd s
   | MULW (rs2,rs1,rd) => execute_MULW rs2 rs1 rd
   | DIVW (rs2,rs1,rd,s) => execute_DIVW rs2 rs1 rd s
   | REMW (rs2,rs1,rd,s) => execute_REMW rs2 rs1 rd s
   | FENCE (pred,succ) => execute_FENCE pred succ
   | FENCEI (g__105) => execute_FENCEI g__105
   | ECALL (g__106) => execute_ECALL g__106
   | MRET (g__107) => execute_MRET g__107
   | SRET (g__108) => execute_SRET g__108
   | EBREAK (g__109) => execute_EBREAK g__109
   | WFI (g__110) => execute_WFI g__110
   | SFENCE_VMA (rs1,rs2) => execute_SFENCE_VMA rs1 rs2
   | LOADRES (aq,rl,rs1,width,rd) => execute_LOADRES aq rl rs1 width rd
   | STORECON (aq,rl,rs2,rs1,width,rd) => execute_STORECON aq rl rs2 rs1 width rd
   | AMO (op,aq,rl,rs2,rs1,width,rd) => execute_AMO op aq rl rs2 rs1 width rd
   | CSR (csr,rs1,rd,is_imm,op) => execute_CSR csr rs1 rd is_imm op
   | NOP (g__111) => returnS ((execute_NOP g__111))
   | ILLEGAL (g__112) => execute_ILLEGAL g__112
   | C_ADDIW (imm,rsd) => execute_C_ADDIW imm rsd
   )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn execute_defn;

val _ = Define `
 ((print_insn:riscv_sequential_types$ast -> string) merge_var=   
 ((case merge_var of
     UTYPE (imm,rd,op) =>
      (case op of
        RISCV_LUI =>
         STRCAT "lui   "
           ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
      | RISCV_AUIPC =>
         STRCAT "auipc "
           ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
      )
   | RISCV_JAL (imm,rd) =>
      STRCAT "jal   "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
   | RISCV_JALR (imm,rs1,rd) =>
      STRCAT "jalr  "
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | BTYPE (imm,rs2,rs1,op) =>
      let (insn : string) =        
((case op of
          RISCV_BEQ => "beq   "
        | RISCV_BNE => "bne   "
        | RISCV_BLT => "blt   "
        | RISCV_BGE => "bge   "
        | RISCV_BLTU => "bltu  "
        | RISCV_BGEU => "bgeu  "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rs1))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs2)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | ITYPE (imm,rs1,rd,op) =>
      let (insn : string) =        
((case op of
          RISCV_ADDI => "addi  "
        | RISCV_SLTI => "slti  "
        | RISCV_SLTIU => "sltiu "
        | RISCV_XORI => "xori  "
        | RISCV_ORI => "ori   "
        | RISCV_ANDI => "andi  "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | SHIFTIOP (shamt,rs1,rd,op) =>
      let (insn : string) =        
((case op of   RISCV_SLLI => "slli  " | RISCV_SRLI => "srli  " | RISCV_SRAI => "srai  " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec shamt))))))))))
   | RTYPE (rs2,rs1,rd,op) =>
      let (insn : string) =        
((case op of
          RISCV_ADD => "add   "
        | RISCV_SUB => "sub   "
        | RISCV_SLL => "sll   "
        | RISCV_SLT => "slt   "
        | RISCV_SLTU => "sltu  "
        | RISCV_XOR => "xor   "
        | RISCV_SRL => "srl   "
        | RISCV_SRA => "sra   "
        | RISCV_OR => "or    "
        | RISCV_AND => "and   "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | LOAD (imm,rs1,rd,is_unsigned,width,aq,rl) =>
      let (insn : string) =        
((case (width, is_unsigned) of
          (BYTE, F) => "lb    "
        | (BYTE, T) => "lbu   "
        | (HALF, F) => "lh    "
        | (HALF, T) => "lhu   "
        | (WORD, F) => "lw    "
        | (WORD, T) => "lwu   "
        | (_, _) => "ld.bad "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | STORE (imm,rs2,rs1,width,aq,rl) =>
      let (insn : string) =        
((case width of
          BYTE => "sb    "
        | HALF => "sh    "
        | WORD => "sw    "
        | DOUBLE => "sd    "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rs2))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | ADDIW (imm,rs1,rd) =>
      STRCAT "addiw "
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec imm))))))))))
   | SHIFTW (shamt,rs1,rd,op) =>
      let (insn : string) =        
((case op of   RISCV_SLLI => "slli  " | RISCV_SRLI => "srli  " | RISCV_SRAI => "srai  " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((string_of_vec shamt))))))))))
   | RTYPEW (rs2,rs1,rd,op) =>
      let (insn : string) =        
((case op of
          RISCV_ADDW => "addw  "
        | RISCV_SUBW => "subw  "
        | RISCV_SLLW => "sllw  "
        | RISCV_SRLW => "srlw  "
        | RISCV_SRAW => "sraw  "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | MUL (rs2,rs1,rd,high,signed1,signed2) =>
      let (insn : string) =        
((case (high, signed1, signed2) of
          (F, T, T) => "mul   "
        | (T, T, T) => "mulh  "
        | (T, T, F) => "mulhsu "
        | (T, F, F) => "mulhu"
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | DIV0 (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "div   " else "divu  ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | REM (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "rem   " else "remu  ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | MULW (rs2,rs1,rd) =>
      STRCAT "mulw  "
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | DIVW (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "divw  " else "divuw ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | REMW (rs2,rs1,rd,s) =>
      let (insn : string) = (if s then "remw  " else "remuw ") in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | FENCE (pred,succ) => "fence"
   | FENCEI (g__93) => "fence.i"
   | ECALL (g__94) => "ecall"
   | MRET (g__95) => "mret"
   | SRET (g__96) => "sret"
   | EBREAK (g__97) => "ebreak"
   | WFI (g__98) => "wfi"
   | SFENCE_VMA (rs1,rs2) =>
      STRCAT "sfence.vma "
        ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))
   | LOADRES (aq,rl,rs1,width,rd) =>
      let (insn : string) =        
((case width of   WORD => "lr.w  " | DOUBLE => "lr.d  " | _ => "lr.bad " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((reg_name_abi rs1))))))
   | STORECON (aq,rl,rs2,rs1,width,rd) =>
      let (insn : string) =        
((case width of   WORD => "sc.w  " | DOUBLE => "sc.d  " | _ => "sc.bad " )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | AMO (op,aq,rl,rs2,rs1,width,rd) =>
      let (insn : string) =        
((case (op, width) of
          (AMOSWAP, WORD) => "amoswap.w "
        | (AMOADD, WORD) => "amoadd.w  "
        | (AMOXOR, WORD) => "amoxor.w  "
        | (AMOAND, WORD) => "amoand.w  "
        | (AMOOR, WORD) => "amoor.w   "
        | (AMOMIN, WORD) => "amomin.w  "
        | (AMOMAX, WORD) => "amomax.w  "
        | (AMOMINU, WORD) => "amominu.w "
        | (AMOMAXU, WORD) => "amomaxu.w "
        | (AMOSWAP, DOUBLE) => "amoswap.d "
        | (AMOADD, DOUBLE) => "amoadd.d  "
        | (AMOXOR, DOUBLE) => "amoxor.d  "
        | (AMOAND, DOUBLE) => "amoand.d  "
        | (AMOOR, DOUBLE) => "amoor.d   "
        | (AMOMIN, DOUBLE) => "amomin.d  "
        | (AMOMAX, DOUBLE) => "amomax.d  "
        | (AMOMINU, DOUBLE) => "amominu.d "
        | (AMOMAXU, DOUBLE) => "amomaxu.d "
        | (_, _) => "amo.bad "
        )) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi rs1)) ((STRCAT ", " ((reg_name_abi rs2))))))))))
   | CSR (csr,rs1,rd,is_imm,op) =>
      let (insn : string) =        
((case (op, is_imm) of
          (CSRRW, T) => "csrrwi "
        | (CSRRW, F) => "csrrw  "
        | (CSRRS, T) => "csrrsi "
        | (CSRRS, F) => "csrrs  "
        | (CSRRC, T) => "csrrci "
        | (CSRRC, F) => "csrrc  "
        )) in
      let (rs1_str : string) = (if is_imm then string_of_vec rs1 else reg_name_abi rs1) in
      STRCAT insn
        ((STRCAT ((reg_name_abi rd))
            ((STRCAT ", " ((STRCAT rs1_str ((STRCAT ", " ((csr_name csr))))))))))
   | NOP (g__99) => "nop"
   | ILLEGAL (g__100) => "illegal"
   | C_ADDI4SPN (rdc,nzimm) =>
      STRCAT "c.addi4spn "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rdc  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec nzimm))))))
   | C_LW (uimm,rsc,rdc) =>
      STRCAT "c.lw   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rdc  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_LD (uimm,rsc,rdc) =>
      STRCAT "c.ld   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rdc  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_SW (uimm,rsc1,rsc2) =>
      STRCAT "c.sw   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsc1  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc2  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_SD (uimm,rsc1,rsc2) =>
      STRCAT "c.sd   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsc1  :  5 words$word))))
            ((STRCAT ", "
                ((STRCAT ((reg_name_abi ((creg2reg_bits rsc2  :  5 words$word))))
                    ((STRCAT ", " ((string_of_vec uimm))))))))))
   | C_ADDI (nzi,rsd) =>
      STRCAT "c.addi   "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((string_of_vec nzi))))))
   | C_JAL (imm) => STRCAT "c.jal   " ((string_of_vec imm))
   | C_ADDIW (imm,rsd) =>
      STRCAT "c.addiw "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((string_of_vec imm))))))
   | C_LI (imm,rd) =>
      STRCAT "c.li  "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
   | C_ADDI16SP (imm) => STRCAT "c.addi16sp  " ((string_of_vec imm))
   | C_LUI (imm,rd) =>
      STRCAT "c.lui  "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec imm))))))
   | C_SRLI (shamt,rsd) =>
      STRCAT "c.srli  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec shamt))))))
   | C_SRAI (shamt,rsd) =>
      STRCAT "c.srai  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec shamt))))))
   | C_ANDI (imm,rsd) =>
      STRCAT "c.andi  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec imm))))))
   | C_SUB (rsd,rs2) =>
      STRCAT "c.sub  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_XOR (rsd,rs2) =>
      STRCAT "c.xor  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_OR (rsd,rs2) =>
      STRCAT "c.or   "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_AND (rsd,rs2) =>
      STRCAT "c.and  "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_SUBW (rsd,rs2) =>
      STRCAT "c.subw "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_ADDW (rsd,rs2) =>
      STRCAT "c.addw "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rsd  :  5 words$word))))
            ((STRCAT ", " ((reg_name_abi ((creg2reg_bits rs2  :  5 words$word))))))))
   | C_J (imm) => STRCAT "c.j    " ((string_of_vec imm))
   | C_BEQZ (imm,rs) =>
      STRCAT "c.beqz "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rs  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec imm))))))
   | C_BNEZ (imm,rs) =>
      STRCAT "c.bnez "
        ((STRCAT ((reg_name_abi ((creg2reg_bits rs  :  5 words$word))))
            ((STRCAT ", " ((string_of_vec imm))))))
   | C_SLLI (shamt,rsd) =>
      STRCAT "c.slli "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((string_of_vec shamt))))))
   | C_LWSP (uimm,rd) =>
      STRCAT "c.lwsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_LDSP (uimm,rd) =>
      STRCAT "c.ldsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_SWSP (uimm,rd) =>
      STRCAT "c.swsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_SDSP (uimm,rd) =>
      STRCAT "c.sdsp "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((string_of_vec uimm))))))
   | C_JR (rs1) => STRCAT "c.jr  " ((reg_name_abi rs1))
   | C_JALR (rs1) => STRCAT "c.jalr  " ((reg_name_abi rs1))
   | C_MV (rd,rs2) =>
      STRCAT "c.mv  "
        ((STRCAT ((reg_name_abi rd)) ((STRCAT ", " ((reg_name_abi rs2))))))
   | C_ADD (rsd,rs2) =>
      STRCAT "c.add  "
        ((STRCAT ((reg_name_abi rsd)) ((STRCAT ", " ((reg_name_abi rs2))))))
   )))`;


(*val isRVC : Machine_word.mword Machine_word.ty16 -> bool*)

val _ = Define `
 ((isRVC:(16)words$word -> bool) h=   
 (~ (((((subrange_vec_dec h (( 1 : int):sail_values$ii) (( 0 : int):sail_values$ii)  :  2 words$word)) = (vec_of_bits [B1;B1]  :  2 words$word))))))`;


(*val fetch : unit -> Riscv_sequential_types.M Riscv_sequential_types.FetchResult*)

val _ = Define `
 ((fetch:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((riscv_sequential_types$FetchResult),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__0 : riscv_sequential_types$xlenbits) .  bindS
   (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__1 : riscv_sequential_types$xlenbits) .  bindS   
(haveRVC () ) (\ (w__2 : bool) . 
   if ((((((((cast_unit_vec0 ((access_vec_dec w__0 (( 0 : int):sail_values$ii)))  :  1 words$word)) <> (vec_of_bits [B0]  :  1 words$word)))) \/ ((((((((cast_unit_vec0 ((access_vec_dec w__1 (( 1 : int):sail_values$ii)))  :  1 words$word)) <> (vec_of_bits [B0]  :  1 words$word)))) /\ ((~ w__2)))))))) then bindS
     (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__3 :  64 words$word) . 
     returnS (F_Error (E_Fetch_Addr_Align,w__3)))
   else bindS
     (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__4 :  64 words$word) .  bindS     
(translateAddr w__4 Execute Instruction) (\ (w__5 : riscv_sequential_types$TR_Result) . 
     (case w__5 of
       TR_Failure (e) => bindS
        (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__6 :  64 words$word) . 
        returnS (F_Error (e,w__6)))
     | TR_Address (ppclo) => bindS
        (checked_mem_read Instruction ppclo (( 2 : int):sail_values$ii)  : ( ( 16 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__7 : ( 16 words$word)
          riscv_sequential_types$MemoryOpResult) . 
        (case w__7 of
          MemException (e) => bindS
           (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__8 :  64 words$word) . 
           returnS (F_Error (E_Fetch_Access_Fault,w__8)))
        | MemValue (ilo) =>
           if ((isRVC ilo)) then returnS (F_RVC ilo)
           else bindS
             (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__9 :  64 words$word) . 
             let (PChi : riscv_sequential_types$xlenbits) = ((add_vec_int w__9 (( 2 : int):sail_values$ii)  :  64 words$word)) in bindS             
(translateAddr PChi Execute Instruction) (\ (w__10 : riscv_sequential_types$TR_Result) . 
             (case w__10 of
               TR_Failure (e) => returnS (F_Error (e,PChi))
             | TR_Address (ppchi) => bindS
                (checked_mem_read Instruction ppchi (( 2 : int):sail_values$ii)  : ( ( 16 words$word)riscv_sequential_types$MemoryOpResult) riscv_sequential_types$M) (\ (w__11 : ( 16 words$word)
                  riscv_sequential_types$MemoryOpResult) . 
                returnS ((case w__11 of
                           MemException (e) => F_Error (E_Fetch_Access_Fault,PChi)
                         | MemValue (ihi) => F_Base ((concat_vec ihi ilo  :  32 words$word))
                         )))
             )))
        ))
     ))))))))`;


(*val step : unit -> Riscv_sequential_types.M bool*)

val _ = Define `
 ((step:unit ->(riscv_sequential_types$regstate)state_monad$sequential_state ->(((bool),(riscv_sequential_types$exception))state_monad$result#(riscv_sequential_types$regstate)state_monad$sequential_state)set) () =  (bindS   
(read_regS mip_ref) (\ (w__0 : riscv_sequential_types$Minterrupts) .  bindS   
(read_regS mie_ref) (\ (w__1 : riscv_sequential_types$Minterrupts) .  bindS   
(read_regS mideleg_ref) (\ (w__2 : riscv_sequential_types$Minterrupts) .  bindS   
(curInterrupt w__0 w__1 w__2) (\ (w__3 :  ((riscv_sequential_types$InterruptType # riscv_sequential_types$Privilege))option) . 
   (case w__3 of
     SOME (intr,priv) =>
      let (_ : unit) = (print_bits "Handling interrupt: " ((interruptType_to_bits intr  :  4 words$word))) in seqS      
(handle_interrupt intr priv) (returnS F)
   | NONE => bindS
      (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__4 : riscv_sequential_types$xlenbits) . 
      let (_ : unit) = (print_bits "PC: " w__4) in bindS      
(fetch () ) (\ (w__5 : riscv_sequential_types$FetchResult) . 
      (case w__5 of
        F_Error (e,addr) => seqS (handle_mem_exception addr e) (returnS F)
      | F_RVC (h) =>
         (case ((decodeCompressed h)) of
           NONE =>
            let (_ : unit) = (prerr_endline ((STRCAT ((string_of_vec h)) " :  <no-decode>"))) in seqS            
(handle_decode_exception ((EXTZ (( 64 : int):sail_values$ii) h  :  64 words$word))) (returnS F)
         | SOME (ast) =>
            let (_ : unit) =              
(prerr_endline
                ((STRCAT ((string_of_vec h)) ((STRCAT " :  " ((print_insn ast))))))) in bindS
            (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__6 :  64 words$word) .  seqS (seqS            
(write_regS nextPC_ref ((add_vec_int w__6 (( 2 : int):sail_values$ii)  :  64 words$word)))            
(execute ast)) (returnS T))
         )
      | F_Base (w) =>
         (case ((decode w)) of
           NONE =>
            let (_ : unit) = (prerr_endline ((STRCAT ((string_of_vec w)) " :  <no-decode>"))) in seqS            
(handle_decode_exception ((EXTZ (( 64 : int):sail_values$ii) w  :  64 words$word))) (returnS F)
         | SOME (ast) =>
            let (_ : unit) =              
(prerr_endline
                ((STRCAT ((string_of_vec w)) ((STRCAT " :  " ((print_insn ast))))))) in bindS
            (read_regS PC_ref  : ( 64 words$word) riscv_sequential_types$M) (\ (w__8 :  64 words$word) .  seqS (seqS            
(write_regS nextPC_ref ((add_vec_int w__8 (( 4 : int):sail_values$ii)  :  64 words$word)))            
(execute ast)) (returnS T))
         )
      )))
   )))))))`;



val _ = export_theory()

