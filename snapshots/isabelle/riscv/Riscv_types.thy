chapter \<open>Generated by Lem from riscv_types.lem.\<close>

theory "Riscv_types" 

imports 
 	 Main
	 "Lem_pervasives_extra" 
	 "Sail_instr_kinds" 
	 "Sail_values" 
	 "Sail_operators_mwords" 
	 "Prompt_monad" 
	 "Prompt" 
	 "State" 

begin 

(*Generated by Sail from riscv.*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators_mwords*)
(*open import Prompt_monad*)
(*open import Prompt*)
(*open import State*)
type_synonym 'n bits =" ( 'n::len)Word.word "



type_synonym xlenbits  =" 64 bits "

type_synonym half  =" 16 bits "

type_synonym word0  =" 32 bits "

type_synonym 'n regno  =" int "

type_synonym regbits  =" 5 bits "

type_synonym cregbits  =" 3 bits "

type_synonym csreg  =" 12 bits "

type_synonym opcode  =" 7 bits "

type_synonym imm12  =" 12 bits "

type_synonym imm20  =" 20 bits "

type_synonym amo  =" 1 bits "

datatype Architecture = RV32 | RV64 | RV128



type_synonym arch_xlen  =" 2 bits "

type_synonym priv_level  =" 2 bits "

datatype Privilege = User | Supervisor | Machine



datatype AccessType = Read | Write | ReadWrite | Execute



datatype ReadType = Instruction | Data



type_synonym exc_code  =" 4 bits "

datatype ExceptionType =
  E_Fetch_Addr_Align
  | E_Fetch_Access_Fault
  | E_Illegal_Instr
  | E_Breakpoint
  | E_Load_Addr_Align
  | E_Load_Access_Fault
  | E_SAMO_Addr_Align
  | E_SAMO_Access_Fault
  | E_U_EnvCall
  | E_S_EnvCall
  | E_Reserved_10
  | E_M_EnvCall
  | E_Fetch_Page_Fault
  | E_Load_Page_Fault
  | E_Reserved_14
  | E_SAMO_Page_Fault



datatype InterruptType =
  I_U_Software
  | I_S_Software
  | I_M_Software
  | I_U_Timer
  | I_S_Timer
  | I_M_Timer
  | I_U_External
  | I_S_External
  | I_M_External



type_synonym tv_mode  =" 2 bits "

datatype TrapVectorMode = TV_Direct | TV_Vector | TV_Reserved



datatype exception  =
    Error_not_implemented " (string)" | Error_EBREAK " (unit)" | Error_internal_error " (unit)"



type_synonym ext_status  =" 2 bits "

datatype ExtStatus = Off | Initial | Clean | Dirty



type_synonym satp_mode  =" 4 bits "

datatype SATPMode = Sbare | Sv32 | Sv39



type_synonym csrRW  =" 2 bits "

datatype uop = RISCV_LUI | RISCV_AUIPC



datatype bop = RISCV_BEQ | RISCV_BNE | RISCV_BLT | RISCV_BGE | RISCV_BLTU | RISCV_BGEU



datatype iop = RISCV_ADDI | RISCV_SLTI | RISCV_SLTIU | RISCV_XORI | RISCV_ORI | RISCV_ANDI



datatype sop = RISCV_SLLI | RISCV_SRLI | RISCV_SRAI



datatype rop =
  RISCV_ADD
  | RISCV_SUB
  | RISCV_SLL
  | RISCV_SLT
  | RISCV_SLTU
  | RISCV_XOR
  | RISCV_SRL
  | RISCV_SRA
  | RISCV_OR
  | RISCV_AND



datatype ropw = RISCV_ADDW | RISCV_SUBW | RISCV_SLLW | RISCV_SRLW | RISCV_SRAW



datatype amoop = AMOSWAP | AMOADD | AMOXOR | AMOAND | AMOOR | AMOMIN | AMOMAX | AMOMINU | AMOMAXU



datatype csrop = CSRRW | CSRRS | CSRRC



datatype word_width = BYTE | HALF | WORD | DOUBLE



datatype 'a MemoryOpResult =   MemValue " ('a)" | MemException " (ExceptionType)"



datatype Misa  =   Mk_Misa " ( 64 Word.word)"



datatype SV39_PTE  =   Mk_SV39_PTE " ( 64 Word.word)"



datatype PTE_Bits  =   Mk_PTE_Bits " ( 8 Word.word)"



datatype Mstatus  =   Mk_Mstatus " ( 64 Word.word)"



datatype Sstatus  =   Mk_Sstatus " ( 64 Word.word)"



datatype Minterrupts  =   Mk_Minterrupts " ( 64 Word.word)"



datatype Sinterrupts  =   Mk_Sinterrupts " ( 64 Word.word)"



datatype Medeleg  =   Mk_Medeleg " ( 64 Word.word)"



datatype Sedeleg  =   Mk_Sedeleg " ( 64 Word.word)"



datatype Mtvec  =   Mk_Mtvec " ( 64 Word.word)"



datatype Satp64  =   Mk_Satp64 " ( 64 Word.word)"



datatype Mcause  =   Mk_Mcause " ( 64 Word.word)"



record sync_exception  =
  
 sync_exception_trap ::" ExceptionType " 
 sync_exception_excinfo ::"  xlenbits option "  



datatype ctl_result  =   CTL_TRAP " (sync_exception)" | CTL_SRET " (unit)" | CTL_MRET " (unit)"



type_synonym pteAttribs  =" 8 bits "

datatype PTW_Error = PTW_Access | PTW_Invalid_PTE | PTW_No_Permission | PTW_Misaligned | PTW_PTE_Update



type_synonym vaddr39  =" 39 bits "

type_synonym paddr39  =" 56 bits "

type_synonym pte39  =" xlenbits "

datatype SV39_Vaddr  =   Mk_SV39_Vaddr " ( 39 Word.word)"



datatype SV39_Paddr  =   Mk_SV39_Paddr " ( 56 Word.word)"



type_synonym asid64  =" 16 bits "

datatype PTW_Result  =
    PTW_Success " ((paddr39 * SV39_PTE * paddr39 * ii * bool))" | PTW_Failure " (PTW_Error)"



record TLB39_Entry  =
  
 TLB39_Entry_asid ::" asid64 " 

     TLB39_Entry_global ::" bool " 

     TLB39_Entry_vAddr ::" vaddr39 " 

     TLB39_Entry_pAddr ::" paddr39 " 

     TLB39_Entry_vMatchMask ::" vaddr39 " 

     TLB39_Entry_vAddrMask ::" vaddr39 " 

     TLB39_Entry_pte ::" SV39_PTE " 

     TLB39_Entry_pteAddr ::" paddr39 " 

     TLB39_Entry_age ::" xlenbits "  



datatype TR39_Result  =   TR39_Address " (paddr39)" | TR39_Failure " (PTW_Error)"



datatype TR_Result  =   TR_Address " (xlenbits)" | TR_Failure " (ExceptionType)"



datatype (plugins only: size) ast  =
    UTYPE " (( 20 bits * regbits * uop))"
  | RISCV_JAL " (( 21 bits * regbits))"
  | RISCV_JALR " (( 12 bits * regbits * regbits))"
  | BTYPE " (( 13 bits * regbits * regbits * bop))"
  | ITYPE " (( 12 bits * regbits * regbits * iop))"
  | SHIFTIOP " (( 6 bits * regbits * regbits * sop))"
  | RTYPE " ((regbits * regbits * regbits * rop))"
  | LOAD " (( 12 bits * regbits * regbits * bool * word_width * bool * bool))"
  | STORE " (( 12 bits * regbits * regbits * word_width * bool * bool))"
  | ADDIW " (( 12 bits * regbits * regbits))"
  | SHIFTW " (( 5 bits * regbits * regbits * sop))"
  | RTYPEW " ((regbits * regbits * regbits * ropw))"
  | MUL " ((regbits * regbits * regbits * bool * bool * bool))"
  | DIV " ((regbits * regbits * regbits * bool))"
  | REM " ((regbits * regbits * regbits * bool))"
  | MULW " ((regbits * regbits * regbits))"
  | DIVW " ((regbits * regbits * regbits * bool))"
  | REMW " ((regbits * regbits * regbits * bool))"
  | FENCE " (( 4 bits * 4 bits))"
  | FENCEI " (unit)"
  | ECALL " (unit)"
  | MRET " (unit)"
  | SRET " (unit)"
  | EBREAK " (unit)"
  | WFI " (unit)"
  | SFENCE_VMA " ((regbits * regbits))"
  | LOADRES " ((bool * bool * regbits * word_width * regbits))"
  | STORECON " ((bool * bool * regbits * regbits * word_width * regbits))"
  | AMO " ((amoop * bool * bool * regbits * regbits * word_width * regbits))"
  | CSR " (( 12 bits * regbits * regbits * bool * csrop))"
  | NOP " (unit)"
  | ILLEGAL " (unit)"
  | C_ADDI4SPN " ((cregbits * 8 bits))"
  | C_LW " (( 5 bits * cregbits * cregbits))"
  | C_LD " (( 5 bits * cregbits * cregbits))"
  | C_SW " (( 5 bits * cregbits * cregbits))"
  | C_SD " (( 5 bits * cregbits * cregbits))"
  | C_ADDI " (( 6 bits * regbits))"
  | C_JAL " ( 11 bits)"
  | C_ADDIW " (( 6 bits * regbits))"
  | C_LI " (( 6 bits * regbits))"
  | C_ADDI16SP " ( 6 bits)"
  | C_LUI " (( 6 bits * regbits))"
  | C_SRLI " (( 6 bits * cregbits))"
  | C_SRAI " (( 6 bits * cregbits))"
  | C_ANDI " (( 6 bits * cregbits))"
  | C_SUB " ((cregbits * cregbits))"
  | C_XOR " ((cregbits * cregbits))"
  | C_OR " ((cregbits * cregbits))"
  | C_AND " ((cregbits * cregbits))"
  | C_SUBW " ((cregbits * cregbits))"
  | C_ADDW " ((cregbits * cregbits))"
  | C_J " ( 11 bits)"
  | C_BEQZ " (( 8 bits * cregbits))"
  | C_BNEZ " (( 8 bits * cregbits))"
  | C_SLLI " (( 6 bits * regbits))"
  | C_LWSP " (( 6 bits * regbits))"
  | C_LDSP " (( 6 bits * regbits))"
  | C_SWSP " (( 6 bits * regbits))"
  | C_SDSP " (( 6 bits * regbits))"
  | C_JR " (regbits)"
  | C_JALR " (regbits)"
  | C_MV " ((regbits * regbits))"
  | C_ADD " ((regbits * regbits))"



datatype FetchResult  =   F_Base " (word0)" | F_RVC " (half)" | F_Error " ((ExceptionType * xlenbits))"



datatype register_value  =
    Regval_vector " ((ii * bool * register_value list))"
  | Regval_list " ( register_value list)"
  | Regval_option " ( register_value option)"
  | Regval_Mcause " (Mcause)"
  | Regval_Medeleg " (Medeleg)"
  | Regval_Minterrupts " (Minterrupts)"
  | Regval_Misa " (Misa)"
  | Regval_Mstatus " (Mstatus)"
  | Regval_Mtvec " (Mtvec)"
  | Regval_Privilege " (Privilege)"
  | Regval_Sedeleg " (Sedeleg)"
  | Regval_Sinterrupts " (Sinterrupts)"
  | Regval_TLB39_Entry " (TLB39_Entry)"
  | Regval_vector_64_dec_bit " ( 64 Word.word)"



record regstate  =
  
 tlb39 ::"  TLB39_Entry option " 

     tselect ::"  64 Word.word " 

     stval ::"  64 Word.word " 

     scause ::" Mcause " 

     sepc ::"  64 Word.word " 

     sscratch ::"  64 Word.word " 

     stvec ::" Mtvec " 

     satp ::"  64 Word.word " 

     sideleg ::" Sinterrupts " 

     sedeleg ::" Sedeleg " 

     pmpcfg0 ::"  64 Word.word " 

     pmpaddr0 ::"  64 Word.word " 

     mhartid ::"  64 Word.word " 

     marchid ::"  64 Word.word " 

     mimpid ::"  64 Word.word " 

     mvendorid ::"  64 Word.word " 

     minstret ::"  64 Word.word " 

     mtime ::"  64 Word.word " 

     mcycle ::"  64 Word.word " 

     mscratch ::"  64 Word.word " 

     mtval ::"  64 Word.word " 

     mepc ::"  64 Word.word " 

     mcause ::" Mcause " 

     mtvec ::" Mtvec " 

     medeleg ::" Medeleg " 

     mideleg ::" Minterrupts " 

     mie ::" Minterrupts " 

     mip ::" Minterrupts " 

     mstatus ::" Mstatus " 

     misa ::" Misa " 

     cur_inst ::"  64 Word.word " 

     cur_privilege ::" Privilege " 

     Xs ::" ( 64 Word.word) list " 

     nextPC ::"  64 Word.word " 

     PC ::"  64 Word.word "  





(*val Mcause_of_regval : register_value -> maybe Mcause*)

fun Mcause_of_regval  :: " register_value \<Rightarrow>(Mcause)option "  where 
     " Mcause_of_regval (Regval_Mcause (v)) = ( Some v )"
|" Mcause_of_regval g__92 = ( None )"


(*val regval_of_Mcause : Mcause -> register_value*)

definition regval_of_Mcause  :: " Mcause \<Rightarrow> register_value "  where 
     " regval_of_Mcause v = ( Regval_Mcause v )"


(*val Medeleg_of_regval : register_value -> maybe Medeleg*)

fun Medeleg_of_regval  :: " register_value \<Rightarrow>(Medeleg)option "  where 
     " Medeleg_of_regval (Regval_Medeleg (v)) = ( Some v )"
|" Medeleg_of_regval g__91 = ( None )"


(*val regval_of_Medeleg : Medeleg -> register_value*)

definition regval_of_Medeleg  :: " Medeleg \<Rightarrow> register_value "  where 
     " regval_of_Medeleg v = ( Regval_Medeleg v )"


(*val Minterrupts_of_regval : register_value -> maybe Minterrupts*)

fun Minterrupts_of_regval  :: " register_value \<Rightarrow>(Minterrupts)option "  where 
     " Minterrupts_of_regval (Regval_Minterrupts (v)) = ( Some v )"
|" Minterrupts_of_regval g__90 = ( None )"


(*val regval_of_Minterrupts : Minterrupts -> register_value*)

definition regval_of_Minterrupts  :: " Minterrupts \<Rightarrow> register_value "  where 
     " regval_of_Minterrupts v = ( Regval_Minterrupts v )"


(*val Misa_of_regval : register_value -> maybe Misa*)

fun Misa_of_regval  :: " register_value \<Rightarrow>(Misa)option "  where 
     " Misa_of_regval (Regval_Misa (v)) = ( Some v )"
|" Misa_of_regval g__89 = ( None )"


(*val regval_of_Misa : Misa -> register_value*)

definition regval_of_Misa  :: " Misa \<Rightarrow> register_value "  where 
     " regval_of_Misa v = ( Regval_Misa v )"


(*val Mstatus_of_regval : register_value -> maybe Mstatus*)

fun Mstatus_of_regval  :: " register_value \<Rightarrow>(Mstatus)option "  where 
     " Mstatus_of_regval (Regval_Mstatus (v)) = ( Some v )"
|" Mstatus_of_regval g__88 = ( None )"


(*val regval_of_Mstatus : Mstatus -> register_value*)

definition regval_of_Mstatus  :: " Mstatus \<Rightarrow> register_value "  where 
     " regval_of_Mstatus v = ( Regval_Mstatus v )"


(*val Mtvec_of_regval : register_value -> maybe Mtvec*)

fun Mtvec_of_regval  :: " register_value \<Rightarrow>(Mtvec)option "  where 
     " Mtvec_of_regval (Regval_Mtvec (v)) = ( Some v )"
|" Mtvec_of_regval g__87 = ( None )"


(*val regval_of_Mtvec : Mtvec -> register_value*)

definition regval_of_Mtvec  :: " Mtvec \<Rightarrow> register_value "  where 
     " regval_of_Mtvec v = ( Regval_Mtvec v )"


(*val Privilege_of_regval : register_value -> maybe Privilege*)

fun Privilege_of_regval  :: " register_value \<Rightarrow>(Privilege)option "  where 
     " Privilege_of_regval (Regval_Privilege (v)) = ( Some v )"
|" Privilege_of_regval g__86 = ( None )"


(*val regval_of_Privilege : Privilege -> register_value*)

definition regval_of_Privilege  :: " Privilege \<Rightarrow> register_value "  where 
     " regval_of_Privilege v = ( Regval_Privilege v )"


(*val Sedeleg_of_regval : register_value -> maybe Sedeleg*)

fun Sedeleg_of_regval  :: " register_value \<Rightarrow>(Sedeleg)option "  where 
     " Sedeleg_of_regval (Regval_Sedeleg (v)) = ( Some v )"
|" Sedeleg_of_regval g__85 = ( None )"


(*val regval_of_Sedeleg : Sedeleg -> register_value*)

definition regval_of_Sedeleg  :: " Sedeleg \<Rightarrow> register_value "  where 
     " regval_of_Sedeleg v = ( Regval_Sedeleg v )"


(*val Sinterrupts_of_regval : register_value -> maybe Sinterrupts*)

fun Sinterrupts_of_regval  :: " register_value \<Rightarrow>(Sinterrupts)option "  where 
     " Sinterrupts_of_regval (Regval_Sinterrupts (v)) = ( Some v )"
|" Sinterrupts_of_regval g__84 = ( None )"


(*val regval_of_Sinterrupts : Sinterrupts -> register_value*)

definition regval_of_Sinterrupts  :: " Sinterrupts \<Rightarrow> register_value "  where 
     " regval_of_Sinterrupts v = ( Regval_Sinterrupts v )"


(*val TLB39_Entry_of_regval : register_value -> maybe TLB39_Entry*)

fun TLB39_Entry_of_regval  :: " register_value \<Rightarrow>(TLB39_Entry)option "  where 
     " TLB39_Entry_of_regval (Regval_TLB39_Entry (v)) = ( Some v )"
|" TLB39_Entry_of_regval g__83 = ( None )"


(*val regval_of_TLB39_Entry : TLB39_Entry -> register_value*)

definition regval_of_TLB39_Entry  :: " TLB39_Entry \<Rightarrow> register_value "  where 
     " regval_of_TLB39_Entry v = ( Regval_TLB39_Entry v )"


(*val vector_64_dec_bit_of_regval : register_value -> maybe (mword ty64)*)

fun vector_64_dec_bit_of_regval  :: " register_value \<Rightarrow>((64)Word.word)option "  where 
     " vector_64_dec_bit_of_regval (Regval_vector_64_dec_bit (v)) = ( Some v )"
|" vector_64_dec_bit_of_regval g__82 = ( None )"


(*val regval_of_vector_64_dec_bit : mword ty64 -> register_value*)

definition regval_of_vector_64_dec_bit  :: "(64)Word.word \<Rightarrow> register_value "  where 
     " regval_of_vector_64_dec_bit v = ( Regval_vector_64_dec_bit v )"




(*val vector_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)*)
definition vector_of_regval  :: "(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a list)option "  where 
     " vector_of_regval of_regval1 = ( \<lambda>x .  
  (case  x of
        Regval_vector (_, _, v) => just_list (List.map of_regval1 v)
    | _ => None
  ) )"


(*val regval_of_vector : forall 'a. ('a -> register_value) -> integer -> bool -> list 'a -> register_value*)
definition regval_of_vector  :: "('a \<Rightarrow> register_value)\<Rightarrow> int \<Rightarrow> bool \<Rightarrow> 'a list \<Rightarrow> register_value "  where 
     " regval_of_vector regval_of1 size1 is_inc xs = ( Regval_vector (size1, is_inc, List.map regval_of1 xs))"


(*val list_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (list 'a)*)
definition list_of_regval  :: "(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a list)option "  where 
     " list_of_regval of_regval1 = ( \<lambda>x .  
  (case  x of
        Regval_list v => just_list (List.map of_regval1 v)
    | _ => None
  ) )"


(*val regval_of_list : forall 'a. ('a -> register_value) -> list 'a -> register_value*)
definition regval_of_list  :: "('a \<Rightarrow> register_value)\<Rightarrow> 'a list \<Rightarrow> register_value "  where 
     " regval_of_list regval_of1 xs = ( Regval_list (List.map regval_of1 xs))"


(*val option_of_regval : forall 'a. (register_value -> maybe 'a) -> register_value -> maybe (maybe 'a)*)
definition option_of_regval  :: "(register_value \<Rightarrow> 'a option)\<Rightarrow> register_value \<Rightarrow>('a option)option "  where 
     " option_of_regval of_regval1 = ( \<lambda>x .  
  (case  x of   Regval_option v => map_option of_regval1 v | _ => None ) )"


(*val regval_of_option : forall 'a. ('a -> register_value) -> maybe 'a -> register_value*)
definition regval_of_option  :: "('a \<Rightarrow> register_value)\<Rightarrow> 'a option \<Rightarrow> register_value "  where 
     " regval_of_option regval_of1 v = ( Regval_option (map_option regval_of1 v))"



definition tlb39_ref  :: "((regstate),(register_value),((TLB39_Entry)option))register_ref "  where 
     " tlb39_ref = ( (|
  name = (''tlb39''),
  read_from = (\<lambda> s . (tlb39   s)),
  write_to = (\<lambda> v s .  (( s (| tlb39 := v |)))),
  of_regval = (\<lambda> v .  option_of_regval (\<lambda> v .  TLB39_Entry_of_regval v) v),
  regval_of = (\<lambda> v .  regval_of_option (\<lambda> v .  regval_of_TLB39_Entry v) v) |) )"


definition tselect_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " tselect_ref = ( (|
  name = (''tselect''),
  read_from = (\<lambda> s . (tselect   s)),
  write_to = (\<lambda> v s .  (( s (| tselect := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition stval_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " stval_ref = ( (|
  name = (''stval''),
  read_from = (\<lambda> s . (stval   s)),
  write_to = (\<lambda> v s .  (( s (| stval := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition scause_ref  :: "((regstate),(register_value),(Mcause))register_ref "  where 
     " scause_ref = ( (|
  name = (''scause''),
  read_from = (\<lambda> s . (scause   s)),
  write_to = (\<lambda> v s .  (( s (| scause := v |)))),
  of_regval = (\<lambda> v .  Mcause_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Mcause v) |) )"


definition sepc_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " sepc_ref = ( (|
  name = (''sepc''),
  read_from = (\<lambda> s . (sepc   s)),
  write_to = (\<lambda> v s .  (( s (| sepc := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition sscratch_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " sscratch_ref = ( (|
  name = (''sscratch''),
  read_from = (\<lambda> s . (sscratch   s)),
  write_to = (\<lambda> v s .  (( s (| sscratch := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition stvec_ref  :: "((regstate),(register_value),(Mtvec))register_ref "  where 
     " stvec_ref = ( (|
  name = (''stvec''),
  read_from = (\<lambda> s . (stvec   s)),
  write_to = (\<lambda> v s .  (( s (| stvec := v |)))),
  of_regval = (\<lambda> v .  Mtvec_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Mtvec v) |) )"


definition satp_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " satp_ref = ( (|
  name = (''satp''),
  read_from = (\<lambda> s . (satp   s)),
  write_to = (\<lambda> v s .  (( s (| satp := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition sideleg_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref "  where 
     " sideleg_ref = ( (|
  name = (''sideleg''),
  read_from = (\<lambda> s . (sideleg   s)),
  write_to = (\<lambda> v s .  (( s (| sideleg := v |)))),
  of_regval = (\<lambda> v .  Sinterrupts_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Sinterrupts v) |) )"


definition sedeleg_ref  :: "((regstate),(register_value),(Sedeleg))register_ref "  where 
     " sedeleg_ref = ( (|
  name = (''sedeleg''),
  read_from = (\<lambda> s . (sedeleg   s)),
  write_to = (\<lambda> v s .  (( s (| sedeleg := v |)))),
  of_regval = (\<lambda> v .  Sedeleg_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Sedeleg v) |) )"


definition pmpcfg0_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " pmpcfg0_ref = ( (|
  name = (''pmpcfg0''),
  read_from = (\<lambda> s . (pmpcfg0   s)),
  write_to = (\<lambda> v s .  (( s (| pmpcfg0 := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition pmpaddr0_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " pmpaddr0_ref = ( (|
  name = (''pmpaddr0''),
  read_from = (\<lambda> s . (pmpaddr0   s)),
  write_to = (\<lambda> v s .  (( s (| pmpaddr0 := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mhartid_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mhartid_ref = ( (|
  name = (''mhartid''),
  read_from = (\<lambda> s . (mhartid   s)),
  write_to = (\<lambda> v s .  (( s (| mhartid := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition marchid_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " marchid_ref = ( (|
  name = (''marchid''),
  read_from = (\<lambda> s . (marchid   s)),
  write_to = (\<lambda> v s .  (( s (| marchid := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mimpid_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mimpid_ref = ( (|
  name = (''mimpid''),
  read_from = (\<lambda> s . (mimpid   s)),
  write_to = (\<lambda> v s .  (( s (| mimpid := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mvendorid_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mvendorid_ref = ( (|
  name = (''mvendorid''),
  read_from = (\<lambda> s . (mvendorid   s)),
  write_to = (\<lambda> v s .  (( s (| mvendorid := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition minstret_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " minstret_ref = ( (|
  name = (''minstret''),
  read_from = (\<lambda> s . (minstret   s)),
  write_to = (\<lambda> v s .  (( s (| minstret := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mtime_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mtime_ref = ( (|
  name = (''mtime''),
  read_from = (\<lambda> s . (mtime   s)),
  write_to = (\<lambda> v s .  (( s (| mtime := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mcycle_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mcycle_ref = ( (|
  name = (''mcycle''),
  read_from = (\<lambda> s . (mcycle   s)),
  write_to = (\<lambda> v s .  (( s (| mcycle := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mscratch_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mscratch_ref = ( (|
  name = (''mscratch''),
  read_from = (\<lambda> s . (mscratch   s)),
  write_to = (\<lambda> v s .  (( s (| mscratch := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mtval_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mtval_ref = ( (|
  name = (''mtval''),
  read_from = (\<lambda> s . (mtval   s)),
  write_to = (\<lambda> v s .  (( s (| mtval := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mepc_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " mepc_ref = ( (|
  name = (''mepc''),
  read_from = (\<lambda> s . (mepc   s)),
  write_to = (\<lambda> v s .  (( s (| mepc := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition mcause_ref  :: "((regstate),(register_value),(Mcause))register_ref "  where 
     " mcause_ref = ( (|
  name = (''mcause''),
  read_from = (\<lambda> s . (mcause   s)),
  write_to = (\<lambda> v s .  (( s (| mcause := v |)))),
  of_regval = (\<lambda> v .  Mcause_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Mcause v) |) )"


definition mtvec_ref  :: "((regstate),(register_value),(Mtvec))register_ref "  where 
     " mtvec_ref = ( (|
  name = (''mtvec''),
  read_from = (\<lambda> s . (mtvec   s)),
  write_to = (\<lambda> v s .  (( s (| mtvec := v |)))),
  of_regval = (\<lambda> v .  Mtvec_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Mtvec v) |) )"


definition medeleg_ref  :: "((regstate),(register_value),(Medeleg))register_ref "  where 
     " medeleg_ref = ( (|
  name = (''medeleg''),
  read_from = (\<lambda> s . (medeleg   s)),
  write_to = (\<lambda> v s .  (( s (| medeleg := v |)))),
  of_regval = (\<lambda> v .  Medeleg_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Medeleg v) |) )"


definition mideleg_ref  :: "((regstate),(register_value),(Minterrupts))register_ref "  where 
     " mideleg_ref = ( (|
  name = (''mideleg''),
  read_from = (\<lambda> s . (mideleg   s)),
  write_to = (\<lambda> v s .  (( s (| mideleg := v |)))),
  of_regval = (\<lambda> v .  Minterrupts_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Minterrupts v) |) )"


definition mie_ref  :: "((regstate),(register_value),(Minterrupts))register_ref "  where 
     " mie_ref = ( (|
  name = (''mie''),
  read_from = (\<lambda> s . (mie   s)),
  write_to = (\<lambda> v s .  (( s (| mie := v |)))),
  of_regval = (\<lambda> v .  Minterrupts_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Minterrupts v) |) )"


definition mip_ref  :: "((regstate),(register_value),(Minterrupts))register_ref "  where 
     " mip_ref = ( (|
  name = (''mip''),
  read_from = (\<lambda> s . (mip   s)),
  write_to = (\<lambda> v s .  (( s (| mip := v |)))),
  of_regval = (\<lambda> v .  Minterrupts_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Minterrupts v) |) )"


definition mstatus_ref  :: "((regstate),(register_value),(Mstatus))register_ref "  where 
     " mstatus_ref = ( (|
  name = (''mstatus''),
  read_from = (\<lambda> s . (mstatus   s)),
  write_to = (\<lambda> v s .  (( s (| mstatus := v |)))),
  of_regval = (\<lambda> v .  Mstatus_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Mstatus v) |) )"


definition misa_ref  :: "((regstate),(register_value),(Misa))register_ref "  where 
     " misa_ref = ( (|
  name = (''misa''),
  read_from = (\<lambda> s . (misa   s)),
  write_to = (\<lambda> v s .  (( s (| misa := v |)))),
  of_regval = (\<lambda> v .  Misa_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Misa v) |) )"


definition cur_inst_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " cur_inst_ref = ( (|
  name = (''cur_inst''),
  read_from = (\<lambda> s . (cur_inst   s)),
  write_to = (\<lambda> v s .  (( s (| cur_inst := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition cur_privilege_ref  :: "((regstate),(register_value),(Privilege))register_ref "  where 
     " cur_privilege_ref = ( (|
  name = (''cur_privilege''),
  read_from = (\<lambda> s . (cur_privilege   s)),
  write_to = (\<lambda> v s .  (( s (| cur_privilege := v |)))),
  of_regval = (\<lambda> v .  Privilege_of_regval v),
  regval_of = (\<lambda> v .  regval_of_Privilege v) |) )"


definition Xs_ref  :: "((regstate),(register_value),(((64)Word.word)list))register_ref "  where 
     " Xs_ref = ( (|
  name = (''Xs''),
  read_from = (\<lambda> s . (Xs   s)),
  write_to = (\<lambda> v s .  (( s (| Xs := v |)))),
  of_regval = (\<lambda> v .  vector_of_regval (\<lambda> v .  vector_64_dec_bit_of_regval v) v),
  regval_of = (\<lambda> v .  regval_of_vector (\<lambda> v .  regval_of_vector_64_dec_bit v)(( 32 :: int)) False v) |) )"


definition nextPC_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " nextPC_ref = ( (|
  name = (''nextPC''),
  read_from = (\<lambda> s . (nextPC   s)),
  write_to = (\<lambda> v s .  (( s (| nextPC := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


definition PC_ref  :: "((regstate),(register_value),((64)Word.word))register_ref "  where 
     " PC_ref = ( (|
  name = (''PC''),
  read_from = (\<lambda> s . (PC   s)),
  write_to = (\<lambda> v s .  (( s (| PC := v |)))),
  of_regval = (\<lambda> v .  vector_64_dec_bit_of_regval v),
  regval_of = (\<lambda> v .  regval_of_vector_64_dec_bit v) |) )"


(*val get_regval : string -> regstate -> maybe register_value*)
definition get_regval  :: " string \<Rightarrow> regstate \<Rightarrow>(register_value)option "  where 
     " get_regval reg_name s = (
  if reg_name = (''tlb39'') then Some ((regval_of   tlb39_ref) ((read_from   tlb39_ref) s)) else
  if reg_name = (''tselect'') then Some ((regval_of   tselect_ref) ((read_from   tselect_ref) s)) else
  if reg_name = (''stval'') then Some ((regval_of   stval_ref) ((read_from   stval_ref) s)) else
  if reg_name = (''scause'') then Some ((regval_of   scause_ref) ((read_from   scause_ref) s)) else
  if reg_name = (''sepc'') then Some ((regval_of   sepc_ref) ((read_from   sepc_ref) s)) else
  if reg_name = (''sscratch'') then Some ((regval_of   sscratch_ref) ((read_from   sscratch_ref) s)) else
  if reg_name = (''stvec'') then Some ((regval_of   stvec_ref) ((read_from   stvec_ref) s)) else
  if reg_name = (''satp'') then Some ((regval_of   satp_ref) ((read_from   satp_ref) s)) else
  if reg_name = (''sideleg'') then Some ((regval_of   sideleg_ref) ((read_from   sideleg_ref) s)) else
  if reg_name = (''sedeleg'') then Some ((regval_of   sedeleg_ref) ((read_from   sedeleg_ref) s)) else
  if reg_name = (''pmpcfg0'') then Some ((regval_of   pmpcfg0_ref) ((read_from   pmpcfg0_ref) s)) else
  if reg_name = (''pmpaddr0'') then Some ((regval_of   pmpaddr0_ref) ((read_from   pmpaddr0_ref) s)) else
  if reg_name = (''mhartid'') then Some ((regval_of   mhartid_ref) ((read_from   mhartid_ref) s)) else
  if reg_name = (''marchid'') then Some ((regval_of   marchid_ref) ((read_from   marchid_ref) s)) else
  if reg_name = (''mimpid'') then Some ((regval_of   mimpid_ref) ((read_from   mimpid_ref) s)) else
  if reg_name = (''mvendorid'') then Some ((regval_of   mvendorid_ref) ((read_from   mvendorid_ref) s)) else
  if reg_name = (''minstret'') then Some ((regval_of   minstret_ref) ((read_from   minstret_ref) s)) else
  if reg_name = (''mtime'') then Some ((regval_of   mtime_ref) ((read_from   mtime_ref) s)) else
  if reg_name = (''mcycle'') then Some ((regval_of   mcycle_ref) ((read_from   mcycle_ref) s)) else
  if reg_name = (''mscratch'') then Some ((regval_of   mscratch_ref) ((read_from   mscratch_ref) s)) else
  if reg_name = (''mtval'') then Some ((regval_of   mtval_ref) ((read_from   mtval_ref) s)) else
  if reg_name = (''mepc'') then Some ((regval_of   mepc_ref) ((read_from   mepc_ref) s)) else
  if reg_name = (''mcause'') then Some ((regval_of   mcause_ref) ((read_from   mcause_ref) s)) else
  if reg_name = (''mtvec'') then Some ((regval_of   mtvec_ref) ((read_from   mtvec_ref) s)) else
  if reg_name = (''medeleg'') then Some ((regval_of   medeleg_ref) ((read_from   medeleg_ref) s)) else
  if reg_name = (''mideleg'') then Some ((regval_of   mideleg_ref) ((read_from   mideleg_ref) s)) else
  if reg_name = (''mie'') then Some ((regval_of   mie_ref) ((read_from   mie_ref) s)) else
  if reg_name = (''mip'') then Some ((regval_of   mip_ref) ((read_from   mip_ref) s)) else
  if reg_name = (''mstatus'') then Some ((regval_of   mstatus_ref) ((read_from   mstatus_ref) s)) else
  if reg_name = (''misa'') then Some ((regval_of   misa_ref) ((read_from   misa_ref) s)) else
  if reg_name = (''cur_inst'') then Some ((regval_of   cur_inst_ref) ((read_from   cur_inst_ref) s)) else
  if reg_name = (''cur_privilege'') then Some ((regval_of   cur_privilege_ref) ((read_from   cur_privilege_ref) s)) else
  if reg_name = (''Xs'') then Some ((regval_of   Xs_ref) ((read_from   Xs_ref) s)) else
  if reg_name = (''nextPC'') then Some ((regval_of   nextPC_ref) ((read_from   nextPC_ref) s)) else
  if reg_name = (''PC'') then Some ((regval_of   PC_ref) ((read_from   PC_ref) s)) else
  None )"


(*val set_regval : string -> register_value -> regstate -> maybe regstate*)
definition set_regval  :: " string \<Rightarrow> register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option "  where 
     " set_regval reg_name v s = (
  if reg_name = (''tlb39'') then map_option (\<lambda> v . (write_to   tlb39_ref) v s) ((of_regval   tlb39_ref) v) else
  if reg_name = (''tselect'') then map_option (\<lambda> v . (write_to   tselect_ref) v s) ((of_regval   tselect_ref) v) else
  if reg_name = (''stval'') then map_option (\<lambda> v . (write_to   stval_ref) v s) ((of_regval   stval_ref) v) else
  if reg_name = (''scause'') then map_option (\<lambda> v . (write_to   scause_ref) v s) ((of_regval   scause_ref) v) else
  if reg_name = (''sepc'') then map_option (\<lambda> v . (write_to   sepc_ref) v s) ((of_regval   sepc_ref) v) else
  if reg_name = (''sscratch'') then map_option (\<lambda> v . (write_to   sscratch_ref) v s) ((of_regval   sscratch_ref) v) else
  if reg_name = (''stvec'') then map_option (\<lambda> v . (write_to   stvec_ref) v s) ((of_regval   stvec_ref) v) else
  if reg_name = (''satp'') then map_option (\<lambda> v . (write_to   satp_ref) v s) ((of_regval   satp_ref) v) else
  if reg_name = (''sideleg'') then map_option (\<lambda> v . (write_to   sideleg_ref) v s) ((of_regval   sideleg_ref) v) else
  if reg_name = (''sedeleg'') then map_option (\<lambda> v . (write_to   sedeleg_ref) v s) ((of_regval   sedeleg_ref) v) else
  if reg_name = (''pmpcfg0'') then map_option (\<lambda> v . (write_to   pmpcfg0_ref) v s) ((of_regval   pmpcfg0_ref) v) else
  if reg_name = (''pmpaddr0'') then map_option (\<lambda> v . (write_to   pmpaddr0_ref) v s) ((of_regval   pmpaddr0_ref) v) else
  if reg_name = (''mhartid'') then map_option (\<lambda> v . (write_to   mhartid_ref) v s) ((of_regval   mhartid_ref) v) else
  if reg_name = (''marchid'') then map_option (\<lambda> v . (write_to   marchid_ref) v s) ((of_regval   marchid_ref) v) else
  if reg_name = (''mimpid'') then map_option (\<lambda> v . (write_to   mimpid_ref) v s) ((of_regval   mimpid_ref) v) else
  if reg_name = (''mvendorid'') then map_option (\<lambda> v . (write_to   mvendorid_ref) v s) ((of_regval   mvendorid_ref) v) else
  if reg_name = (''minstret'') then map_option (\<lambda> v . (write_to   minstret_ref) v s) ((of_regval   minstret_ref) v) else
  if reg_name = (''mtime'') then map_option (\<lambda> v . (write_to   mtime_ref) v s) ((of_regval   mtime_ref) v) else
  if reg_name = (''mcycle'') then map_option (\<lambda> v . (write_to   mcycle_ref) v s) ((of_regval   mcycle_ref) v) else
  if reg_name = (''mscratch'') then map_option (\<lambda> v . (write_to   mscratch_ref) v s) ((of_regval   mscratch_ref) v) else
  if reg_name = (''mtval'') then map_option (\<lambda> v . (write_to   mtval_ref) v s) ((of_regval   mtval_ref) v) else
  if reg_name = (''mepc'') then map_option (\<lambda> v . (write_to   mepc_ref) v s) ((of_regval   mepc_ref) v) else
  if reg_name = (''mcause'') then map_option (\<lambda> v . (write_to   mcause_ref) v s) ((of_regval   mcause_ref) v) else
  if reg_name = (''mtvec'') then map_option (\<lambda> v . (write_to   mtvec_ref) v s) ((of_regval   mtvec_ref) v) else
  if reg_name = (''medeleg'') then map_option (\<lambda> v . (write_to   medeleg_ref) v s) ((of_regval   medeleg_ref) v) else
  if reg_name = (''mideleg'') then map_option (\<lambda> v . (write_to   mideleg_ref) v s) ((of_regval   mideleg_ref) v) else
  if reg_name = (''mie'') then map_option (\<lambda> v . (write_to   mie_ref) v s) ((of_regval   mie_ref) v) else
  if reg_name = (''mip'') then map_option (\<lambda> v . (write_to   mip_ref) v s) ((of_regval   mip_ref) v) else
  if reg_name = (''mstatus'') then map_option (\<lambda> v . (write_to   mstatus_ref) v s) ((of_regval   mstatus_ref) v) else
  if reg_name = (''misa'') then map_option (\<lambda> v . (write_to   misa_ref) v s) ((of_regval   misa_ref) v) else
  if reg_name = (''cur_inst'') then map_option (\<lambda> v . (write_to   cur_inst_ref) v s) ((of_regval   cur_inst_ref) v) else
  if reg_name = (''cur_privilege'') then map_option (\<lambda> v . (write_to   cur_privilege_ref) v s) ((of_regval   cur_privilege_ref) v) else
  if reg_name = (''Xs'') then map_option (\<lambda> v . (write_to   Xs_ref) v s) ((of_regval   Xs_ref) v) else
  if reg_name = (''nextPC'') then map_option (\<lambda> v . (write_to   nextPC_ref) v s) ((of_regval   nextPC_ref) v) else
  if reg_name = (''PC'') then map_option (\<lambda> v . (write_to   PC_ref) v s) ((of_regval   PC_ref) v) else
  None )"


definition register_accessors  :: "(string \<Rightarrow> regstate \<Rightarrow>(register_value)option)*(string \<Rightarrow> register_value \<Rightarrow> regstate \<Rightarrow>(regstate)option)"  where 
     " register_accessors = ( (get_regval, set_regval))"



type_synonym( 'a, 'r) MR =" (register_value, 'a, 'r, exception) monadR "
type_synonym 'a M =" (register_value, 'a, exception) monad "
end
