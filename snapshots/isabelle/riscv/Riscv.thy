chapter \<open>Generated by Lem from riscv.lem.\<close>

theory "Riscv" 

imports 
 	 Main
	 "Lem_pervasives_extra" 
	 "Sail_instr_kinds" 
	 "Sail_values" 
	 "Sail_operators_mwords" 
	 "Prompt_monad" 
	 "Prompt" 
	 "State" 
	 "Riscv_types" 
	 "Riscv_extras" 

begin 

(*Generated by Sail from riscv.*)
(*open import Pervasives_extra*)
(*open import Sail_instr_kinds*)
(*open import Sail_values*)
(*open import Sail_operators_mwords*)
(*open import Prompt_monad*)
(*open import Prompt*)
(*open import State*)
(*open import Riscv_types*)
(*open import Riscv_extras*)









(*val builtin_and_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val builtin_or_vec : forall 'n. bits 'n -> bits 'n -> bits 'n*)



(*val __raw_SetSlice_int : forall 'w. integer -> ii -> ii -> bits 'w -> ii*)

(*val __GetSlice_int : forall 'n. Size 'n => integer -> ii -> ii -> mword 'n*)

definition GetSlice_int  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " GetSlice_int n m o1 = ( (get_slice_int0 n m o1  :: ( 'n::len)Word.word))"


(*val __raw_SetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w -> bits 'n*)

(*val __raw_GetSlice_bits : forall 'n 'w. integer -> integer -> bits 'n -> ii -> bits 'w*)

(*val cast_unit_vec : bitU -> mword ty1*)

fun cast_unit_vec0  :: " bitU \<Rightarrow>(1)Word.word "  where 
     " cast_unit_vec0 B0 = ( (vec_of_bits [B0]  ::  1 Word.word))"
|" cast_unit_vec0 B1 = ( (vec_of_bits [B1]  ::  1 Word.word))"


(*val DecStr : ii -> string*)

(*val HexStr : ii -> string*)

(*val __RISCV_write : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M bool*)

definition RISCV_write  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " RISCV_write addr width data = (
   write_ram (( 64 :: int)::ii) width
     (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                   B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                   B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
       ::  64 Word.word) addr data \<then>
   return True )"


(*val __TraceMemoryWrite : forall 'int8_times_n 'm. integer -> bits 'm -> bits 'int8_times_n -> unit*)

(*val __RISCV_read : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (maybe (mword 'int8_times_n))*)

definition RISCV_read  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)option),(exception))monad "  where 
     " RISCV_read addr width = (
   (read_ram (( 64 :: int)::ii) width
      (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                    B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                    B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
        ::  64 Word.word) addr
     :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__0 :: ( 'int8_times_n::len)Word.word) . 
   return (Some w__0)))"


(*val __TraceMemoryRead : forall 'int8_times_n 'm. integer -> bits 'm -> bits 'int8_times_n -> unit*)

(*val ex_nat : ii -> integer*)

definition ex_nat  :: " int \<Rightarrow> int "  where 
     " ex_nat n = ( n )"


(*val ex_int : ii -> integer*)

definition ex_int  :: " int \<Rightarrow> int "  where 
     " ex_int n = ( n )"


(*val coerce_int_nat : ii -> M ii*)

definition coerce_int_nat  :: " int \<Rightarrow>((register_value),(int),(exception))monad "  where 
     " coerce_int_nat x = ( assert_exp True ('''') \<then> return x )"


(*val EXTS : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

(*val EXTZ : forall 'n 'm . Size 'm, Size 'n => integer -> mword 'n -> mword 'm*)

definition EXTS  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " EXTS (m__tv :: int) v = ( (sign_extend v m__tv  :: ( 'm::len)Word.word))"


definition EXTZ  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " EXTZ (m__tv :: int) v = ( (zero_extend v m__tv  :: ( 'm::len)Word.word))"


(*val zopz0zI_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zKzJ_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zI_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zKzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

(*val zopz0zIzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool*)

definition zopz0zI_s  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zI_s x y = ( ((Word.sint x)) < ((Word.sint y)))"


definition zopz0zKzJ_s  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zKzJ_s x y = ( ((Word.sint x)) \<ge> ((Word.sint y)))"


definition zopz0zI_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zI_u x y = ( ((Word.uint x)) < ((Word.uint y)))"


definition zopz0zKzJ_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zKzJ_u x y = ( ((Word.uint x)) \<ge> ((Word.uint y)))"


definition zopz0zIzJ_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zIzJ_u x y = ( ((Word.uint x)) \<le> ((Word.uint y)))"


(*val bool_to_bits : bool -> mword ty1*)

definition bool_to_bits  :: " bool \<Rightarrow>(1)Word.word "  where 
     " bool_to_bits x = ( if x then (vec_of_bits [B1]  ::  1 Word.word) else (vec_of_bits [B0]  ::  1 Word.word))"


(*val bit_to_bool : bitU -> bool*)

fun bit_to_bool  :: " bitU \<Rightarrow> bool "  where 
     " bit_to_bool B1 = ( True )"
|" bit_to_bool B0 = ( False )"


(*val vector64 : ii -> mword ty64*)

definition vector64  :: " int \<Rightarrow>(64)Word.word "  where 
     " vector64 n = ( (get_slice_int0 (( 64 :: int)::ii) n (( 0 :: int)::ii)  ::  64 Word.word))"


(*val to_bits : forall 'l. Size 'l => integer -> ii -> mword 'l*)

definition to_bits  :: " int \<Rightarrow> int \<Rightarrow>('l::len)Word.word "  where 
     " to_bits l n = ( (get_slice_int0 l n (( 0 :: int)::ii)  :: ( 'l::len)Word.word))"


(*val shift_right_arith64 : mword ty64 -> mword ty6 -> mword ty64*)

definition shift_right_arith64  :: "(64)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(64)Word.word "  where 
     " shift_right_arith64 (v :: 64 bits) (shift :: 6 bits) = (
   (let (v128 :: 128 bits) = ((EXTS (( 128 :: int)::ii) v  ::  128 Word.word)) in
   (subrange_vec_dec ((shift_bits_right v128 shift  ::  128 Word.word)) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)))"


(*val shift_right_arith32 : mword ty32 -> mword ty5 -> mword ty32*)

definition shift_right_arith32  :: "(32)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(32)Word.word "  where 
     " shift_right_arith32 (v :: 32 bits) (shift :: 5 bits) = (
   (let (v64 :: 64 bits) = ((EXTS (( 64 :: int)::ii) v  ::  64 Word.word)) in
   (subrange_vec_dec ((shift_bits_right v64 shift  ::  64 Word.word)) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)))"


definition xlen  :: " int "  where 
     " xlen = ( (( 64 :: int)::ii))"


definition xlen_max_unsigned  :: " int "  where 
     " xlen_max_unsigned = ( ((pow2 xlen)) - (( 1 :: int)::ii))"


definition xlen_max_signed  :: " int "  where 
     " xlen_max_signed = ( ((pow2 ((xlen - (( 1 :: int)::ii))))) - (( 1 :: int)::ii))"


definition xlen_min_signed  :: " int "  where 
     " xlen_min_signed = ( (( 0 :: int)::ii) - ((pow2 ((xlen - (( 1 :: int)::ii))))))"


(*val regbits_to_regno : mword ty5 -> integer*)

definition regbits_to_regno  :: "(5)Word.word \<Rightarrow> int "  where 
     " regbits_to_regno b = (
   (let r = (Word.uint b) in
   r))"


(*val creg2reg_bits : mword ty3 -> mword ty5*)

definition creg2reg_bits  :: "(3)Word.word \<Rightarrow>(5)Word.word "  where 
     " creg2reg_bits creg = ( (concat_vec (vec_of_bits [B0,B1]  ::  2 Word.word) creg  ::  5 Word.word))"


definition zreg  :: "(5)Word.word "  where 
     " zreg = ( (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))"


definition ra  :: "(5)Word.word "  where 
     " ra = ( (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))"


definition sp  :: "(5)Word.word "  where 
     " sp = ( (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word))"


(*val rX : integer -> M (mword ty64)*)

definition rX  :: " int \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " rX l__81 = (
   if (((l__81 = (( 0 :: int)::ii)))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                          B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                          B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
              ::  64 Word.word)
   else
     read_reg Xs_ref \<bind> (\<lambda> (w__0 :: xlenbits list) . 
     return ((access_list_dec w__0 l__81  ::  64 Word.word))))"


(*val wX : integer -> mword ty64 -> M unit*)

definition wX  :: " int \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " wX r v = (
   if (((r \<noteq> (( 0 :: int)::ii)))) then
     read_reg Xs_ref \<bind> (\<lambda> (w__0 :: ( 64 Word.word) list) . 
     write_reg Xs_ref ((update_list_dec w__0 r v  :: ( 64 Word.word) list)) \<then>
     return ((prerr_endline
                (((op@) (''x'')
                    (((op@) ((stringFromInteger r))
                        (((op@) ('' <- '') ((string_of_vec v)))))))))))
   else return ()  )"


(*val reg_name_abi : mword ty5 -> string*)

definition reg_name_abi  :: "(5)Word.word \<Rightarrow> string "  where 
     " reg_name_abi r = (
   (let b__0 = r in
   if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     (''zero'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     (''ra'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     (''sp'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     (''gp'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     (''tp'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     (''t0'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     (''t1'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     (''t2'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     (''fp'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     (''s1'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     (''a0'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     (''a1'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     (''a2'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     (''a3'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     (''a4'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     (''a5'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     (''a6'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     (''a7'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     (''s2'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     (''s3'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     (''s4'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     (''s5'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     (''s6'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     (''s7'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     (''s8'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     (''s9'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     (''s10'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     (''s11'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     (''t3'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     (''t4'')
   else if (((((regbits_to_regno b__0)) = ((regbits_to_regno (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     (''t5'')
   else (''t6'')))"


(*val Architecture_of_num : integer -> Architecture*)

definition Architecture_of_num  :: " int \<Rightarrow> Architecture "  where 
     " Architecture_of_num arg0 = (
   (let l__79 = arg0 in
   if (((l__79 = (( 0 :: int)::ii)))) then RV32
   else if (((l__79 = (( 1 :: int)::ii)))) then RV64
   else RV128))"


(*val num_of_Architecture : Architecture -> integer*)

fun num_of_Architecture  :: " Architecture \<Rightarrow> int "  where 
     " num_of_Architecture RV32 = ( (( 0 :: int)::ii))"
|" num_of_Architecture RV64 = ( (( 1 :: int)::ii))"
|" num_of_Architecture RV128 = ( (( 2 :: int)::ii))"


(*val architecture : mword ty2 -> maybe Architecture*)

definition architecture  :: "(2)Word.word \<Rightarrow>(Architecture)option "  where 
     " architecture a = (
   (let b__0 = a in
   if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then Some RV32
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then Some RV64
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then Some RV128
   else None))"


(*val arch_to_bits : Architecture -> mword ty2*)

fun arch_to_bits  :: " Architecture \<Rightarrow>(2)Word.word "  where 
     " arch_to_bits RV32 = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" arch_to_bits RV64 = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" arch_to_bits RV128 = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


(*val Privilege_of_num : integer -> Privilege*)

definition Privilege_of_num  :: " int \<Rightarrow> Privilege "  where 
     " Privilege_of_num arg0 = (
   (let l__77 = arg0 in
   if (((l__77 = (( 0 :: int)::ii)))) then User
   else if (((l__77 = (( 1 :: int)::ii)))) then Supervisor
   else Machine))"


(*val num_of_Privilege : Privilege -> integer*)

fun num_of_Privilege  :: " Privilege \<Rightarrow> int "  where 
     " num_of_Privilege User = ( (( 0 :: int)::ii))"
|" num_of_Privilege Supervisor = ( (( 1 :: int)::ii))"
|" num_of_Privilege Machine = ( (( 2 :: int)::ii))"


(*val privLevel_to_bits : Privilege -> mword ty2*)

fun privLevel_to_bits  :: " Privilege \<Rightarrow>(2)Word.word "  where 
     " privLevel_to_bits User = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"
|" privLevel_to_bits Supervisor = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" privLevel_to_bits Machine = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


(*val privLevel_of_bits : mword ty2 -> Privilege*)

definition privLevel_of_bits  :: "(2)Word.word \<Rightarrow> Privilege "  where 
     " privLevel_of_bits p = (
   (let b__0 = p in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then User
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then Supervisor
   else Machine))"


(*val privLevel_to_str : Privilege -> string*)

fun privLevel_to_str  :: " Privilege \<Rightarrow> string "  where 
     " privLevel_to_str User = ( (''U''))"
|" privLevel_to_str Supervisor = ( (''S''))"
|" privLevel_to_str Machine = ( (''M''))"


(*val AccessType_of_num : integer -> AccessType*)

definition AccessType_of_num  :: " int \<Rightarrow> AccessType "  where 
     " AccessType_of_num arg0 = (
   (let l__74 = arg0 in
   if (((l__74 = (( 0 :: int)::ii)))) then Read
   else if (((l__74 = (( 1 :: int)::ii)))) then Write
   else if (((l__74 = (( 2 :: int)::ii)))) then ReadWrite
   else Execute))"


(*val num_of_AccessType : AccessType -> integer*)

fun num_of_AccessType  :: " AccessType \<Rightarrow> int "  where 
     " num_of_AccessType Read = ( (( 0 :: int)::ii))"
|" num_of_AccessType Write = ( (( 1 :: int)::ii))"
|" num_of_AccessType ReadWrite = ( (( 2 :: int)::ii))"
|" num_of_AccessType Execute = ( (( 3 :: int)::ii))"


(*val ReadType_of_num : integer -> ReadType*)

definition ReadType_of_num  :: " int \<Rightarrow> ReadType "  where 
     " ReadType_of_num arg0 = (
   (let l__73 = arg0 in
   if (((l__73 = (( 0 :: int)::ii)))) then Instruction
   else Data))"


(*val num_of_ReadType : ReadType -> integer*)

fun num_of_ReadType  :: " ReadType \<Rightarrow> int "  where 
     " num_of_ReadType Instruction = ( (( 0 :: int)::ii))"
|" num_of_ReadType Data = ( (( 1 :: int)::ii))"


(*val ExceptionType_of_num : integer -> ExceptionType*)

definition ExceptionType_of_num  :: " int \<Rightarrow> ExceptionType "  where 
     " ExceptionType_of_num arg0 = (
   (let l__58 = arg0 in
   if (((l__58 = (( 0 :: int)::ii)))) then E_Fetch_Addr_Align
   else if (((l__58 = (( 1 :: int)::ii)))) then E_Fetch_Access_Fault
   else if (((l__58 = (( 2 :: int)::ii)))) then E_Illegal_Instr
   else if (((l__58 = (( 3 :: int)::ii)))) then E_Breakpoint
   else if (((l__58 = (( 4 :: int)::ii)))) then E_Load_Addr_Align
   else if (((l__58 = (( 5 :: int)::ii)))) then E_Load_Access_Fault
   else if (((l__58 = (( 6 :: int)::ii)))) then E_SAMO_Addr_Align
   else if (((l__58 = (( 7 :: int)::ii)))) then E_SAMO_Access_Fault
   else if (((l__58 = (( 8 :: int)::ii)))) then E_U_EnvCall
   else if (((l__58 = (( 9 :: int)::ii)))) then E_S_EnvCall
   else if (((l__58 = (( 10 :: int)::ii)))) then E_Reserved_10
   else if (((l__58 = (( 11 :: int)::ii)))) then E_M_EnvCall
   else if (((l__58 = (( 12 :: int)::ii)))) then E_Fetch_Page_Fault
   else if (((l__58 = (( 13 :: int)::ii)))) then E_Load_Page_Fault
   else if (((l__58 = (( 14 :: int)::ii)))) then E_Reserved_14
   else E_SAMO_Page_Fault))"


(*val num_of_ExceptionType : ExceptionType -> integer*)

fun num_of_ExceptionType  :: " ExceptionType \<Rightarrow> int "  where 
     " num_of_ExceptionType E_Fetch_Addr_Align = ( (( 0 :: int)::ii))"
|" num_of_ExceptionType E_Fetch_Access_Fault = ( (( 1 :: int)::ii))"
|" num_of_ExceptionType E_Illegal_Instr = ( (( 2 :: int)::ii))"
|" num_of_ExceptionType E_Breakpoint = ( (( 3 :: int)::ii))"
|" num_of_ExceptionType E_Load_Addr_Align = ( (( 4 :: int)::ii))"
|" num_of_ExceptionType E_Load_Access_Fault = ( (( 5 :: int)::ii))"
|" num_of_ExceptionType E_SAMO_Addr_Align = ( (( 6 :: int)::ii))"
|" num_of_ExceptionType E_SAMO_Access_Fault = ( (( 7 :: int)::ii))"
|" num_of_ExceptionType E_U_EnvCall = ( (( 8 :: int)::ii))"
|" num_of_ExceptionType E_S_EnvCall = ( (( 9 :: int)::ii))"
|" num_of_ExceptionType E_Reserved_10 = ( (( 10 :: int)::ii))"
|" num_of_ExceptionType E_M_EnvCall = ( (( 11 :: int)::ii))"
|" num_of_ExceptionType E_Fetch_Page_Fault = ( (( 12 :: int)::ii))"
|" num_of_ExceptionType E_Load_Page_Fault = ( (( 13 :: int)::ii))"
|" num_of_ExceptionType E_Reserved_14 = ( (( 14 :: int)::ii))"
|" num_of_ExceptionType E_SAMO_Page_Fault = ( (( 15 :: int)::ii))"


(*val exceptionType_to_bits : ExceptionType -> mword ty4*)

fun exceptionType_to_bits  :: " ExceptionType \<Rightarrow>(4)Word.word "  where 
     " exceptionType_to_bits E_Fetch_Addr_Align = ( (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_Fetch_Access_Fault = ( (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_Illegal_Instr = ( (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_Breakpoint = ( (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_Load_Addr_Align = ( (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_Load_Access_Fault = ( (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_SAMO_Addr_Align = ( (vec_of_bits [B0,B1,B1,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_SAMO_Access_Fault = ( (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_U_EnvCall = ( (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_S_EnvCall = ( (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_Reserved_10 = ( (vec_of_bits [B1,B0,B1,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_M_EnvCall = ( (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_Fetch_Page_Fault = ( (vec_of_bits [B1,B1,B0,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_Load_Page_Fault = ( (vec_of_bits [B1,B1,B0,B1]  ::  4 Word.word))"
|" exceptionType_to_bits E_Reserved_14 = ( (vec_of_bits [B1,B1,B1,B0]  ::  4 Word.word))"
|" exceptionType_to_bits E_SAMO_Page_Fault = ( (vec_of_bits [B1,B1,B1,B1]  ::  4 Word.word))"


(*val exceptionType_to_str : ExceptionType -> string*)

fun exceptionType_to_str  :: " ExceptionType \<Rightarrow> string "  where 
     " exceptionType_to_str E_Fetch_Addr_Align = ( (''fisaligned-fetch''))"
|" exceptionType_to_str E_Fetch_Access_Fault = ( (''fetch-access-fault''))"
|" exceptionType_to_str E_Illegal_Instr = ( (''illegal-instruction''))"
|" exceptionType_to_str E_Breakpoint = ( (''breakpoint''))"
|" exceptionType_to_str E_Load_Addr_Align = ( (''misaligned-load''))"
|" exceptionType_to_str E_Load_Access_Fault = ( (''load-access-fault''))"
|" exceptionType_to_str E_SAMO_Addr_Align = ( (''misaliged-store/amo''))"
|" exceptionType_to_str E_SAMO_Access_Fault = ( (''store/amo-access-fault''))"
|" exceptionType_to_str E_U_EnvCall = ( (''u-call''))"
|" exceptionType_to_str E_S_EnvCall = ( (''s-call''))"
|" exceptionType_to_str E_Reserved_10 = ( (''reserved-0''))"
|" exceptionType_to_str E_M_EnvCall = ( (''m-call''))"
|" exceptionType_to_str E_Fetch_Page_Fault = ( (''fetch-page-fault''))"
|" exceptionType_to_str E_Load_Page_Fault = ( (''load-page-fault''))"
|" exceptionType_to_str E_Reserved_14 = ( (''reserved-1''))"
|" exceptionType_to_str E_SAMO_Page_Fault = ( (''store/amo-page-fault''))"


(*val InterruptType_of_num : integer -> InterruptType*)

definition InterruptType_of_num  :: " int \<Rightarrow> InterruptType "  where 
     " InterruptType_of_num arg0 = (
   (let l__50 = arg0 in
   if (((l__50 = (( 0 :: int)::ii)))) then I_U_Software
   else if (((l__50 = (( 1 :: int)::ii)))) then I_S_Software
   else if (((l__50 = (( 2 :: int)::ii)))) then I_M_Software
   else if (((l__50 = (( 3 :: int)::ii)))) then I_U_Timer
   else if (((l__50 = (( 4 :: int)::ii)))) then I_S_Timer
   else if (((l__50 = (( 5 :: int)::ii)))) then I_M_Timer
   else if (((l__50 = (( 6 :: int)::ii)))) then I_U_External
   else if (((l__50 = (( 7 :: int)::ii)))) then I_S_External
   else I_M_External))"


(*val num_of_InterruptType : InterruptType -> integer*)

fun num_of_InterruptType  :: " InterruptType \<Rightarrow> int "  where 
     " num_of_InterruptType I_U_Software = ( (( 0 :: int)::ii))"
|" num_of_InterruptType I_S_Software = ( (( 1 :: int)::ii))"
|" num_of_InterruptType I_M_Software = ( (( 2 :: int)::ii))"
|" num_of_InterruptType I_U_Timer = ( (( 3 :: int)::ii))"
|" num_of_InterruptType I_S_Timer = ( (( 4 :: int)::ii))"
|" num_of_InterruptType I_M_Timer = ( (( 5 :: int)::ii))"
|" num_of_InterruptType I_U_External = ( (( 6 :: int)::ii))"
|" num_of_InterruptType I_S_External = ( (( 7 :: int)::ii))"
|" num_of_InterruptType I_M_External = ( (( 8 :: int)::ii))"


(*val interruptType_to_bits : InterruptType -> mword ty4*)

fun interruptType_to_bits  :: " InterruptType \<Rightarrow>(4)Word.word "  where 
     " interruptType_to_bits I_U_Software = ( (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word))"
|" interruptType_to_bits I_S_Software = ( (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word))"
|" interruptType_to_bits I_M_Software = ( (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word))"
|" interruptType_to_bits I_U_Timer = ( (vec_of_bits [B0,B1,B0,B0]  ::  4 Word.word))"
|" interruptType_to_bits I_S_Timer = ( (vec_of_bits [B0,B1,B0,B1]  ::  4 Word.word))"
|" interruptType_to_bits I_M_Timer = ( (vec_of_bits [B0,B1,B1,B1]  ::  4 Word.word))"
|" interruptType_to_bits I_U_External = ( (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word))"
|" interruptType_to_bits I_S_External = ( (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word))"
|" interruptType_to_bits I_M_External = ( (vec_of_bits [B1,B0,B1,B1]  ::  4 Word.word))"


(*val TrapVectorMode_of_num : integer -> TrapVectorMode*)

definition TrapVectorMode_of_num  :: " int \<Rightarrow> TrapVectorMode "  where 
     " TrapVectorMode_of_num arg0 = (
   (let l__48 = arg0 in
   if (((l__48 = (( 0 :: int)::ii)))) then TV_Direct
   else if (((l__48 = (( 1 :: int)::ii)))) then TV_Vector
   else TV_Reserved))"


(*val num_of_TrapVectorMode : TrapVectorMode -> integer*)

fun num_of_TrapVectorMode  :: " TrapVectorMode \<Rightarrow> int "  where 
     " num_of_TrapVectorMode TV_Direct = ( (( 0 :: int)::ii))"
|" num_of_TrapVectorMode TV_Vector = ( (( 1 :: int)::ii))"
|" num_of_TrapVectorMode TV_Reserved = ( (( 2 :: int)::ii))"


(*val trapVectorMode_of_bits : mword ty2 -> TrapVectorMode*)

definition trapVectorMode_of_bits  :: "(2)Word.word \<Rightarrow> TrapVectorMode "  where 
     " trapVectorMode_of_bits m = (
   (let b__0 = m in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then TV_Direct
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then TV_Vector
   else TV_Reserved))"


(*val not_implemented : forall 'a. string -> M 'a*)

definition not_implemented  :: " string \<Rightarrow>((register_value),'a,(exception))monad "  where 
     " not_implemented message = ( throw (Error_not_implemented message))"


(*val internal_error : forall 'a. string -> M 'a*)

definition internal_error  :: " string \<Rightarrow>((register_value),'a,(exception))monad "  where 
     " internal_error s = ( assert_exp False s \<then> throw (Error_internal_error () ))"


(*val ExtStatus_of_num : integer -> ExtStatus*)

definition ExtStatus_of_num  :: " int \<Rightarrow> ExtStatus "  where 
     " ExtStatus_of_num arg0 = (
   (let l__45 = arg0 in
   if (((l__45 = (( 0 :: int)::ii)))) then Off
   else if (((l__45 = (( 1 :: int)::ii)))) then Initial
   else if (((l__45 = (( 2 :: int)::ii)))) then Clean
   else Dirty))"


(*val num_of_ExtStatus : ExtStatus -> integer*)

fun num_of_ExtStatus  :: " ExtStatus \<Rightarrow> int "  where 
     " num_of_ExtStatus Off = ( (( 0 :: int)::ii))"
|" num_of_ExtStatus Initial = ( (( 1 :: int)::ii))"
|" num_of_ExtStatus Clean = ( (( 2 :: int)::ii))"
|" num_of_ExtStatus Dirty = ( (( 3 :: int)::ii))"


(*val extStatus_to_bits : ExtStatus -> mword ty2*)

fun extStatus_to_bits  :: " ExtStatus \<Rightarrow>(2)Word.word "  where 
     " extStatus_to_bits Off = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"
|" extStatus_to_bits Initial = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" extStatus_to_bits Clean = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" extStatus_to_bits Dirty = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


(*val extStatus_of_bits : mword ty2 -> ExtStatus*)

definition extStatus_of_bits  :: "(2)Word.word \<Rightarrow> ExtStatus "  where 
     " extStatus_of_bits e = (
   (let b__0 = e in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then Off
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then Initial
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then Clean
   else Dirty))"


(*val SATPMode_of_num : integer -> SATPMode*)

definition SATPMode_of_num  :: " int \<Rightarrow> SATPMode "  where 
     " SATPMode_of_num arg0 = (
   (let l__43 = arg0 in
   if (((l__43 = (( 0 :: int)::ii)))) then Sbare
   else if (((l__43 = (( 1 :: int)::ii)))) then Sv32
   else Sv39))"


(*val num_of_SATPMode : SATPMode -> integer*)

fun num_of_SATPMode  :: " SATPMode \<Rightarrow> int "  where 
     " num_of_SATPMode Sbare = ( (( 0 :: int)::ii))"
|" num_of_SATPMode Sv32 = ( (( 1 :: int)::ii))"
|" num_of_SATPMode Sv39 = ( (( 2 :: int)::ii))"


(*val satpMode_of_bits : Architecture -> mword ty4 -> maybe SATPMode*)

definition satpMode_of_bits  :: " Architecture \<Rightarrow>(4)Word.word \<Rightarrow>(SATPMode)option "  where 
     " satpMode_of_bits (g__113 :: Architecture) (b__0 :: satp_mode) = ( Some Sbare )"


(*val uop_of_num : integer -> uop*)

definition uop_of_num  :: " int \<Rightarrow> uop "  where 
     " uop_of_num arg0 = (
   (let l__42 = arg0 in
   if (((l__42 = (( 0 :: int)::ii)))) then RISCV_LUI
   else RISCV_AUIPC))"


(*val num_of_uop : uop -> integer*)

fun num_of_uop  :: " uop \<Rightarrow> int "  where 
     " num_of_uop RISCV_LUI = ( (( 0 :: int)::ii))"
|" num_of_uop RISCV_AUIPC = ( (( 1 :: int)::ii))"


(*val bop_of_num : integer -> bop*)

definition bop_of_num  :: " int \<Rightarrow> bop "  where 
     " bop_of_num arg0 = (
   (let l__37 = arg0 in
   if (((l__37 = (( 0 :: int)::ii)))) then RISCV_BEQ
   else if (((l__37 = (( 1 :: int)::ii)))) then RISCV_BNE
   else if (((l__37 = (( 2 :: int)::ii)))) then RISCV_BLT
   else if (((l__37 = (( 3 :: int)::ii)))) then RISCV_BGE
   else if (((l__37 = (( 4 :: int)::ii)))) then RISCV_BLTU
   else RISCV_BGEU))"


(*val num_of_bop : bop -> integer*)

fun num_of_bop  :: " bop \<Rightarrow> int "  where 
     " num_of_bop RISCV_BEQ = ( (( 0 :: int)::ii))"
|" num_of_bop RISCV_BNE = ( (( 1 :: int)::ii))"
|" num_of_bop RISCV_BLT = ( (( 2 :: int)::ii))"
|" num_of_bop RISCV_BGE = ( (( 3 :: int)::ii))"
|" num_of_bop RISCV_BLTU = ( (( 4 :: int)::ii))"
|" num_of_bop RISCV_BGEU = ( (( 5 :: int)::ii))"


(*val iop_of_num : integer -> iop*)

definition iop_of_num  :: " int \<Rightarrow> iop "  where 
     " iop_of_num arg0 = (
   (let l__32 = arg0 in
   if (((l__32 = (( 0 :: int)::ii)))) then RISCV_ADDI
   else if (((l__32 = (( 1 :: int)::ii)))) then RISCV_SLTI
   else if (((l__32 = (( 2 :: int)::ii)))) then RISCV_SLTIU
   else if (((l__32 = (( 3 :: int)::ii)))) then RISCV_XORI
   else if (((l__32 = (( 4 :: int)::ii)))) then RISCV_ORI
   else RISCV_ANDI))"


(*val num_of_iop : iop -> integer*)

fun num_of_iop  :: " iop \<Rightarrow> int "  where 
     " num_of_iop RISCV_ADDI = ( (( 0 :: int)::ii))"
|" num_of_iop RISCV_SLTI = ( (( 1 :: int)::ii))"
|" num_of_iop RISCV_SLTIU = ( (( 2 :: int)::ii))"
|" num_of_iop RISCV_XORI = ( (( 3 :: int)::ii))"
|" num_of_iop RISCV_ORI = ( (( 4 :: int)::ii))"
|" num_of_iop RISCV_ANDI = ( (( 5 :: int)::ii))"


(*val sop_of_num : integer -> sop*)

definition sop_of_num  :: " int \<Rightarrow> sop "  where 
     " sop_of_num arg0 = (
   (let l__30 = arg0 in
   if (((l__30 = (( 0 :: int)::ii)))) then RISCV_SLLI
   else if (((l__30 = (( 1 :: int)::ii)))) then RISCV_SRLI
   else RISCV_SRAI))"


(*val num_of_sop : sop -> integer*)

fun num_of_sop  :: " sop \<Rightarrow> int "  where 
     " num_of_sop RISCV_SLLI = ( (( 0 :: int)::ii))"
|" num_of_sop RISCV_SRLI = ( (( 1 :: int)::ii))"
|" num_of_sop RISCV_SRAI = ( (( 2 :: int)::ii))"


(*val rop_of_num : integer -> rop*)

definition rop_of_num  :: " int \<Rightarrow> rop "  where 
     " rop_of_num arg0 = (
   (let l__21 = arg0 in
   if (((l__21 = (( 0 :: int)::ii)))) then RISCV_ADD
   else if (((l__21 = (( 1 :: int)::ii)))) then RISCV_SUB
   else if (((l__21 = (( 2 :: int)::ii)))) then RISCV_SLL
   else if (((l__21 = (( 3 :: int)::ii)))) then RISCV_SLT
   else if (((l__21 = (( 4 :: int)::ii)))) then RISCV_SLTU
   else if (((l__21 = (( 5 :: int)::ii)))) then RISCV_XOR
   else if (((l__21 = (( 6 :: int)::ii)))) then RISCV_SRL
   else if (((l__21 = (( 7 :: int)::ii)))) then RISCV_SRA
   else if (((l__21 = (( 8 :: int)::ii)))) then RISCV_OR
   else RISCV_AND))"


(*val num_of_rop : rop -> integer*)

fun num_of_rop  :: " rop \<Rightarrow> int "  where 
     " num_of_rop RISCV_ADD = ( (( 0 :: int)::ii))"
|" num_of_rop RISCV_SUB = ( (( 1 :: int)::ii))"
|" num_of_rop RISCV_SLL = ( (( 2 :: int)::ii))"
|" num_of_rop RISCV_SLT = ( (( 3 :: int)::ii))"
|" num_of_rop RISCV_SLTU = ( (( 4 :: int)::ii))"
|" num_of_rop RISCV_XOR = ( (( 5 :: int)::ii))"
|" num_of_rop RISCV_SRL = ( (( 6 :: int)::ii))"
|" num_of_rop RISCV_SRA = ( (( 7 :: int)::ii))"
|" num_of_rop RISCV_OR = ( (( 8 :: int)::ii))"
|" num_of_rop RISCV_AND = ( (( 9 :: int)::ii))"


(*val ropw_of_num : integer -> ropw*)

definition ropw_of_num  :: " int \<Rightarrow> ropw "  where 
     " ropw_of_num arg0 = (
   (let l__17 = arg0 in
   if (((l__17 = (( 0 :: int)::ii)))) then RISCV_ADDW
   else if (((l__17 = (( 1 :: int)::ii)))) then RISCV_SUBW
   else if (((l__17 = (( 2 :: int)::ii)))) then RISCV_SLLW
   else if (((l__17 = (( 3 :: int)::ii)))) then RISCV_SRLW
   else RISCV_SRAW))"


(*val num_of_ropw : ropw -> integer*)

fun num_of_ropw  :: " ropw \<Rightarrow> int "  where 
     " num_of_ropw RISCV_ADDW = ( (( 0 :: int)::ii))"
|" num_of_ropw RISCV_SUBW = ( (( 1 :: int)::ii))"
|" num_of_ropw RISCV_SLLW = ( (( 2 :: int)::ii))"
|" num_of_ropw RISCV_SRLW = ( (( 3 :: int)::ii))"
|" num_of_ropw RISCV_SRAW = ( (( 4 :: int)::ii))"


(*val amoop_of_num : integer -> amoop*)

definition amoop_of_num  :: " int \<Rightarrow> amoop "  where 
     " amoop_of_num arg0 = (
   (let l__9 = arg0 in
   if (((l__9 = (( 0 :: int)::ii)))) then AMOSWAP
   else if (((l__9 = (( 1 :: int)::ii)))) then AMOADD
   else if (((l__9 = (( 2 :: int)::ii)))) then AMOXOR
   else if (((l__9 = (( 3 :: int)::ii)))) then AMOAND
   else if (((l__9 = (( 4 :: int)::ii)))) then AMOOR
   else if (((l__9 = (( 5 :: int)::ii)))) then AMOMIN
   else if (((l__9 = (( 6 :: int)::ii)))) then AMOMAX
   else if (((l__9 = (( 7 :: int)::ii)))) then AMOMINU
   else AMOMAXU))"


(*val num_of_amoop : amoop -> integer*)

fun num_of_amoop  :: " amoop \<Rightarrow> int "  where 
     " num_of_amoop AMOSWAP = ( (( 0 :: int)::ii))"
|" num_of_amoop AMOADD = ( (( 1 :: int)::ii))"
|" num_of_amoop AMOXOR = ( (( 2 :: int)::ii))"
|" num_of_amoop AMOAND = ( (( 3 :: int)::ii))"
|" num_of_amoop AMOOR = ( (( 4 :: int)::ii))"
|" num_of_amoop AMOMIN = ( (( 5 :: int)::ii))"
|" num_of_amoop AMOMAX = ( (( 6 :: int)::ii))"
|" num_of_amoop AMOMINU = ( (( 7 :: int)::ii))"
|" num_of_amoop AMOMAXU = ( (( 8 :: int)::ii))"


(*val csrop_of_num : integer -> csrop*)

definition csrop_of_num  :: " int \<Rightarrow> csrop "  where 
     " csrop_of_num arg0 = (
   (let l__7 = arg0 in
   if (((l__7 = (( 0 :: int)::ii)))) then CSRRW
   else if (((l__7 = (( 1 :: int)::ii)))) then CSRRS
   else CSRRC))"


(*val num_of_csrop : csrop -> integer*)

fun num_of_csrop  :: " csrop \<Rightarrow> int "  where 
     " num_of_csrop CSRRW = ( (( 0 :: int)::ii))"
|" num_of_csrop CSRRS = ( (( 1 :: int)::ii))"
|" num_of_csrop CSRRC = ( (( 2 :: int)::ii))"


(*val word_width_of_num : integer -> word_width*)

definition word_width_of_num  :: " int \<Rightarrow> word_width "  where 
     " word_width_of_num arg0 = (
   (let l__4 = arg0 in
   if (((l__4 = (( 0 :: int)::ii)))) then BYTE
   else if (((l__4 = (( 1 :: int)::ii)))) then HALF
   else if (((l__4 = (( 2 :: int)::ii)))) then WORD
   else DOUBLE))"


(*val num_of_word_width : word_width -> integer*)

fun num_of_word_width  :: " word_width \<Rightarrow> int "  where 
     " num_of_word_width BYTE = ( (( 0 :: int)::ii))"
|" num_of_word_width HALF = ( (( 1 :: int)::ii))"
|" num_of_word_width WORD = ( (( 2 :: int)::ii))"
|" num_of_word_width DOUBLE = ( (( 3 :: int)::ii))"


(*val is_aligned_addr : mword ty64 -> integer -> bool*)

definition is_aligned_addr  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " is_aligned_addr (addr :: xlenbits) (width :: int) = (
   (((ex_int ((hardware_mod ((Word.uint addr)) width)))) = (( 0 :: int)::ii)))"


(*val checked_mem_read : forall 'int8_times_n. Size 'int8_times_n => ReadType -> mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

definition checked_mem_read  :: " ReadType \<Rightarrow>(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " checked_mem_read (t :: ReadType) (addr :: xlenbits) (width :: int) = (
   (RISCV_read addr width  :: ( (( 'int8_times_n::len)Word.word)option) M) \<bind> (\<lambda> (w__0 ::
      (( 'int8_times_n::len)Word.word)option) . 
   return ((case  (t, w__0) of
     (Instruction, None) => MemException E_Fetch_Access_Fault
   | (Data, None) => MemException E_Load_Access_Fault
   | (_, Some (v)) => MemValue v
   ))))"


(*val MEMr : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_strong_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_reserved : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_reserved_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

(*val MEMr_reserved_strong_acquire : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> M (MemoryOpResult (mword 'int8_times_n))*)

definition MEMr  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " MEMr addr width = ( (checked_mem_read Data addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))"


definition MEMr_acquire  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " MEMr_acquire addr width = (
   (checked_mem_read Data addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))"


definition MEMr_strong_acquire  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " MEMr_strong_acquire addr width = (
   (checked_mem_read Data addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))"


definition MEMr_reserved  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " MEMr_reserved addr width = (
   (checked_mem_read Data addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))"


definition MEMr_reserved_acquire  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " MEMr_reserved_acquire addr width = (
   (checked_mem_read Data addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))"


definition MEMr_reserved_strong_acquire  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " MEMr_reserved_strong_acquire addr width = (
   (checked_mem_read Data addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M))"


(*val mem_read : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))*)

definition mem_read  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " mem_read addr width aq rl res = (
   if ((((((aq \<or> res))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
     return (MemException E_Load_Addr_Align)
   else
     (case  (aq, rl, res) of
       (False, False, False) => (MEMr addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
     | (True, False, False) => (MEMr_acquire addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
     | (False, False, True) =>
        (MEMr_reserved addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
     | (True, False, True) =>
        (MEMr_reserved_acquire addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
     | (False, True, False) => throw (Error_not_implemented (''load.rl''))
     | (True, True, False) =>
        (MEMr_strong_acquire addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
     | (False, True, True) => throw (Error_not_implemented (''lr.rl''))
     | (True, True, True) =>
        (MEMr_reserved_strong_acquire addr width  :: ( (( 'int8_times_n::len)Word.word)MemoryOpResult) M)
     ))"


(*val mem_write_ea : mword ty64 -> integer -> bool -> bool -> bool -> M (MemoryOpResult unit)*)

definition mem_write_ea  :: "(64)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " mem_write_ea addr width aq rl con = (
   if ((((((rl \<or> con))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
     return (MemException E_SAMO_Addr_Align)
   else
     (case  (aq, rl, con) of
       (False, False, False) => MEMea addr width \<then> return (MemValue () )
     | (False, True, False) => MEMea_release addr width \<then> return (MemValue () )
     | (False, False, True) => MEMea_conditional addr width \<then> return (MemValue () )
     | (False, True, True) => MEMea_conditional_release addr width \<then> return (MemValue () )
     | (True, False, False) => throw (Error_not_implemented (''store.aq''))
     | (True, True, False) => MEMea_strong_release addr width \<then> return (MemValue () )
     | (True, False, True) => throw (Error_not_implemented (''sc.aq''))
     | (True, True, True) => MEMea_conditional_strong_release addr width \<then> return (MemValue () )
     ))"


(*val checked_mem_write : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

definition checked_mem_write  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " checked_mem_write (addr :: xlenbits) (width :: int) (data :: 'int8_times_n bits) = (
   RISCV_write addr width data \<bind> (\<lambda> (w__0 :: bool) . 
   return (if w__0 then MemValue () 
           else MemException E_SAMO_Access_Fault)))"


(*val MEMval : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_strong_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_conditional : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_conditional_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

(*val MEMval_conditional_strong_release : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> M (MemoryOpResult unit)*)

definition MEMval  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " MEMval addr width data = ( checked_mem_write addr width data )"


definition MEMval_release  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " MEMval_release addr width data = ( checked_mem_write addr width data )"


definition MEMval_strong_release  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " MEMval_strong_release addr width data = ( checked_mem_write addr width data )"


definition MEMval_conditional  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " MEMval_conditional addr width data = ( checked_mem_write addr width data )"


definition MEMval_conditional_release  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " MEMval_conditional_release addr width data = ( checked_mem_write addr width data )"


definition MEMval_conditional_strong_release  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " MEMval_conditional_strong_release addr width data = ( checked_mem_write addr width data )"


(*val mem_write_value : forall 'int8_times_n. Size 'int8_times_n => mword ty64 -> integer -> mword 'int8_times_n -> bool -> bool -> bool -> M (MemoryOpResult unit)*)

definition mem_write_value  :: "(64)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " mem_write_value addr width value1 aq rl con = (
   if ((((((rl \<or> con))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
     return (MemException E_SAMO_Addr_Align)
   else
     (case  (aq, rl, con) of
       (False, False, False) => MEMval addr width value1
     | (False, True, False) => MEMval_release addr width value1
     | (False, False, True) => MEMval_conditional addr width value1
     | (False, True, True) => MEMval_conditional_release addr width value1
     | (True, False, False) => throw (Error_not_implemented (''store.aq''))
     | (True, True, False) => MEMval_strong_release addr width value1
     | (True, False, True) => throw (Error_not_implemented (''sc.aq''))
     | (True, True, True) => MEMval_conditional_strong_release addr width value1
     ))"


(*val _get_Misa : Misa -> mword ty64*)

fun get_Misa  :: " Misa \<Rightarrow>(64)Word.word "  where 
     " get_Misa (Mk_Misa (v)) = ( v )"


(*val _set_Misa : register_ref regstate register_value Misa -> mword ty64 -> M unit*)

definition set_Misa  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Misa v) in
   write_reg r_ref r)))"


(*val _get_SV39_PTE : SV39_PTE -> mword ty64*)

(*val _set_SV39_PTE : register_ref regstate register_value SV39_PTE -> mword ty64 -> M unit*)

(*val _get_Misa_MXL : Misa -> mword ty2*)

fun get_Misa_MXL  :: " Misa \<Rightarrow>(2)Word.word "  where 
     " get_Misa_MXL (Mk_Misa (v)) = ( (subrange_vec_dec v (( 63 :: int)::ii) (( 62 :: int)::ii)  ::  2 Word.word))"


(*val _set_Misa_MXL : register_ref regstate register_value Misa -> mword ty2 -> M unit*)

definition set_Misa_MXL  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_MXL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 63 :: int)::ii) (( 62 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_MXL : Misa -> mword ty2 -> Misa*)

fun update_Misa_MXL  :: " Misa \<Rightarrow>(2)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_MXL (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 63 :: int)::ii) (( 62 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_Z : Misa -> mword ty1*)

fun get_Misa_Z  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_Z (Mk_Misa (v)) = ( (subrange_vec_dec v (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_Z : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_Z  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_Z r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 25 :: int)::ii) (( 25 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_Z : Misa -> mword ty1 -> Misa*)

fun update_Misa_Z  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_Z (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 25 :: int)::ii) (( 25 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_Y : Misa -> mword ty1*)

fun get_Misa_Y  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_Y (Mk_Misa (v)) = ( (subrange_vec_dec v (( 24 :: int)::ii) (( 24 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_Y : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_Y  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_Y r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 24 :: int)::ii) (( 24 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_Y : Misa -> mword ty1 -> Misa*)

fun update_Misa_Y  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_Y (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 24 :: int)::ii) (( 24 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_X : Misa -> mword ty1*)

fun get_Misa_X  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_X (Mk_Misa (v)) = ( (subrange_vec_dec v (( 23 :: int)::ii) (( 23 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_X : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_X  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_X r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 23 :: int)::ii) (( 23 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_X : Misa -> mword ty1 -> Misa*)

fun update_Misa_X  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_X (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 23 :: int)::ii) (( 23 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_X : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_X : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_X : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_W : Misa -> mword ty1*)

fun get_Misa_W  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_W (Mk_Misa (v)) = ( (subrange_vec_dec v (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_W : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_W  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_W r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 22 :: int)::ii) (( 22 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_W : Misa -> mword ty1 -> Misa*)

fun update_Misa_W  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_W (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 22 :: int)::ii) (( 22 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_W : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_W : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_W : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_V : Misa -> mword ty1*)

fun get_Misa_V  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_V (Mk_Misa (v)) = ( (subrange_vec_dec v (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_V : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_V  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_V r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 21 :: int)::ii) (( 21 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_V : Misa -> mword ty1 -> Misa*)

fun update_Misa_V  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_V (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 21 :: int)::ii) (( 21 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_V : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_V : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_V : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_U : Misa -> mword ty1*)

fun get_Misa_U  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_U (Mk_Misa (v)) = ( (subrange_vec_dec v (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_U : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_U  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_U r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 20 :: int)::ii) (( 20 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_U : Misa -> mword ty1 -> Misa*)

fun update_Misa_U  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_U (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 20 :: int)::ii) (( 20 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_U : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_U : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_U : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_T : Misa -> mword ty1*)

fun get_Misa_T  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_T (Mk_Misa (v)) = ( (subrange_vec_dec v (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_T : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_T  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_T r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 19 :: int)::ii) (( 19 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_T : Misa -> mword ty1 -> Misa*)

fun update_Misa_T  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_T (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 19 :: int)::ii) (( 19 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_S : Misa -> mword ty1*)

fun get_Misa_S  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_S (Mk_Misa (v)) = ( (subrange_vec_dec v (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_S : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_S  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_S r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 18 :: int)::ii) (( 18 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_S : Misa -> mword ty1 -> Misa*)

fun update_Misa_S  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_S (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 18 :: int)::ii) (( 18 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_R : Misa -> mword ty1*)

fun get_Misa_R  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_R (Mk_Misa (v)) = ( (subrange_vec_dec v (( 17 :: int)::ii) (( 17 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_R : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_R  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_R r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 17 :: int)::ii) (( 17 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_R : Misa -> mword ty1 -> Misa*)

fun update_Misa_R  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_R (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 17 :: int)::ii) (( 17 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_R : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_R : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_R : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_Q : Misa -> mword ty1*)

fun get_Misa_Q  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_Q (Mk_Misa (v)) = ( (subrange_vec_dec v (( 16 :: int)::ii) (( 16 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_Q : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_Q  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_Q r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 16 :: int)::ii) (( 16 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_Q : Misa -> mword ty1 -> Misa*)

fun update_Misa_Q  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_Q (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 16 :: int)::ii) (( 16 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_P : Misa -> mword ty1*)

fun get_Misa_P  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_P (Mk_Misa (v)) = ( (subrange_vec_dec v (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_P : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_P  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_P r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 15 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_P : Misa -> mword ty1 -> Misa*)

fun update_Misa_P  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_P (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 15 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_O : Misa -> mword ty1*)

fun get_Misa_O  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_O (Mk_Misa (v)) = ( (subrange_vec_dec v (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_O : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_O  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_O r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 14 :: int)::ii) (( 14 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_O : Misa -> mword ty1 -> Misa*)

fun update_Misa_O  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_O (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 14 :: int)::ii) (( 14 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_N : Misa -> mword ty1*)

fun get_Misa_N  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_N (Mk_Misa (v)) = ( (subrange_vec_dec v (( 13 :: int)::ii) (( 13 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_N : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_N  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_N r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 13 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_N : Misa -> mword ty1 -> Misa*)

fun update_Misa_N  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_N (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 13 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_M : Misa -> mword ty1*)

fun get_Misa_M  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_M (Mk_Misa (v)) = ( (subrange_vec_dec v (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_M : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_M  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_M r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 12 :: int)::ii) (( 12 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_M : Misa -> mword ty1 -> Misa*)

fun update_Misa_M  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_M (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 12 :: int)::ii) (( 12 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_L : Misa -> mword ty1*)

fun get_Misa_L  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_L (Mk_Misa (v)) = ( (subrange_vec_dec v (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_L : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_L  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_L r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 11 :: int)::ii) (( 11 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_L : Misa -> mword ty1 -> Misa*)

fun update_Misa_L  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_L (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 11 :: int)::ii) (( 11 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_K : Misa -> mword ty1*)

fun get_Misa_K  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_K (Mk_Misa (v)) = ( (subrange_vec_dec v (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_K : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_K  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_K r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 10 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_K : Misa -> mword ty1 -> Misa*)

fun update_Misa_K  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_K (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 10 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_J : Misa -> mword ty1*)

fun get_Misa_J  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_J (Mk_Misa (v)) = ( (subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_J : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_J  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_J r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_J : Misa -> mword ty1 -> Misa*)

fun update_Misa_J  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_J (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_I : Misa -> mword ty1*)

fun get_Misa_I  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_I (Mk_Misa (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_I : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_I  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_I r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_I : Misa -> mword ty1 -> Misa*)

fun update_Misa_I  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_I (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_H : Misa -> mword ty1*)

fun get_Misa_H  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_H (Mk_Misa (v)) = ( (subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_H : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_H  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_H r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_H : Misa -> mword ty1 -> Misa*)

fun update_Misa_H  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_H (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_G : Misa -> mword ty1*)

fun get_Misa_G  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_G (Mk_Misa (v)) = ( (subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_G : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_G  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_G r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_G : Misa -> mword ty1 -> Misa*)

fun update_Misa_G  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_G (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_G : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_G : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_G : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_F : Misa -> mword ty1*)

fun get_Misa_F  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_F (Mk_Misa (v)) = ( (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_F : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_F  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_F r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_F : Misa -> mword ty1 -> Misa*)

fun update_Misa_F  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_F (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_E : Misa -> mword ty1*)

fun get_Misa_E  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_E (Mk_Misa (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_E : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_E  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_E r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_E : Misa -> mword ty1 -> Misa*)

fun update_Misa_E  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_E (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_D : Misa -> mword ty1*)

fun get_Misa_D  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_D (Mk_Misa (v)) = ( (subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_D : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_D  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_D r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_D : Misa -> mword ty1 -> Misa*)

fun update_Misa_D  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_D (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_D : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_D : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_D : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val _get_Misa_C : Misa -> mword ty1*)

fun get_Misa_C  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_C (Mk_Misa (v)) = ( (subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_C : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_C  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_C r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_C : Misa -> mword ty1 -> Misa*)

fun update_Misa_C  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_C (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_B : Misa -> mword ty1*)

fun get_Misa_B  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_B (Mk_Misa (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_B : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_B  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_B r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_B : Misa -> mword ty1 -> Misa*)

fun update_Misa_B  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_B (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Misa_A : Misa -> mword ty1*)

fun get_Misa_A  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_A (Mk_Misa (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_Misa_A : register_ref regstate register_value Misa -> mword ty1 -> M unit*)

definition set_Misa_A  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_A r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   (let r = ((get_Misa w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Misa r)))))"


(*val _update_Misa_A : Misa -> mword ty1 -> Misa*)

fun update_Misa_A  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_A (Mk_Misa (v)) x = (
   Mk_Misa ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_PTE_Bits_A : PTE_Bits -> mword ty1 -> PTE_Bits*)

(*val _get_PTE_Bits_A : PTE_Bits -> mword ty1*)

(*val _set_PTE_Bits_A : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit*)

(*val legalize_misa : Misa -> mword ty64 -> Misa*)

definition legalize_misa  :: " Misa \<Rightarrow>(64)Word.word \<Rightarrow> Misa "  where 
     " legalize_misa (m :: Misa) (v :: xlenbits) = ( m )"


(*val _get_Mstatus : Mstatus -> mword ty64*)

fun get_Mstatus  :: " Mstatus \<Rightarrow>(64)Word.word "  where 
     " get_Mstatus (Mk_Mstatus (v)) = ( v )"


(*val _set_Mstatus : register_ref regstate register_value Mstatus -> mword ty64 -> M unit*)

definition set_Mstatus  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Mstatus v) in
   write_reg r_ref r)))"


(*val _get_Mstatus_SD : Mstatus -> mword ty1*)

fun get_Mstatus_SD  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SD (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_SD : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_SD  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SD r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_SD : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_SD  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SD (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_SD : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SD : Sstatus -> mword ty1*)

(*val _set_Sstatus_SD : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_SXL : Mstatus -> mword ty2*)

fun get_Mstatus_SXL  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_SXL (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 35 :: int)::ii) (( 34 :: int)::ii)  ::  2 Word.word))"


(*val _set_Mstatus_SXL : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

definition set_Mstatus_SXL  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SXL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 35 :: int)::ii) (( 34 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_SXL : Mstatus -> mword ty2 -> Mstatus*)

fun update_Mstatus_SXL  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SXL (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 35 :: int)::ii) (( 34 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_UXL : Mstatus -> mword ty2*)

fun get_Mstatus_UXL  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_UXL (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 33 :: int)::ii) (( 32 :: int)::ii)  ::  2 Word.word))"


(*val _set_Mstatus_UXL : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

definition set_Mstatus_UXL  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_UXL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 33 :: int)::ii) (( 32 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_UXL : Mstatus -> mword ty2 -> Mstatus*)

fun update_Mstatus_UXL  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_UXL (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 33 :: int)::ii) (( 32 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_UXL : Sstatus -> mword ty2 -> Sstatus*)

(*val _get_Sstatus_UXL : Sstatus -> mword ty2*)

(*val _set_Sstatus_UXL : register_ref regstate register_value Sstatus -> mword ty2 -> M unit*)

(*val _get_Mstatus_TSR : Mstatus -> mword ty1*)

fun get_Mstatus_TSR  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_TSR (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_TSR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_TSR  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_TSR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 22 :: int)::ii) (( 22 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_TSR : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_TSR  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_TSR (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 22 :: int)::ii) (( 22 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_TW : Mstatus -> mword ty1*)

fun get_Mstatus_TW  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_TW (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_TW : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_TW  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_TW r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 21 :: int)::ii) (( 21 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_TW : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_TW  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_TW (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 21 :: int)::ii) (( 21 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_TVM : Mstatus -> mword ty1*)

fun get_Mstatus_TVM  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_TVM (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_TVM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_TVM  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_TVM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 20 :: int)::ii) (( 20 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_TVM : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_TVM  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_TVM (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 20 :: int)::ii) (( 20 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_MXR : Mstatus -> mword ty1*)

fun get_Mstatus_MXR  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MXR (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_MXR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_MXR  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MXR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 19 :: int)::ii) (( 19 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_MXR : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_MXR  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MXR (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 19 :: int)::ii) (( 19 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_MXR : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_MXR : Sstatus -> mword ty1*)

(*val _set_Sstatus_MXR : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_SUM : Mstatus -> mword ty1*)

fun get_Mstatus_SUM  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SUM (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_SUM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_SUM  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SUM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 18 :: int)::ii) (( 18 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_SUM : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_SUM  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SUM (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 18 :: int)::ii) (( 18 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_SUM : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SUM : Sstatus -> mword ty1*)

(*val _set_Sstatus_SUM : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_MPRV : Mstatus -> mword ty1*)

fun get_Mstatus_MPRV  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MPRV (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 17 :: int)::ii) (( 17 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_MPRV : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_MPRV  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MPRV r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 17 :: int)::ii) (( 17 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_MPRV : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_MPRV  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MPRV (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 17 :: int)::ii) (( 17 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_XS : Mstatus -> mword ty2*)

fun get_Mstatus_XS  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_XS (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word))"


(*val _set_Mstatus_XS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

definition set_Mstatus_XS  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_XS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 16 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_XS : Mstatus -> mword ty2 -> Mstatus*)

fun update_Mstatus_XS  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_XS (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 16 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_XS : Sstatus -> mword ty2 -> Sstatus*)

(*val _get_Sstatus_XS : Sstatus -> mword ty2*)

(*val _set_Sstatus_XS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit*)

(*val _get_Mstatus_FS : Mstatus -> mword ty2*)

fun get_Mstatus_FS  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_FS (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word))"


(*val _set_Mstatus_FS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

definition set_Mstatus_FS  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_FS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 14 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_FS : Mstatus -> mword ty2 -> Mstatus*)

fun update_Mstatus_FS  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_FS (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 14 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_FS : Sstatus -> mword ty2 -> Sstatus*)

(*val _get_Sstatus_FS : Sstatus -> mword ty2*)

(*val _set_Sstatus_FS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit*)

(*val _get_Mstatus_MPP : Mstatus -> mword ty2*)

fun get_Mstatus_MPP  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_MPP (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word))"


(*val _set_Mstatus_MPP : register_ref regstate register_value Mstatus -> mword ty2 -> M unit*)

definition set_Mstatus_MPP  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MPP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 12 :: int)::ii) (( 11 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_MPP : Mstatus -> mword ty2 -> Mstatus*)

fun update_Mstatus_MPP  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MPP (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 12 :: int)::ii) (( 11 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_SPP : Mstatus -> mword ty1*)

fun get_Mstatus_SPP  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SPP (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_SPP : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_SPP  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SPP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_SPP : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_SPP  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SPP (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_SPP : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SPP : Sstatus -> mword ty1*)

(*val _set_Sstatus_SPP : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_MPIE : Mstatus -> mword ty1*)

fun get_Mstatus_MPIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MPIE (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_MPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_MPIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_MPIE : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_MPIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MPIE (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_SPIE : Mstatus -> mword ty1*)

fun get_Mstatus_SPIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SPIE (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_SPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_SPIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_SPIE : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_SPIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SPIE (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_SPIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SPIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_SPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_UPIE : Mstatus -> mword ty1*)

fun get_Mstatus_UPIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_UPIE (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_UPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_UPIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_UPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_UPIE : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_UPIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_UPIE (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_UPIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_UPIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_UPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_MIE : Mstatus -> mword ty1*)

fun get_Mstatus_MIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MIE (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_MIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_MIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_MIE : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_MIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MIE (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mstatus_SIE : Mstatus -> mword ty1*)

fun get_Mstatus_SIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SIE (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_SIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_SIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_SIE : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_SIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SIE (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_SIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_SIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_SIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val _get_Mstatus_UIE : Mstatus -> mword ty1*)

fun get_Mstatus_UIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_UIE (Mk_Mstatus (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mstatus_UIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit*)

definition set_Mstatus_UIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_UIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
   (let r = ((get_Mstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mstatus r)))))"


(*val _update_Mstatus_UIE : Mstatus -> mword ty1 -> Mstatus*)

fun update_Mstatus_UIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_UIE (Mk_Mstatus (v)) x = (
   Mk_Mstatus ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sstatus_UIE : Sstatus -> mword ty1 -> Sstatus*)

(*val _get_Sstatus_UIE : Sstatus -> mword ty1*)

(*val _set_Sstatus_UIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit*)

(*val legalize_mstatus : Mstatus -> mword ty64 -> Mstatus*)

definition legalize_mstatus  :: " Mstatus \<Rightarrow>(64)Word.word \<Rightarrow> Mstatus "  where 
     " legalize_mstatus (o1 :: Mstatus) (v :: xlenbits) = (
   (let (m :: Mstatus) = (Mk_Mstatus v) in
   (let m = (update_Mstatus_XS m ((extStatus_to_bits Off  ::  2 Word.word))) in
   (let m =
     (update_Mstatus_SD m
       ((bool_to_bits
           ((((((((extStatus_to_bits ((extStatus_of_bits ((get_Mstatus_FS m  ::  2 Word.word))))
                      ::  2 Word.word)) = ((extStatus_to_bits Dirty  ::  2 Word.word))))) \<or> (((((extStatus_to_bits ((extStatus_of_bits ((get_Mstatus_XS m  ::  2 Word.word))))
                      ::  2 Word.word)) = ((extStatus_to_bits Dirty  ::  2 Word.word))))))))
          ::  1 Word.word))) in
   (let m = (update_Mstatus_SXL m ((get_Mstatus_SXL o1  ::  2 Word.word))) in
   (let m = (update_Mstatus_UXL m ((get_Mstatus_UXL o1  ::  2 Word.word))) in
   (let m = (update_Mstatus_UPIE m ((bool_to_bits False  ::  1 Word.word))) in
   update_Mstatus_UIE m ((bool_to_bits False  ::  1 Word.word)))))))))"


(*val cur_Architecture : unit -> M Architecture*)

definition cur_Architecture  :: " unit \<Rightarrow>((register_value),(Architecture),(exception))monad "  where 
     " cur_Architecture _ = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     Machine =>
      read_reg misa_ref \<bind> (\<lambda> (w__1 :: Misa) .  return ((get_Misa_MXL w__1  ::  2 Word.word)))
   | Supervisor =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) .  return ((get_Mstatus_SXL w__2  ::  2 Word.word)))
   | User =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__3 :: Mstatus) .  return ((get_Mstatus_UXL w__3  ::  2 Word.word)))
   ) \<bind> (\<lambda> (a :: arch_xlen) . 
   (case  ((architecture a)) of
     Some (a) => return a
   | None => internal_error (''Invalid current architecture'')
   ))))"


(*val in32BitMode : unit -> M bool*)

definition in32BitMode  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " in32BitMode _ = ( cur_Architecture ()  \<bind> (\<lambda> (w__0 :: Architecture) .  return (((w__0 = RV32)))))"


(*val haveAtomics : unit -> M bool*)

definition haveAtomics  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveAtomics _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_A w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


(*val haveRVC : unit -> M bool*)

definition haveRVC  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveRVC _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_C w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


(*val haveMulDiv : unit -> M bool*)

definition haveMulDiv  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveMulDiv _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_M w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


(*val haveFP : unit -> M bool*)

definition haveFP  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveFP _ = (
   or_boolM
     (read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
      return (((((get_Misa_F w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
     (read_reg misa_ref \<bind> (\<lambda> (w__1 :: Misa) . 
      return (((((get_Misa_D w__1  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))))"


(*val _get_Minterrupts : Minterrupts -> mword ty64*)

fun get_Minterrupts  :: " Minterrupts \<Rightarrow>(64)Word.word "  where 
     " get_Minterrupts (Mk_Minterrupts (v)) = ( v )"


(*val _set_Minterrupts : register_ref regstate register_value Minterrupts -> mword ty64 -> M unit*)

definition set_Minterrupts  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Minterrupts v) in
   write_reg r_ref r)))"


(*val _get_Minterrupts_MEI : Minterrupts -> mword ty1*)

fun get_Minterrupts_MEI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_MEI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_MEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_MEI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_MEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 11 :: int)::ii) (( 11 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_MEI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_MEI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_MEI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 11 :: int)::ii) (( 11 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Minterrupts_SEI : Minterrupts -> mword ty1*)

fun get_Minterrupts_SEI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_SEI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_SEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_SEI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_SEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_SEI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_SEI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_SEI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sinterrupts_SEI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_SEI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_SEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_UEI : Minterrupts -> mword ty1*)

fun get_Minterrupts_UEI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_UEI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_UEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_UEI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_UEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_UEI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_UEI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_UEI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sinterrupts_UEI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_UEI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_UEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_MTI : Minterrupts -> mword ty1*)

fun get_Minterrupts_MTI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_MTI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_MTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_MTI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_MTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_MTI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_MTI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_MTI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Minterrupts_STI : Minterrupts -> mword ty1*)

fun get_Minterrupts_STI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_STI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_STI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_STI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_STI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_STI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_STI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_STI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sinterrupts_STI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_STI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_STI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_UTI : Minterrupts -> mword ty1*)

fun get_Minterrupts_UTI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_UTI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_UTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_UTI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_UTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_UTI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_UTI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_UTI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sinterrupts_UTI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_UTI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_UTI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_MSI : Minterrupts -> mword ty1*)

fun get_Minterrupts_MSI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_MSI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_MSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_MSI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_MSI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_MSI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_MSI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_MSI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Minterrupts_SSI : Minterrupts -> mword ty1*)

fun get_Minterrupts_SSI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_SSI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_SSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_SSI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_SSI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_SSI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_SSI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_SSI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sinterrupts_SSI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_SSI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_SSI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val _get_Minterrupts_USI : Minterrupts -> mword ty1*)

fun get_Minterrupts_USI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_USI (Mk_Minterrupts (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_Minterrupts_USI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit*)

definition set_Minterrupts_USI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_USI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   (let r = ((get_Minterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Minterrupts r)))))"


(*val _update_Minterrupts_USI : Minterrupts -> mword ty1 -> Minterrupts*)

fun update_Minterrupts_USI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_USI (Mk_Minterrupts (v)) x = (
   Mk_Minterrupts ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sinterrupts_USI : Sinterrupts -> mword ty1 -> Sinterrupts*)

(*val _get_Sinterrupts_USI : Sinterrupts -> mword ty1*)

(*val _set_Sinterrupts_USI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit*)

(*val legalize_mip : Minterrupts -> mword ty64 -> Minterrupts*)

definition legalize_mip  :: " Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts "  where 
     " legalize_mip (o1 :: Minterrupts) (v :: xlenbits) = (
   (let v = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_SEI o1 ((get_Minterrupts_SEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  ::  1 Word.word))) in
   update_Minterrupts_SSI m ((get_Minterrupts_SSI v  ::  1 Word.word))))))"


(*val legalize_mie : Minterrupts -> mword ty64 -> Minterrupts*)

definition legalize_mie  :: " Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts "  where 
     " legalize_mie (o1 :: Minterrupts) (v :: xlenbits) = (
   (let v = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_MEI o1 ((get_Minterrupts_MEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MTI m ((get_Minterrupts_MTI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MSI m ((get_Minterrupts_MSI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SEI m ((get_Minterrupts_SEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  ::  1 Word.word))) in
   update_Minterrupts_SSI m ((get_Minterrupts_SSI v  ::  1 Word.word)))))))))"


(*val legalize_mideleg : Minterrupts -> mword ty64 -> Minterrupts*)

definition legalize_mideleg  :: " Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts "  where 
     " legalize_mideleg (o1 :: Minterrupts) (v :: xlenbits) = (
   (let m = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_MEI m ((bool_to_bits False  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MTI m ((bool_to_bits False  ::  1 Word.word))) in
   update_Minterrupts_MSI m ((bool_to_bits False  ::  1 Word.word))))))"


(*val _get_Medeleg : Medeleg -> mword ty64*)

fun get_Medeleg  :: " Medeleg \<Rightarrow>(64)Word.word "  where 
     " get_Medeleg (Mk_Medeleg (v)) = ( v )"


(*val _set_Medeleg : register_ref regstate register_value Medeleg -> mword ty64 -> M unit*)

definition set_Medeleg  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Medeleg v) in
   write_reg r_ref r)))"


(*val _get_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1*)

fun get_Medeleg_SAMO_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SAMO_Page_Fault (Mk_Medeleg (v)) = (
   (subrange_vec_dec v (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_SAMO_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_SAMO_Page_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SAMO_Page_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 15 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_SAMO_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SAMO_Page_Fault (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 15 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Medeleg_Load_Page_Fault : Medeleg -> mword ty1*)

fun get_Medeleg_Load_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Load_Page_Fault (Mk_Medeleg (v)) = (
   (subrange_vec_dec v (( 13 :: int)::ii) (( 13 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Load_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Load_Page_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Load_Page_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 13 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Load_Page_Fault : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Load_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Load_Page_Fault (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 13 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1*)

fun get_Medeleg_Fetch_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Fetch_Page_Fault (Mk_Medeleg (v)) = (
   (subrange_vec_dec v (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Fetch_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Fetch_Page_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Fetch_Page_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 12 :: int)::ii) (( 12 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Fetch_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Fetch_Page_Fault (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 12 :: int)::ii) (( 12 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Medeleg_MEnvCall : Medeleg -> mword ty1*)

fun get_Medeleg_MEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_MEnvCall (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_MEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_MEnvCall  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_MEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 10 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_MEnvCall : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_MEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_MEnvCall (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 10 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Medeleg_SEnvCall : Medeleg -> mword ty1*)

fun get_Medeleg_SEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SEnvCall (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_SEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_SEnvCall  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_SEnvCall : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_SEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SEnvCall (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Medeleg_UEnvCall : Medeleg -> mword ty1*)

fun get_Medeleg_UEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_UEnvCall (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_UEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_UEnvCall  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_UEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_UEnvCall : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_UEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_UEnvCall (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_UEnvCall : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_UEnvCall : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_UEnvCall : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1*)

fun get_Medeleg_SAMO_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SAMO_Access_Fault (Mk_Medeleg (v)) = (
   (subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_SAMO_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_SAMO_Access_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SAMO_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_SAMO_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SAMO_Access_Fault (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_SAMO_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1*)

fun get_Medeleg_SAMO_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SAMO_Addr_Align (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_SAMO_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_SAMO_Addr_Align  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SAMO_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_SAMO_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SAMO_Addr_Align (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_SAMO_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Load_Access_Fault : Medeleg -> mword ty1*)

fun get_Medeleg_Load_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Load_Access_Fault (Mk_Medeleg (v)) = (
   (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Load_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Load_Access_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Load_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Load_Access_Fault : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Load_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Load_Access_Fault (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Load_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Load_Addr_Align : Medeleg -> mword ty1*)

fun get_Medeleg_Load_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Load_Addr_Align (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Load_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Load_Addr_Align  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Load_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Load_Addr_Align : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Load_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Load_Addr_Align (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Load_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Breakpoint : Medeleg -> mword ty1*)

fun get_Medeleg_Breakpoint  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Breakpoint (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Breakpoint : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Breakpoint  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Breakpoint r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Breakpoint : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Breakpoint  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Breakpoint (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_Breakpoint : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Breakpoint : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Breakpoint : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Illegal_Instr : Medeleg -> mword ty1*)

fun get_Medeleg_Illegal_Instr  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Illegal_Instr (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Illegal_Instr : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Illegal_Instr  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Illegal_Instr r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Illegal_Instr : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Illegal_Instr  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Illegal_Instr (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Illegal_Instr : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1*)

fun get_Medeleg_Fetch_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Fetch_Access_Fault (Mk_Medeleg (v)) = (
   (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Fetch_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Fetch_Access_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Fetch_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Fetch_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Fetch_Access_Fault (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Fetch_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val _get_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1*)

fun get_Medeleg_Fetch_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Fetch_Addr_Align (Mk_Medeleg (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


(*val _set_Medeleg_Fetch_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit*)

definition set_Medeleg_Fetch_Addr_Align  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Fetch_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let r = ((get_Medeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Medeleg r)))))"


(*val _update_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1 -> Medeleg*)

fun update_Medeleg_Fetch_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Fetch_Addr_Align (Mk_Medeleg (v)) x = (
   Mk_Medeleg ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg*)

(*val _get_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1*)

(*val _set_Sedeleg_Fetch_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit*)

(*val legalize_medeleg : Medeleg -> mword ty64 -> Medeleg*)

definition legalize_medeleg  :: " Medeleg \<Rightarrow>(64)Word.word \<Rightarrow> Medeleg "  where 
     " legalize_medeleg (o1 :: Medeleg) (v :: xlenbits) = (
   (let m = (Mk_Medeleg v) in
   update_Medeleg_MEnvCall m ((bool_to_bits False  ::  1 Word.word))))"


(*val _get_Mtvec : Mtvec -> mword ty64*)

fun get_Mtvec  :: " Mtvec \<Rightarrow>(64)Word.word "  where 
     " get_Mtvec (Mk_Mtvec (v)) = ( v )"


(*val _set_Mtvec : register_ref regstate register_value Mtvec -> mword ty64 -> M unit*)

definition set_Mtvec  :: "((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mtvec r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Mtvec v) in
   write_reg r_ref r)))"


(*val _get_Mtvec_Base : Mtvec -> mword ty62*)

fun get_Mtvec_Base  :: " Mtvec \<Rightarrow>(62)Word.word "  where 
     " get_Mtvec_Base (Mk_Mtvec (v)) = ( (subrange_vec_dec v (( 63 :: int)::ii) (( 2 :: int)::ii)  ::  62 Word.word))"


(*val _set_Mtvec_Base : register_ref regstate register_value Mtvec -> mword ty62 -> M unit*)

definition set_Mtvec_Base  :: "((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(62)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mtvec_Base r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mtvec) . 
   (let r = ((get_Mtvec w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 63 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mtvec r)))))"


(*val _update_Mtvec_Base : Mtvec -> mword ty62 -> Mtvec*)

fun update_Mtvec_Base  :: " Mtvec \<Rightarrow>(62)Word.word \<Rightarrow> Mtvec "  where 
     " update_Mtvec_Base (Mk_Mtvec (v)) x = (
   Mk_Mtvec ((update_subrange_vec_dec v (( 63 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mtvec_Mode : Mtvec -> mword ty2*)

fun get_Mtvec_Mode  :: " Mtvec \<Rightarrow>(2)Word.word "  where 
     " get_Mtvec_Mode (Mk_Mtvec (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))"


(*val _set_Mtvec_Mode : register_ref regstate register_value Mtvec -> mword ty2 -> M unit*)

definition set_Mtvec_Mode  :: "((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mtvec_Mode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mtvec) . 
   (let r = ((get_Mtvec w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mtvec r)))))"


(*val _update_Mtvec_Mode : Mtvec -> mword ty2 -> Mtvec*)

fun update_Mtvec_Mode  :: " Mtvec \<Rightarrow>(2)Word.word \<Rightarrow> Mtvec "  where 
     " update_Mtvec_Mode (Mk_Mtvec (v)) x = (
   Mk_Mtvec ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val _update_Satp64_Mode : Satp64 -> mword ty4 -> Satp64*)

(*val _get_Satp64_Mode : Satp64 -> mword ty4*)

(*val _set_Satp64_Mode : register_ref regstate register_value Satp64 -> mword ty4 -> M unit*)

(*val legalize_tvec : Mtvec -> mword ty64 -> Mtvec*)

definition legalize_tvec  :: " Mtvec \<Rightarrow>(64)Word.word \<Rightarrow> Mtvec "  where 
     " legalize_tvec (o1 :: Mtvec) (v :: xlenbits) = (
   (let v = (Mk_Mtvec v) in
   (case  ((trapVectorMode_of_bits ((get_Mtvec_Mode v  ::  2 Word.word)))) of
     TV_Direct => v
   | TV_Vector => v
   | _ => update_Mtvec_Mode v ((get_Mtvec_Mode o1  ::  2 Word.word))
   )))"


(*val _get_Mcause : Mcause -> mword ty64*)

fun get_Mcause  :: " Mcause \<Rightarrow>(64)Word.word "  where 
     " get_Mcause (Mk_Mcause (v)) = ( v )"


(*val _set_Mcause : register_ref regstate register_value Mcause -> mword ty64 -> M unit*)

definition set_Mcause  :: "((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mcause r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Mcause v) in
   write_reg r_ref r)))"


(*val _get_Mcause_IsInterrupt : Mcause -> mword ty1*)

fun get_Mcause_IsInterrupt  :: " Mcause \<Rightarrow>(1)Word.word "  where 
     " get_Mcause_IsInterrupt (Mk_Mcause (v)) = ( (subrange_vec_dec v (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))"


(*val _set_Mcause_IsInterrupt : register_ref regstate register_value Mcause -> mword ty1 -> M unit*)

definition set_Mcause_IsInterrupt  :: "((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mcause_IsInterrupt r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mcause) . 
   (let r = ((get_Mcause w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mcause r)))))"


(*val _update_Mcause_IsInterrupt : Mcause -> mword ty1 -> Mcause*)

fun update_Mcause_IsInterrupt  :: " Mcause \<Rightarrow>(1)Word.word \<Rightarrow> Mcause "  where 
     " update_Mcause_IsInterrupt (Mk_Mcause (v)) x = (
   Mk_Mcause ((update_subrange_vec_dec v (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Mcause_Cause : Mcause -> mword ty63*)

fun get_Mcause_Cause  :: " Mcause \<Rightarrow>(63)Word.word "  where 
     " get_Mcause_Cause (Mk_Mcause (v)) = ( (subrange_vec_dec v (( 62 :: int)::ii) (( 0 :: int)::ii)  ::  63 Word.word))"


(*val _set_Mcause_Cause : register_ref regstate register_value Mcause -> mword ty63 -> M unit*)

definition set_Mcause_Cause  :: "((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(63)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mcause_Cause r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Mcause) . 
   (let r = ((get_Mcause w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 62 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Mcause r)))))"


(*val _update_Mcause_Cause : Mcause -> mword ty63 -> Mcause*)

fun update_Mcause_Cause  :: " Mcause \<Rightarrow>(63)Word.word \<Rightarrow> Mcause "  where 
     " update_Mcause_Cause (Mk_Mcause (v)) x = (
   Mk_Mcause ((update_subrange_vec_dec v (( 62 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val tvec_addr : Mtvec -> Mcause -> maybe (mword ty64)*)

definition tvec_addr  :: " Mtvec \<Rightarrow> Mcause \<Rightarrow>((64)Word.word)option "  where 
     " tvec_addr (m :: Mtvec) (c :: Mcause) = (
   (let (base :: xlenbits) =
     ((concat_vec ((get_Mtvec_Base m  ::  62 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
       ::  64 Word.word)) in
   (case  ((trapVectorMode_of_bits ((get_Mtvec_Mode m  ::  2 Word.word)))) of
     TV_Direct => Some base
   | TV_Vector =>
      if (((((get_Mcause_IsInterrupt c  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
      then
        Some ((add_vec base
                 ((shift_bits_left
                     ((EXTZ (( 64 :: int)::ii) ((get_Mcause_Cause c  ::  63 Word.word))  ::  64 Word.word))
                     (vec_of_bits [B1,B0]  ::  2 Word.word)
                    ::  64 Word.word))
                ::  64 Word.word))
      else Some base
   | TV_Reserved => None
   )))"


(*val legalize_xepc : mword ty64 -> M (mword ty64)*)

definition legalize_xepc  :: "(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " legalize_xepc v = (
   haveRVC ()  \<bind> (\<lambda> (w__0 :: bool) . 
   return ((and_vec v
              ((EXTS (( 64 :: int)::ii)
                  (if w__0 then (vec_of_bits [B1,B1,B0]  ::  3 Word.word)
                   else (vec_of_bits [B1,B0,B0]  ::  3 Word.word))
                 ::  64 Word.word))
             ::  64 Word.word))))"


(*val _get_Sstatus : Sstatus -> mword ty64*)

fun get_Sstatus  :: " Sstatus \<Rightarrow>(64)Word.word "  where 
     " get_Sstatus (Mk_Sstatus (v)) = ( v )"


(*val _set_Sstatus : register_ref regstate register_value Sstatus -> mword ty64 -> M unit*)

definition set_Sstatus  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Sstatus v) in
   write_reg r_ref r)))"


fun get_Sstatus_SD  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SD (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 63 :: int)::ii) (( 63 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_SD  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SD r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 63 :: int)::ii) (( 63 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_SD  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SD (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 63 :: int)::ii) (( 63 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_UXL  :: " Sstatus \<Rightarrow>(2)Word.word "  where 
     " get_Sstatus_UXL (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 33 :: int)::ii) (( 32 :: int)::ii)  ::  2 Word.word))"


definition set_Sstatus_UXL  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_UXL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 33 :: int)::ii) (( 32 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_UXL  :: " Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_UXL (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 33 :: int)::ii) (( 32 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_MXR  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_MXR (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_MXR  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_MXR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 19 :: int)::ii) (( 19 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_MXR  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_MXR (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 19 :: int)::ii) (( 19 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_SUM  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SUM (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_SUM  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SUM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 18 :: int)::ii) (( 18 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_SUM  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SUM (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 18 :: int)::ii) (( 18 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_XS  :: " Sstatus \<Rightarrow>(2)Word.word "  where 
     " get_Sstatus_XS (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word))"


definition set_Sstatus_XS  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_XS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 16 :: int)::ii) (( 15 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_XS  :: " Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_XS (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 16 :: int)::ii) (( 15 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_FS  :: " Sstatus \<Rightarrow>(2)Word.word "  where 
     " get_Sstatus_FS (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word))"


definition set_Sstatus_FS  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_FS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 14 :: int)::ii) (( 13 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_FS  :: " Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_FS (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 14 :: int)::ii) (( 13 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_SPP  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SPP (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_SPP  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SPP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_SPP  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SPP (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_SPIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SPIE (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_SPIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_SPIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SPIE (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_UPIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_UPIE (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_UPIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_UPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_UPIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_UPIE (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_SIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SIE (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_SIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_SIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SIE (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sstatus_UIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_UIE (Mk_Sstatus (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


definition set_Sstatus_UIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_UIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sstatus) . 
   (let r = ((get_Sstatus w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sstatus r)))))"


fun update_Sstatus_UIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_UIE (Mk_Sstatus (v)) x = (
   Mk_Sstatus ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val lower_mstatus : Mstatus -> Sstatus*)

definition lower_mstatus  :: " Mstatus \<Rightarrow> Sstatus "  where 
     " lower_mstatus m = (
   (let s = (Mk_Sstatus ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) in
   (let s = (update_Sstatus_SD s ((get_Mstatus_SD m  ::  1 Word.word))) in
   (let s = (update_Sstatus_UXL s ((get_Mstatus_UXL m  ::  2 Word.word))) in
   (let s = (update_Sstatus_MXR s ((get_Mstatus_MXR m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SUM s ((get_Mstatus_SUM m  ::  1 Word.word))) in
   (let s = (update_Sstatus_XS s ((get_Mstatus_XS m  ::  2 Word.word))) in
   (let s = (update_Sstatus_FS s ((get_Mstatus_FS m  ::  2 Word.word))) in
   (let s = (update_Sstatus_SPP s ((get_Mstatus_SPP m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SPIE s ((get_Mstatus_SPIE m  ::  1 Word.word))) in
   (let s = (update_Sstatus_UPIE s ((get_Mstatus_UPIE m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SIE s ((get_Mstatus_SIE m  ::  1 Word.word))) in
   update_Sstatus_UIE s ((get_Mstatus_UIE m  ::  1 Word.word))))))))))))))"


(*val lift_sstatus : Mstatus -> Sstatus -> Mstatus*)

definition lift_sstatus  :: " Mstatus \<Rightarrow> Sstatus \<Rightarrow> Mstatus "  where 
     " lift_sstatus (m :: Mstatus) (s :: Sstatus) = (
   (let m = (update_Mstatus_SD m ((get_Sstatus_SD s  ::  1 Word.word))) in
   (let m = (update_Mstatus_UXL m ((get_Sstatus_UXL s  ::  2 Word.word))) in
   (let m = (update_Mstatus_MXR m ((get_Sstatus_MXR s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SUM m ((get_Sstatus_SUM s  ::  1 Word.word))) in
   (let m = (update_Mstatus_XS m ((get_Sstatus_XS s  ::  2 Word.word))) in
   (let m = (update_Mstatus_FS m ((get_Sstatus_FS s  ::  2 Word.word))) in
   (let m = (update_Mstatus_SPP m ((get_Sstatus_SPP s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SPIE m ((get_Sstatus_SPIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_UPIE m ((get_Sstatus_UPIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SIE m ((get_Sstatus_SIE s  ::  1 Word.word))) in
   update_Mstatus_UIE m ((get_Sstatus_UIE s  ::  1 Word.word)))))))))))))"


(*val legalize_sstatus : Mstatus -> mword ty64 -> Mstatus*)

definition legalize_sstatus  :: " Mstatus \<Rightarrow>(64)Word.word \<Rightarrow> Mstatus "  where 
     " legalize_sstatus (m :: Mstatus) (v :: xlenbits) = ( lift_sstatus m (Mk_Sstatus v))"


(*val _get_Sedeleg : Sedeleg -> mword ty64*)

fun get_Sedeleg  :: " Sedeleg \<Rightarrow>(64)Word.word "  where 
     " get_Sedeleg (Mk_Sedeleg (v)) = ( v )"


(*val _set_Sedeleg : register_ref regstate register_value Sedeleg -> mword ty64 -> M unit*)

definition set_Sedeleg  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Sedeleg v) in
   write_reg r_ref r)))"


fun get_Sedeleg_UEnvCall  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_UEnvCall (Mk_Sedeleg (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_UEnvCall  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_UEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_UEnvCall  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_UEnvCall (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_SAMO_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_SAMO_Access_Fault (Mk_Sedeleg (v)) = (
   (subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_SAMO_Access_Fault  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_SAMO_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_SAMO_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_SAMO_Access_Fault (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_SAMO_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_SAMO_Addr_Align (Mk_Sedeleg (v)) = ( (subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_SAMO_Addr_Align  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_SAMO_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_SAMO_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_SAMO_Addr_Align (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_Load_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Load_Access_Fault (Mk_Sedeleg (v)) = (
   (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_Load_Access_Fault  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Load_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_Load_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Load_Access_Fault (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_Load_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Load_Addr_Align (Mk_Sedeleg (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_Load_Addr_Align  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Load_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_Load_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Load_Addr_Align (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_Breakpoint  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Breakpoint (Mk_Sedeleg (v)) = ( (subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_Breakpoint  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Breakpoint r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_Breakpoint  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Breakpoint (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_Illegal_Instr  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Illegal_Instr (Mk_Sedeleg (v)) = ( (subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_Illegal_Instr  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Illegal_Instr r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_Illegal_Instr  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Illegal_Instr (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_Fetch_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Fetch_Access_Fault (Mk_Sedeleg (v)) = (
   (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_Fetch_Access_Fault  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Fetch_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_Fetch_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Fetch_Access_Fault (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sedeleg_Fetch_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Fetch_Addr_Align (Mk_Sedeleg (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


definition set_Sedeleg_Fetch_Addr_Align  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Fetch_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sedeleg) . 
   (let r = ((get_Sedeleg w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sedeleg r)))))"


fun update_Sedeleg_Fetch_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Fetch_Addr_Align (Mk_Sedeleg (v)) x = (
   Mk_Sedeleg ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val legalize_sedeleg : Sedeleg -> mword ty64 -> Sedeleg*)

definition legalize_sedeleg  :: " Sedeleg \<Rightarrow>(64)Word.word \<Rightarrow> Sedeleg "  where 
     " legalize_sedeleg (s :: Sedeleg) (v :: xlenbits) = (
   Mk_Sedeleg ((EXTZ (( 64 :: int)::ii) ((subrange_vec_dec v (( 8 :: int)::ii) (( 0 :: int)::ii)  ::  9 Word.word))  ::  64 Word.word)))"


(*val _get_Sinterrupts : Sinterrupts -> mword ty64*)

fun get_Sinterrupts  :: " Sinterrupts \<Rightarrow>(64)Word.word "  where 
     " get_Sinterrupts (Mk_Sinterrupts (v)) = ( v )"


(*val _set_Sinterrupts : register_ref regstate register_value Sinterrupts -> mword ty64 -> M unit*)

definition set_Sinterrupts  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Sinterrupts v) in
   write_reg r_ref r)))"


fun get_Sinterrupts_SEI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_SEI (Mk_Sinterrupts (v)) = ( (subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))"


definition set_Sinterrupts_SEI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_SEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sinterrupts) . 
   (let r = ((get_Sinterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 9 :: int)::ii) (( 9 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sinterrupts r)))))"


fun update_Sinterrupts_SEI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_SEI (Mk_Sinterrupts (v)) x = (
   Mk_Sinterrupts ((update_subrange_vec_dec v (( 9 :: int)::ii) (( 9 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sinterrupts_UEI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_UEI (Mk_Sinterrupts (v)) = ( (subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))"


definition set_Sinterrupts_UEI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_UEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sinterrupts) . 
   (let r = ((get_Sinterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 8 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sinterrupts r)))))"


fun update_Sinterrupts_UEI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_UEI (Mk_Sinterrupts (v)) x = (
   Mk_Sinterrupts ((update_subrange_vec_dec v (( 8 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sinterrupts_STI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_STI (Mk_Sinterrupts (v)) = ( (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


definition set_Sinterrupts_STI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_STI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sinterrupts) . 
   (let r = ((get_Sinterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sinterrupts r)))))"


fun update_Sinterrupts_STI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_STI (Mk_Sinterrupts (v)) x = (
   Mk_Sinterrupts ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sinterrupts_UTI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_UTI (Mk_Sinterrupts (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


definition set_Sinterrupts_UTI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_UTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sinterrupts) . 
   (let r = ((get_Sinterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sinterrupts r)))))"


fun update_Sinterrupts_UTI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_UTI (Mk_Sinterrupts (v)) x = (
   Mk_Sinterrupts ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sinterrupts_SSI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_SSI (Mk_Sinterrupts (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


definition set_Sinterrupts_SSI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_SSI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sinterrupts) . 
   (let r = ((get_Sinterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sinterrupts r)))))"


fun update_Sinterrupts_SSI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_SSI (Mk_Sinterrupts (v)) x = (
   Mk_Sinterrupts ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  64 Word.word)))"


fun get_Sinterrupts_USI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_USI (Mk_Sinterrupts (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


definition set_Sinterrupts_USI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_USI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Sinterrupts) . 
   (let r = ((get_Sinterrupts w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Sinterrupts r)))))"


fun update_Sinterrupts_USI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_USI (Mk_Sinterrupts (v)) x = (
   Mk_Sinterrupts ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val lower_mip : Minterrupts -> Minterrupts -> Sinterrupts*)

definition lower_mip  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts "  where 
     " lower_mip (m :: Minterrupts) (d :: Minterrupts) = (
   (let (s :: Sinterrupts) =
     (Mk_Sinterrupts ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) in
   (let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  ::  1 Word.word)) ((get_Minterrupts_SEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  ::  1 Word.word)) ((get_Minterrupts_STI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  ::  1 Word.word)) ((get_Minterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word)))))))))"


(*val lower_mie : Minterrupts -> Minterrupts -> Sinterrupts*)

definition lower_mie  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts "  where 
     " lower_mie (m :: Minterrupts) (d :: Minterrupts) = (
   (let (s :: Sinterrupts) =
     (Mk_Sinterrupts ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) in
   (let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  ::  1 Word.word)) ((get_Minterrupts_SEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  ::  1 Word.word)) ((get_Minterrupts_STI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  ::  1 Word.word)) ((get_Minterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word)))))))))"


(*val lift_sip : Minterrupts -> Minterrupts -> Sinterrupts -> Minterrupts*)

definition lift_sip  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Minterrupts "  where 
     " lift_sip (o1 :: Minterrupts) (d :: Minterrupts) (s :: Sinterrupts) = (
   (let (m :: Minterrupts) = o1 in
   (let m =
     (update_Minterrupts_SSI m
       ((and_vec ((get_Sinterrupts_SSI s  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let m =
     (update_Minterrupts_UEI m
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Minterrupts_USI m
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word))))))"


(*val legalize_sip : Minterrupts -> Minterrupts -> mword ty64 -> Minterrupts*)

definition legalize_sip  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts "  where 
     " legalize_sip (m :: Minterrupts) (d :: Minterrupts) (v :: xlenbits) = (
   lift_sip m d (Mk_Sinterrupts v))"


(*val lift_sie : Minterrupts -> Minterrupts -> Sinterrupts -> Minterrupts*)

definition lift_sie  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Minterrupts "  where 
     " lift_sie (o1 :: Minterrupts) (d :: Minterrupts) (s :: Sinterrupts) = (
   (let (m :: Minterrupts) = o1 in
   (let m =
     (if (((((get_Minterrupts_SEI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_SEI m ((get_Sinterrupts_SEI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_STI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_STI m ((get_Sinterrupts_STI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_SSI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_SSI m ((get_Sinterrupts_SSI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_UEI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_UTI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_UTI m ((get_Sinterrupts_UTI s  ::  1 Word.word))
     else m) in
   if (((((get_Minterrupts_USI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
     update_Minterrupts_USI m ((get_Sinterrupts_USI s  ::  1 Word.word))
   else m)))))))"


(*val legalize_sie : Minterrupts -> Minterrupts -> mword ty64 -> Minterrupts*)

definition legalize_sie  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(64)Word.word \<Rightarrow> Minterrupts "  where 
     " legalize_sie (m :: Minterrupts) (d :: Minterrupts) (v :: xlenbits) = (
   lift_sie m d (Mk_Sinterrupts v))"


(*val _get_Satp64 : Satp64 -> mword ty64*)

fun get_Satp64  :: " Satp64 \<Rightarrow>(64)Word.word "  where 
     " get_Satp64 (Mk_Satp64 (v)) = ( v )"


(*val _set_Satp64 : register_ref regstate register_value Satp64 -> mword ty64 -> M unit*)

definition set_Satp64  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64 r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_Satp64 v) in
   write_reg r_ref r)))"


fun get_Satp64_Mode  :: " Satp64 \<Rightarrow>(4)Word.word "  where 
     " get_Satp64_Mode (Mk_Satp64 (v)) = ( (subrange_vec_dec v (( 63 :: int)::ii) (( 60 :: int)::ii)  ::  4 Word.word))"


definition set_Satp64_Mode  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_Mode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Satp64) . 
   (let r = ((get_Satp64 w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 63 :: int)::ii) (( 60 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Satp64 r)))))"


fun update_Satp64_Mode  :: " Satp64 \<Rightarrow>(4)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_Mode (Mk_Satp64 (v)) x = (
   Mk_Satp64 ((update_subrange_vec_dec v (( 63 :: int)::ii) (( 60 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Satp64_Asid : Satp64 -> mword ty16*)

fun get_Satp64_Asid  :: " Satp64 \<Rightarrow>(16)Word.word "  where 
     " get_Satp64_Asid (Mk_Satp64 (v)) = ( (subrange_vec_dec v (( 59 :: int)::ii) (( 44 :: int)::ii)  ::  16 Word.word))"


(*val _set_Satp64_Asid : register_ref regstate register_value Satp64 -> mword ty16 -> M unit*)

definition set_Satp64_Asid  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_Asid r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Satp64) . 
   (let r = ((get_Satp64 w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 59 :: int)::ii) (( 44 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Satp64 r)))))"


(*val _update_Satp64_Asid : Satp64 -> mword ty16 -> Satp64*)

fun update_Satp64_Asid  :: " Satp64 \<Rightarrow>(16)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_Asid (Mk_Satp64 (v)) x = (
   Mk_Satp64 ((update_subrange_vec_dec v (( 59 :: int)::ii) (( 44 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_Satp64_PPN : Satp64 -> mword ty44*)

fun get_Satp64_PPN  :: " Satp64 \<Rightarrow>(44)Word.word "  where 
     " get_Satp64_PPN (Mk_Satp64 (v)) = ( (subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))"


(*val _set_Satp64_PPN : register_ref regstate register_value Satp64 -> mword ty44 -> M unit*)

definition set_Satp64_PPN  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_PPN r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: Satp64) . 
   (let r = ((get_Satp64 w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 43 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_Satp64 r)))))"


(*val _update_Satp64_PPN : Satp64 -> mword ty44 -> Satp64*)

fun update_Satp64_PPN  :: " Satp64 \<Rightarrow>(44)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_PPN (Mk_Satp64 (v)) x = (
   Mk_Satp64 ((update_subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val legalize_satp : Architecture -> mword ty64 -> mword ty64 -> mword ty64*)

definition legalize_satp  :: " Architecture \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word "  where 
     " legalize_satp (a :: Architecture) (o1 :: xlenbits) (v :: xlenbits) = (
   (let s = (Mk_Satp64 v) in
   (case  ((satpMode_of_bits a ((get_Satp64_Mode s  ::  4 Word.word)))) of
     None => o1
   | Some (Sv32) => o1
   | Some (_) => (get_Satp64 s  ::  64 Word.word)
   )))"


(*val csr_name : mword ty12 -> string*)

definition csr_name  :: "(12)Word.word \<Rightarrow> string "  where 
     " csr_name csr = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''ustatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''uie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (''utvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''fflags'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''frm'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''fcsr'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''cycle'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''time'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''instret'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''cycleh'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''timeh'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''instreth'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''sstatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''sedeleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''sideleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''sie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (''stvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     (''scounteren'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''sscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''sepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''scause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''stval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''sip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''satp'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''mvendorid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''marchid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''mimpid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''mhartid'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mstatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''misa'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''medeleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''mideleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''mie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (''mtvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     (''mcounteren'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''mepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''mcause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''mtval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''mip'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mcycle'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''minstret'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mcycleh'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''minstreth'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''tselect'')
   else (''UNKNOWN'')))"


(*val csrAccess : mword ty12 -> mword ty2*)

definition csrAccess  :: "(12)Word.word \<Rightarrow>(2)Word.word "  where 
     " csrAccess csr = ( (subrange_vec_dec csr (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word))"


(*val csrPriv : mword ty12 -> mword ty2*)

definition csrPriv  :: "(12)Word.word \<Rightarrow>(2)Word.word "  where 
     " csrPriv csr = ( (subrange_vec_dec csr (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))"


(*val is_CSR_defined : mword ty12 -> Privilege -> bool*)

definition is_CSR_defined  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow> bool "  where 
     " is_CSR_defined (csr :: 12 bits) (p :: Privilege) = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     ((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))
   else False))"


(*val check_CSR_access : mword ty2 -> mword ty2 -> Privilege -> bool -> bool*)

definition check_CSR_access  :: "(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool "  where 
     " check_CSR_access csrrw csrpr p isWrite = (
   (((\<not> ((((((((bool_to_bits isWrite  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((csrrw = (vec_of_bits [B1,B1]  ::  2 Word.word))))))))) \<and> ((zopz0zKzJ_u ((privLevel_to_bits p  ::  2 Word.word)) csrpr))))"


(*val check_TVM_SATP : mword ty12 -> Privilege -> M bool*)

definition check_TVM_SATP  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " check_TVM_SATP (csr :: csreg) (p :: Privilege) = (
   and_boolM
     (return (((csr = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))))
     (and_boolM
        (return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
        (read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
         return (((((get_Mstatus_TVM w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   return ((\<not> w__2))))"


(*val check_CSR : mword ty12 -> Privilege -> bool -> M bool*)

definition check_CSR  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " check_CSR (csr :: csreg) (p :: Privilege) (isWrite :: bool) = (
   and_boolM (return ((is_CSR_defined csr p)))
     (and_boolM
        (return ((check_CSR_access ((csrAccess csr  ::  2 Word.word)) ((csrPriv csr  ::  2 Word.word)) p
                    isWrite))) ((check_TVM_SATP csr p))))"


(*val exception_delegatee : ExceptionType -> Privilege -> M Privilege*)

definition exception_delegatee  :: " ExceptionType \<Rightarrow> Privilege \<Rightarrow>((register_value),(Privilege),(exception))monad "  where 
     " exception_delegatee (e :: ExceptionType) (p :: Privilege) = (
   (let idx = (num_of_ExceptionType e) in
   read_reg medeleg_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let super = (access_vec_dec ((get_Medeleg w__0  ::  64 Word.word)) idx) in
   read_reg sedeleg_ref \<bind> (\<lambda> (w__1 :: Sedeleg) . 
   (let user = (access_vec_dec ((get_Sedeleg w__1  ::  64 Word.word)) idx) in
   and_boolM
     (read_reg misa_ref \<bind> (\<lambda> (w__2 :: Misa) . 
      return (((((get_Misa_S w__2  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
     (return ((bit_to_bool super))) \<bind> (\<lambda> (w__3 :: bool) . 
   (let deleg = (if w__3 then Supervisor else Machine) in
   return (if ((zopz0zI_u ((privLevel_to_bits deleg  ::  2 Word.word))
                  ((privLevel_to_bits p  ::  2 Word.word)))) then
             p
           else deleg)))))))))"


(*val findPendingInterrupt : mword ty64 -> maybe InterruptType*)

definition findPendingInterrupt  :: "(64)Word.word \<Rightarrow>(InterruptType)option "  where 
     " findPendingInterrupt ip = (
   (let ip = (Mk_Minterrupts ip) in
   if (((((get_Minterrupts_MEI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
     Some I_M_External
   else if (((((get_Minterrupts_MSI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_M_Software
   else if (((((get_Minterrupts_MTI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_M_Timer
   else if (((((get_Minterrupts_SEI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_S_External
   else if (((((get_Minterrupts_SSI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_S_Software
   else if (((((get_Minterrupts_STI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_S_Timer
   else if (((((get_Minterrupts_UEI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_U_External
   else if (((((get_Minterrupts_USI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_U_Software
   else if (((((get_Minterrupts_UTI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_U_Timer
   else None))"


(*val curInterrupt : Minterrupts -> Minterrupts -> Minterrupts -> M (maybe ((InterruptType * Privilege)))*)

definition curInterrupt  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>((register_value),((InterruptType*Privilege)option),(exception))monad "  where 
     " curInterrupt (pend :: Minterrupts) (enbl :: Minterrupts) (delg :: Minterrupts) = (
   (let (en_mip :: xlenbits) =
     ((and_vec ((get_Minterrupts pend  ::  64 Word.word)) ((get_Minterrupts enbl  ::  64 Word.word))
       ::  64 Word.word)) in
   if (((en_mip = ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))))) then
     return None
   else
     (let eff_mip =
       ((and_vec en_mip ((not_vec ((get_Minterrupts delg  ::  64 Word.word))  ::  64 Word.word))
         ::  64 Word.word)) in
     (let eff_sip = ((and_vec en_mip ((get_Minterrupts delg  ::  64 Word.word))  ::  64 Word.word)) in
     and_boolM
       (read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
        return (((((get_Mstatus_MIE w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
       (return (((eff_mip \<noteq> ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word)))))) \<bind> (\<lambda> (w__1 ::
       bool) . 
     if w__1 then
       return ((case  ((findPendingInterrupt eff_mip)) of
         Some (i) =>
          (let r = (i, Machine) in
          Some r)
       | None => None
       ))
     else
       and_boolM
         (read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) . 
          return (((((get_Mstatus_SIE w__2  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
         (and_boolM
            (return (((eff_sip \<noteq> ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))))))
            (or_boolM
               (read_reg cur_privilege_ref \<bind> (\<lambda> (w__3 :: Privilege) . 
                return (((((privLevel_to_bits w__3  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))
               (read_reg cur_privilege_ref \<bind> (\<lambda> (w__4 :: Privilege) . 
                return (((((privLevel_to_bits w__4  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word))))))))) \<bind> (\<lambda> (w__7 :: bool) . 
       return (if w__7 then
                 (case  ((findPendingInterrupt eff_sip)) of
                   Some (i) =>
                    (let r = (i, Supervisor) in
                    Some r)
                 | None => None
                 )
               else None)))))))"


(*val tval : maybe (mword ty64) -> mword ty64*)

fun tval  :: "((64)Word.word)option \<Rightarrow>(64)Word.word "  where 
     " tval (Some (e)) = ( e )"
|" tval None = ( (EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))"


(*val handle_trap : Privilege -> bool -> mword ty4 -> mword ty64 -> maybe (mword ty64) -> M (mword ty64)*)

definition handle_trap  :: " Privilege \<Rightarrow> bool \<Rightarrow>(4)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(xlenbits)option \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " handle_trap (del_priv :: Privilege) (intr :: bool) (c :: exc_code) (pc :: xlenbits) (info ::
   xlenbits option) = (
   (let (_ :: unit) =
     (prerr_endline
       (((op@) (''handling '')
           (((op@) (if intr then (''int#'') else (''exc#''))
               (((op@) ((string_of_vec c))
                   (((op@) ('' at priv '')
                       (((op@) ((privLevel_to_str del_priv))
                           (((op@) ('' with tval '')
                               ((string_of_vec ((tval info  ::  64 Word.word))))))))))))))))) in
   (case  del_priv of
     Machine =>
      ((set_Mcause_IsInterrupt mcause_ref ((bool_to_bits intr  ::  1 Word.word)) \<then>
      set_Mcause_Cause mcause_ref ((EXTZ (( 63 :: int)::ii) c  ::  63 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__0 :: Mstatus) . 
      ((set_Mstatus_MPIE mstatus_ref ((get_Mstatus_MIE w__0  ::  1 Word.word)) \<then>
      set_Mstatus_MIE mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      read_reg cur_privilege_ref) \<bind> (\<lambda> (w__1 :: Privilege) . 
      ((((set_Mstatus_MPP mstatus_ref ((privLevel_to_bits w__1  ::  2 Word.word)) \<then>
      write_reg mtval_ref ((tval info  ::  64 Word.word))) \<then>
      write_reg mepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      read_reg mtvec_ref) \<bind> (\<lambda> (w__2 :: Mtvec) . 
      read_reg mcause_ref \<bind> (\<lambda> (w__3 :: Mcause) . 
      (case  ((tvec_addr w__2 w__3  ::  ( 64 Word.word)option)) of
        Some (epc) => return epc
      | None => (internal_error (''Invalid mtvec mode'')  :: ( 64 Word.word) M)
      )))))
   | Supervisor =>
      ((set_Mcause_IsInterrupt scause_ref ((bool_to_bits intr  ::  1 Word.word)) \<then>
      set_Mcause_Cause scause_ref ((EXTZ (( 63 :: int)::ii) c  ::  63 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__6 :: Mstatus) . 
      ((set_Mstatus_SPIE mstatus_ref ((get_Mstatus_SIE w__6  ::  1 Word.word)) \<then>
      set_Mstatus_SIE mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      read_reg cur_privilege_ref) \<bind> (\<lambda> (w__7 :: Privilege) . 
      (case  w__7 of
        User => return ((bool_to_bits False  ::  1 Word.word))
      | Supervisor => return ((bool_to_bits True  ::  1 Word.word))
      | Machine => (internal_error (''invalid privilege for s-mode trap'')  :: ( 1 Word.word) M)
      ) \<bind> (\<lambda> (w__9 ::  1 Word.word) . 
      ((((set_Mstatus_SPP mstatus_ref w__9 \<then>
      write_reg stval_ref ((tval info  ::  64 Word.word))) \<then>
      write_reg sepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      read_reg stvec_ref) \<bind> (\<lambda> (w__10 :: Mtvec) . 
      read_reg scause_ref \<bind> (\<lambda> (w__11 :: Mcause) . 
      (case  ((tvec_addr w__10 w__11  ::  ( 64 Word.word)option)) of
        Some (epc) => return epc
      | None => (internal_error (''Invalid stvec mode'')  :: ( 64 Word.word) M)
      ))))))
   | User => (internal_error (''the N extension is currently unsupported'')  :: ( 64 Word.word) M)
   )))"


(*val handle_exception : Privilege -> ctl_result -> mword ty64 -> M (mword ty64)*)

definition handle_exception  :: " Privilege \<Rightarrow> ctl_result \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " handle_exception (cur_priv :: Privilege) (ctl :: ctl_result) (pc :: xlenbits) = (
   (case  (cur_priv, ctl) of
     (_, CTL_TRAP (e)) =>
      exception_delegatee(sync_exception_trap   e) cur_priv \<bind> (\<lambda> del_priv . 
      (let (_ :: unit) =
        (prerr_endline
          (((op@) (''trapping from '')
              (((op@) ((privLevel_to_str cur_priv))
                  (((op@) ('' to '')
                      (((op@) ((privLevel_to_str del_priv))
                          (((op@) ('' to handle '')
                              ((exceptionType_to_str(sync_exception_trap   e)))))))))))))) in
      (handle_trap del_priv False ((exceptionType_to_bits(sync_exception_trap   e)  ::  4 Word.word)) pc(sync_exception_excinfo  
         e)
        :: ( 64 Word.word) M)))
   | (_, CTL_MRET (_)) =>
      read_reg cur_privilege_ref \<bind> (\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      ((set_Mstatus_MIE mstatus_ref ((get_Mstatus_MPIE w__1  ::  1 Word.word)) \<then>
      set_Mstatus_MPIE mstatus_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__2 :: Mstatus) . 
      ((write_reg cur_privilege_ref ((privLevel_of_bits ((get_Mstatus_MPP w__2  ::  2 Word.word)))) \<then>
      set_Mstatus_MPP mstatus_ref ((privLevel_to_bits User  ::  2 Word.word))) \<then>
      read_reg cur_privilege_ref) \<bind> (\<lambda> (w__3 :: Privilege) . 
      (let (_ :: unit) =
        (prerr_endline
          (((op@) (''ret-ing from '')
              (((op@) ((privLevel_to_str prev_priv))
                  (((op@) ('' to '') ((privLevel_to_str w__3))))))))) in
      (read_reg mepc_ref  :: ( 64 Word.word) M))))))
   | (_, CTL_SRET (_)) =>
      read_reg cur_privilege_ref \<bind> (\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> (\<lambda> (w__5 :: Mstatus) . 
      ((set_Mstatus_SIE mstatus_ref ((get_Mstatus_SPIE w__5  ::  1 Word.word)) \<then>
      set_Mstatus_SPIE mstatus_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__6 :: Mstatus) . 
      ((write_reg
        cur_privilege_ref
        (if (((((get_Mstatus_SPP w__6  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
         then
           Supervisor
         else User) \<then>
      set_Mstatus_SPP mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      read_reg cur_privilege_ref) \<bind> (\<lambda> (w__7 :: Privilege) . 
      (let (_ :: unit) =
        (prerr_endline
          (((op@) (''ret-ing from '')
              (((op@) ((privLevel_to_str prev_priv))
                  (((op@) ('' to '') ((privLevel_to_str w__7))))))))) in
      (read_reg sepc_ref  :: ( 64 Word.word) M))))))
   ))"


(*val handle_mem_exception : mword ty64 -> ExceptionType -> M unit*)

definition handle_mem_exception  :: "(64)Word.word \<Rightarrow> ExceptionType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_mem_exception (addr :: xlenbits) (e :: ExceptionType) = (
   (let (t :: sync_exception) = ((| sync_exception_trap = e,  sync_exception_excinfo = (Some addr) |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (handle_exception w__0 (CTL_TRAP t) w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: xlenbits) . 
   write_reg nextPC_ref w__2)))))"


(*val handle_decode_exception : mword ty64 -> M unit*)

definition handle_decode_exception  :: "(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_decode_exception instbits = (
   (let (t :: sync_exception) =
     ((| sync_exception_trap = E_Illegal_Instr, 
        sync_exception_excinfo = (Some instbits) |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (handle_exception w__0 (CTL_TRAP t) w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: xlenbits) . 
   write_reg nextPC_ref w__2)))))"


(*val handle_interrupt : InterruptType -> Privilege -> M unit*)

definition handle_interrupt  :: " InterruptType \<Rightarrow> Privilege \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_interrupt (i :: InterruptType) (del_priv :: Privilege) = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (handle_trap del_priv True ((interruptType_to_bits i  ::  4 Word.word)) w__0 None
     :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: xlenbits) . 
   write_reg nextPC_ref w__1)))"


(*val handle_illegal : unit -> M unit*)

definition handle_illegal  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_illegal _ = (
   (let (t :: sync_exception) =
     ((| sync_exception_trap = E_Illegal_Instr, 
        sync_exception_excinfo = None |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (handle_exception w__0 (CTL_TRAP t) w__1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 :: xlenbits) . 
   write_reg nextPC_ref w__2)))))"


(*val init_sys : unit -> M unit*)

definition init_sys  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_sys _ = (
   (((((write_reg cur_privilege_ref Machine \<then>
   set_Misa_MXL misa_ref ((arch_to_bits RV64  ::  2 Word.word))) \<then>
   set_Misa_C misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   set_Misa_U misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   set_Misa_S misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   read_reg misa_ref) \<bind> (\<lambda> (w__0 :: Misa) . 
   (set_Mstatus_SXL mstatus_ref ((get_Misa_MXL w__0  ::  2 Word.word)) \<then>
   read_reg misa_ref) \<bind> (\<lambda> (w__1 :: Misa) . 
   (set_Mstatus_UXL mstatus_ref ((get_Misa_MXL w__1  ::  2 Word.word)) \<then>
   set_Mstatus_SD mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
   write_reg mhartid_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word)))))"


(*val tick_clock : unit -> M unit*)

definition tick_clock  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " tick_clock _ = (
   (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   write_reg mcycle_ref ((add_vec_int w__0 (( 1 :: int)::ii)  ::  64 Word.word))))"


definition PAGESIZE_BITS  :: " int "  where 
     " PAGESIZE_BITS = ( (( 12 :: int)::ii))"


(*val _get_PTE_Bits : PTE_Bits -> mword ty8*)

fun get_PTE_Bits  :: " PTE_Bits \<Rightarrow>(8)Word.word "  where 
     " get_PTE_Bits (Mk_PTE_Bits (v)) = ( v )"


(*val _set_PTE_Bits : register_ref regstate register_value PTE_Bits -> mword ty8 -> M unit*)

definition set_PTE_Bits  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_PTE_Bits v) in
   write_reg r_ref r)))"


fun get_PTE_Bits_D  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_D (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_D  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_D r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 7 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_D  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_D (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 7 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_A  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_A (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_A  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_A r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 6 :: int)::ii) (( 6 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_A  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_A (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 6 :: int)::ii) (( 6 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_G  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_G (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_G  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_G r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 5 :: int)::ii) (( 5 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_G  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_G (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 5 :: int)::ii) (( 5 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_U  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_U (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_U  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_U r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 4 :: int)::ii) (( 4 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_U  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_U (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 4 :: int)::ii) (( 4 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_X  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_X (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_X  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_X r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 3 :: int)::ii) (( 3 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_X  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_X (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 3 :: int)::ii) (( 3 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_W  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_W (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_W  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_W r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 2 :: int)::ii) (( 2 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_W  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_W (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 2 :: int)::ii) (( 2 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_R  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_R (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_R  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_R r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 1 :: int)::ii) (( 1 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_R  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_R (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 1 :: int)::ii) (( 1 :: int)::ii) x  ::  8 Word.word)))"


fun get_PTE_Bits_V  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_V (Mk_PTE_Bits (v)) = ( (subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))"


definition set_PTE_Bits_V  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_V r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: PTE_Bits) . 
   (let r = ((get_PTE_Bits w__0  ::  8 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 0 :: int)::ii) (( 0 :: int)::ii) v  ::  8 Word.word)) in
   write_reg r_ref (Mk_PTE_Bits r)))))"


fun update_PTE_Bits_V  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_V (Mk_PTE_Bits (v)) x = (
   Mk_PTE_Bits ((update_subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii) x  ::  8 Word.word)))"


(*val isPTEPtr : mword ty8 -> bool*)

definition isPTEPtr  :: "(8)Word.word \<Rightarrow> bool "  where 
     " isPTEPtr p = (
   (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_R a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_W a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_X a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))))))))"


(*val isInvalidPTE : mword ty8 -> bool*)

definition isInvalidPTE  :: "(8)Word.word \<Rightarrow> bool "  where 
     " isInvalidPTE p = (
   (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_V a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_W a  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_R a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))))))))"


(*val checkPTEPermission : AccessType -> Privilege -> bool -> bool -> PTE_Bits -> M bool*)

fun checkPTEPermission  :: " AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> PTE_Bits \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " checkPTEPermission (Read :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr))))))))))"
|" checkPTEPermission (Write :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))"
|" checkPTEPermission (ReadWrite :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr)))))))))))))"
|" checkPTEPermission (Execute :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))"
|" checkPTEPermission (Read :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> do_sum))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr))))))))))"
|" checkPTEPermission (Write :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> do_sum))) \<and> (((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))"
|" checkPTEPermission (ReadWrite :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> do_sum))) \<and> ((((((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr)))))))))))))"
|" checkPTEPermission (Execute :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))"
|" checkPTEPermission (_ :: AccessType) (Machine :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = ( internal_error (''m-mode mem perm check''))"


(*val update_PTE_Bits : PTE_Bits -> AccessType -> maybe PTE_Bits*)

definition update_PTE_Bits  :: " PTE_Bits \<Rightarrow> AccessType \<Rightarrow>(PTE_Bits)option "  where 
     " update_PTE_Bits (p :: PTE_Bits) (a :: AccessType) = (
   (let update_d =
     (((((((a = Write))) \<or> (((a = ReadWrite)))))) \<and> (((((get_PTE_Bits_D p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))) in
   (let update_a = (((get_PTE_Bits_A p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))) in
   if (((update_d \<or> update_a))) then
     (let np = (update_PTE_Bits_A p ((bool_to_bits True  ::  1 Word.word))) in
     (let np = (if update_d then update_PTE_Bits_D p ((bool_to_bits True  ::  1 Word.word)) else np) in
     Some np))
   else None)))"


(*val PTW_Error_of_num : integer -> PTW_Error*)

definition PTW_Error_of_num  :: " int \<Rightarrow> PTW_Error "  where 
     " PTW_Error_of_num arg0 = (
   (let l__0 = arg0 in
   if (((l__0 = (( 0 :: int)::ii)))) then PTW_Access
   else if (((l__0 = (( 1 :: int)::ii)))) then PTW_Invalid_PTE
   else if (((l__0 = (( 2 :: int)::ii)))) then PTW_No_Permission
   else if (((l__0 = (( 3 :: int)::ii)))) then PTW_Misaligned
   else PTW_PTE_Update))"


(*val num_of_PTW_Error : PTW_Error -> integer*)

fun num_of_PTW_Error  :: " PTW_Error \<Rightarrow> int "  where 
     " num_of_PTW_Error PTW_Access = ( (( 0 :: int)::ii))"
|" num_of_PTW_Error PTW_Invalid_PTE = ( (( 1 :: int)::ii))"
|" num_of_PTW_Error PTW_No_Permission = ( (( 2 :: int)::ii))"
|" num_of_PTW_Error PTW_Misaligned = ( (( 3 :: int)::ii))"
|" num_of_PTW_Error PTW_PTE_Update = ( (( 4 :: int)::ii))"


(*val translationException : AccessType -> PTW_Error -> ExceptionType*)

fun translationException  :: " AccessType \<Rightarrow> PTW_Error \<Rightarrow> ExceptionType "  where 
     " translationException (Read :: AccessType) (PTW_Access :: PTW_Error) = ( E_Load_Access_Fault )"
|" translationException (Read :: AccessType) (_ :: PTW_Error) = ( E_Load_Page_Fault )"
|" translationException (Write :: AccessType) (PTW_Access :: PTW_Error) = ( E_SAMO_Access_Fault )"
|" translationException (Write :: AccessType) (_ :: PTW_Error) = ( E_SAMO_Page_Fault )"
|" translationException (Fetch :: AccessType) (PTW_Access :: PTW_Error) = ( E_Fetch_Access_Fault )"
|" translationException (Fetch :: AccessType) (_ :: PTW_Error) = ( E_Fetch_Page_Fault )"


definition SV39_LEVEL_BITS  :: " int "  where 
     " SV39_LEVEL_BITS = ( (( 9 :: int)::ii))"


definition SV39_LEVELS  :: " int "  where 
     " SV39_LEVELS = ( (( 3 :: int)::ii))"


definition PTE39_LOG_SIZE  :: " int "  where 
     " PTE39_LOG_SIZE = ( (( 3 :: int)::ii))"


definition PTE39_SIZE  :: " int "  where 
     " PTE39_SIZE = ( (( 8 :: int)::ii))"


(*val _get_SV39_Vaddr : SV39_Vaddr -> mword ty39*)

fun get_SV39_Vaddr  :: " SV39_Vaddr \<Rightarrow>(39)Word.word "  where 
     " get_SV39_Vaddr (Mk_SV39_Vaddr (v)) = ( v )"


(*val _set_SV39_Vaddr : register_ref regstate register_value SV39_Vaddr -> mword ty39 -> M unit*)

definition set_SV39_Vaddr  :: "((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(39)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Vaddr r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_SV39_Vaddr v) in
   write_reg r_ref r)))"


(*val _get_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27*)

fun get_SV39_Vaddr_VPNi  :: " SV39_Vaddr \<Rightarrow>(27)Word.word "  where 
     " get_SV39_Vaddr_VPNi (Mk_SV39_Vaddr (v)) = ( (subrange_vec_dec v (( 38 :: int)::ii) (( 12 :: int)::ii)  ::  27 Word.word))"


(*val _set_SV39_Vaddr_VPNi : register_ref regstate register_value SV39_Vaddr -> mword ty27 -> M unit*)

definition set_SV39_Vaddr_VPNi  :: "((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Vaddr_VPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_Vaddr) . 
   (let r = ((get_SV39_Vaddr w__0  ::  39 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 38 :: int)::ii) (( 12 :: int)::ii) v  ::  39 Word.word)) in
   write_reg r_ref (Mk_SV39_Vaddr r)))))"


(*val _update_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27 -> SV39_Vaddr*)

fun update_SV39_Vaddr_VPNi  :: " SV39_Vaddr \<Rightarrow>(27)Word.word \<Rightarrow> SV39_Vaddr "  where 
     " update_SV39_Vaddr_VPNi (Mk_SV39_Vaddr (v)) x = (
   Mk_SV39_Vaddr ((update_subrange_vec_dec v (( 38 :: int)::ii) (( 12 :: int)::ii) x  ::  39 Word.word)))"


(*val _get_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12*)

fun get_SV39_Vaddr_PgOfs  :: " SV39_Vaddr \<Rightarrow>(12)Word.word "  where 
     " get_SV39_Vaddr_PgOfs (Mk_SV39_Vaddr (v)) = ( (subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))"


(*val _set_SV39_Vaddr_PgOfs : register_ref regstate register_value SV39_Vaddr -> mword ty12 -> M unit*)

definition set_SV39_Vaddr_PgOfs  :: "((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Vaddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_Vaddr) . 
   (let r = ((get_SV39_Vaddr w__0  ::  39 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  39 Word.word)) in
   write_reg r_ref (Mk_SV39_Vaddr r)))))"


(*val _update_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12 -> SV39_Vaddr*)

fun update_SV39_Vaddr_PgOfs  :: " SV39_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV39_Vaddr "  where 
     " update_SV39_Vaddr_PgOfs (Mk_SV39_Vaddr (v)) x = (
   Mk_SV39_Vaddr ((update_subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  39 Word.word)))"


(*val _update_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12 -> SV39_Paddr*)

(*val _get_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12*)

(*val _set_SV39_Paddr_PgOfs : register_ref regstate register_value SV39_Paddr -> mword ty12 -> M unit*)

(*val _get_SV39_Paddr : SV39_Paddr -> mword ty56*)

fun get_SV39_Paddr  :: " SV39_Paddr \<Rightarrow>(56)Word.word "  where 
     " get_SV39_Paddr (Mk_SV39_Paddr (v)) = ( v )"


(*val _set_SV39_Paddr : register_ref regstate register_value SV39_Paddr -> mword ty56 -> M unit*)

definition set_SV39_Paddr  :: "((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(56)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Paddr r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_SV39_Paddr v) in
   write_reg r_ref r)))"


(*val _get_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44*)

fun get_SV39_Paddr_PPNi  :: " SV39_Paddr \<Rightarrow>(44)Word.word "  where 
     " get_SV39_Paddr_PPNi (Mk_SV39_Paddr (v)) = ( (subrange_vec_dec v (( 55 :: int)::ii) (( 12 :: int)::ii)  ::  44 Word.word))"


(*val _set_SV39_Paddr_PPNi : register_ref regstate register_value SV39_Paddr -> mword ty44 -> M unit*)

definition set_SV39_Paddr_PPNi  :: "((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Paddr_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_Paddr) . 
   (let r = ((get_SV39_Paddr w__0  ::  56 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 55 :: int)::ii) (( 12 :: int)::ii) v  ::  56 Word.word)) in
   write_reg r_ref (Mk_SV39_Paddr r)))))"


(*val _update_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44 -> SV39_Paddr*)

fun update_SV39_Paddr_PPNi  :: " SV39_Paddr \<Rightarrow>(44)Word.word \<Rightarrow> SV39_Paddr "  where 
     " update_SV39_Paddr_PPNi (Mk_SV39_Paddr (v)) x = (
   Mk_SV39_Paddr ((update_subrange_vec_dec v (( 55 :: int)::ii) (( 12 :: int)::ii) x  ::  56 Word.word)))"


(*val _update_SV39_PTE_PPNi : SV39_PTE -> mword ty44 -> SV39_PTE*)

(*val _get_SV39_PTE_PPNi : SV39_PTE -> mword ty44*)

(*val _set_SV39_PTE_PPNi : register_ref regstate register_value SV39_PTE -> mword ty44 -> M unit*)

fun get_SV39_Paddr_PgOfs  :: " SV39_Paddr \<Rightarrow>(12)Word.word "  where 
     " get_SV39_Paddr_PgOfs (Mk_SV39_Paddr (v)) = ( (subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))"


definition set_SV39_Paddr_PgOfs  :: "((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Paddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_Paddr) . 
   (let r = ((get_SV39_Paddr w__0  ::  56 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 11 :: int)::ii) (( 0 :: int)::ii) v  ::  56 Word.word)) in
   write_reg r_ref (Mk_SV39_Paddr r)))))"


fun update_SV39_Paddr_PgOfs  :: " SV39_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV39_Paddr "  where 
     " update_SV39_Paddr_PgOfs (Mk_SV39_Paddr (v)) x = (
   Mk_SV39_Paddr ((update_subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii) x  ::  56 Word.word)))"


fun get_SV39_PTE  :: " SV39_PTE \<Rightarrow>(64)Word.word "  where 
     " get_SV39_PTE (Mk_SV39_PTE (v)) = ( v )"


definition set_SV39_PTE  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r = (Mk_SV39_PTE v) in
   write_reg r_ref r)))"


fun get_SV39_PTE_PPNi  :: " SV39_PTE \<Rightarrow>(44)Word.word "  where 
     " get_SV39_PTE_PPNi (Mk_SV39_PTE (v)) = ( (subrange_vec_dec v (( 53 :: int)::ii) (( 10 :: int)::ii)  ::  44 Word.word))"


definition set_SV39_PTE_PPNi  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_PTE) . 
   (let r = ((get_SV39_PTE w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 53 :: int)::ii) (( 10 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_SV39_PTE r)))))"


fun update_SV39_PTE_PPNi  :: " SV39_PTE \<Rightarrow>(44)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_PPNi (Mk_SV39_PTE (v)) x = (
   Mk_SV39_PTE ((update_subrange_vec_dec v (( 53 :: int)::ii) (( 10 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_SV39_PTE_RSW : SV39_PTE -> mword ty2*)

fun get_SV39_PTE_RSW  :: " SV39_PTE \<Rightarrow>(2)Word.word "  where 
     " get_SV39_PTE_RSW (Mk_SV39_PTE (v)) = ( (subrange_vec_dec v (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))"


(*val _set_SV39_PTE_RSW : register_ref regstate register_value SV39_PTE -> mword ty2 -> M unit*)

definition set_SV39_PTE_RSW  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_RSW r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_PTE) . 
   (let r = ((get_SV39_PTE w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 9 :: int)::ii) (( 8 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_SV39_PTE r)))))"


(*val _update_SV39_PTE_RSW : SV39_PTE -> mword ty2 -> SV39_PTE*)

fun update_SV39_PTE_RSW  :: " SV39_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_RSW (Mk_SV39_PTE (v)) x = (
   Mk_SV39_PTE ((update_subrange_vec_dec v (( 9 :: int)::ii) (( 8 :: int)::ii) x  ::  64 Word.word)))"


(*val _get_SV39_PTE_BITS : SV39_PTE -> mword ty8*)

fun get_SV39_PTE_BITS  :: " SV39_PTE \<Rightarrow>(8)Word.word "  where 
     " get_SV39_PTE_BITS (Mk_SV39_PTE (v)) = ( (subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))"


(*val _set_SV39_PTE_BITS : register_ref regstate register_value SV39_PTE -> mword ty8 -> M unit*)

definition set_SV39_PTE_BITS  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_BITS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> (w__0 :: SV39_PTE) . 
   (let r = ((get_SV39_PTE w__0  ::  64 Word.word)) in
   (let r = ((update_subrange_vec_dec r (( 7 :: int)::ii) (( 0 :: int)::ii) v  ::  64 Word.word)) in
   write_reg r_ref (Mk_SV39_PTE r)))))"


(*val _update_SV39_PTE_BITS : SV39_PTE -> mword ty8 -> SV39_PTE*)

fun update_SV39_PTE_BITS  :: " SV39_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_BITS (Mk_SV39_PTE (v)) x = (
   Mk_SV39_PTE ((update_subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii) x  ::  64 Word.word)))"


(*val curAsid64 : unit -> M (mword ty16)*)

definition curAsid64  :: " unit \<Rightarrow>((register_value),((16)Word.word),(exception))monad "  where 
     " curAsid64 _ = (
   (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let satp64 = (Mk_Satp64 w__0) in
   return ((get_Satp64_Asid satp64  ::  16 Word.word)))))"


(*val curPTB39 : unit -> M (mword ty56)*)

definition curPTB39  :: " unit \<Rightarrow>((register_value),((56)Word.word),(exception))monad "  where 
     " curPTB39 _ = (
   (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let satp64 = (Mk_Satp64 w__0) in
   return ((EXTZ (( 56 :: int)::ii)
              ((shiftl ((get_Satp64_PPN satp64  ::  44 Word.word)) PAGESIZE_BITS  ::  44 Word.word))
             ::  56 Word.word)))))"


(*val walk39 : mword ty39 -> AccessType -> Privilege -> bool -> bool -> mword ty56 -> ii -> bool -> M PTW_Result*)

function (sequential,domintros)  walk39  :: "(39)Word.word \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(56)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(PTW_Result),(exception))monad "  where 
     " walk39 vaddr ac priv mxr do_sum ptb level global1 = (
   (let va = (Mk_SV39_Vaddr vaddr) in
   (let (pt_ofs :: paddr39) =
     ((shiftl
        ((EXTZ (( 56 :: int)::ii)
            ((subrange_vec_dec
                ((shiftr ((get_SV39_Vaddr_VPNi va  ::  27 Word.word))
                    ((level * SV39_LEVEL_BITS))
                   ::  27 Word.word)) ((SV39_LEVEL_BITS - (( 1 :: int)::ii))) (( 0 :: int)::ii)
               ::  9 Word.word))
           ::  56 Word.word)) PTE39_LOG_SIZE
       ::  56 Word.word)) in
   (let pte_addr = ((add_vec ptb pt_ofs  ::  56 Word.word)) in
   (checked_mem_read Data ((EXTZ (( 64 :: int)::ii) pte_addr  ::  64 Word.word)) (( 8 :: int)::ii)
     :: ( ( 64 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__0 :: ( 64 Word.word) MemoryOpResult) . 
   (case  w__0 of
     MemException (_) => return (PTW_Failure PTW_Access)
   | MemValue (v) =>
      (let pte = (Mk_SV39_PTE v) in
      (let pbits = ((get_SV39_PTE_BITS pte  ::  8 Word.word)) in
      (let pattr = (Mk_PTE_Bits pbits) in
      (let is_global =
        (global1 \<or> (((((get_PTE_Bits_G pattr  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))) in
      if ((isInvalidPTE pbits)) then return (PTW_Failure PTW_Invalid_PTE)
      else if ((isPTEPtr pbits)) then
        if (((level = (( 0 :: int)::ii)))) then return (PTW_Failure PTW_Invalid_PTE)
        else
          walk39 vaddr ac priv mxr do_sum
            ((EXTZ (( 56 :: int)::ii)
                ((shiftl ((get_SV39_PTE_PPNi pte  ::  44 Word.word)) PAGESIZE_BITS  ::  44 Word.word))
               ::  56 Word.word)) ((level - (( 1 :: int)::ii))) is_global
      else
        checkPTEPermission ac priv mxr do_sum pattr \<bind> (\<lambda> (w__3 :: bool) . 
        return (if ((\<not> w__3)) then PTW_Failure PTW_No_Permission
                else if ((level > (( 0 :: int)::ii))) then
                  (let mask1 =
                    ((sub_vec_int
                       ((shiftl
                           ((xor_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                               ((xor_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                                   ((EXTZ (( 44 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  44 Word.word))
                                  ::  44 Word.word))
                              ::  44 Word.word)) ((level * SV39_LEVEL_BITS))
                          ::  44 Word.word)) (( 1 :: int)::ii)
                      ::  44 Word.word)) in
                  if (((((and_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word)) mask1  ::  44 Word.word)) \<noteq> ((EXTZ (( 44 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  44 Word.word))))) then
                    PTW_Failure PTW_Misaligned
                  else
                    (let ppn =
                      ((or_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                         ((and_vec
                             ((EXTZ (( 44 :: int)::ii) ((get_SV39_Vaddr_VPNi va  ::  27 Word.word))  ::  44 Word.word))
                             mask1
                            ::  44 Word.word))
                        ::  44 Word.word)) in
                    PTW_Success ((concat_vec ppn ((get_SV39_Vaddr_PgOfs va  ::  12 Word.word))
                                   ::  56 Word.word),pte,pte_addr,level,is_global)))
                else
                  PTW_Success ((concat_vec ((get_SV39_PTE_PPNi pte  ::  44 Word.word))
                                  ((get_SV39_Vaddr_PgOfs va  ::  12 Word.word))
                                 ::  56 Word.word),pte,pte_addr,level,is_global)))))))
   ))))))" 
by pat_completeness auto


(*val make_TLB39_Entry : mword ty16 -> bool -> mword ty39 -> mword ty56 -> SV39_PTE -> ii -> mword ty56 -> M TLB39_Entry*)

definition make_TLB39_Entry  :: "(16)Word.word \<Rightarrow> bool \<Rightarrow>(39)Word.word \<Rightarrow>(56)Word.word \<Rightarrow> SV39_PTE \<Rightarrow> int \<Rightarrow>(56)Word.word \<Rightarrow>((register_value),(TLB39_Entry),(exception))monad "  where 
     " make_TLB39_Entry asid global1 vAddr pAddr pte level pteAddr = (
   (let (shift :: ii) = (PAGESIZE_BITS + ((level * SV39_LEVEL_BITS))) in
   (let (vAddrMask :: vaddr39) =
     ((sub_vec_int
        ((shiftl
            ((xor_vec vAddr
                ((xor_vec vAddr ((EXTZ (( 39 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  39 Word.word))
                   ::  39 Word.word))
               ::  39 Word.word)) shift
           ::  39 Word.word)) (( 1 :: int)::ii)
       ::  39 Word.word)) in
   (let (vMatchMask :: vaddr39) = ((not_vec vAddrMask  ::  39 Word.word)) in
   (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: xlenbits) . 
   return ((| TLB39_Entry_asid = asid, 
              TLB39_Entry_global = global1, 
              TLB39_Entry_vAddr = ((and_vec vAddr vMatchMask  ::  39 Word.word)), 
              TLB39_Entry_pAddr =
                ((shiftl ((shiftr pAddr shift  ::  56 Word.word)) shift  ::  56 Word.word)), 
              TLB39_Entry_vMatchMask = vMatchMask, 
              TLB39_Entry_vAddrMask = vAddrMask, 
              TLB39_Entry_pte = pte, 
              TLB39_Entry_pteAddr = pteAddr, 
              TLB39_Entry_age = w__0  |)))))))"


definition TLBEntries  :: " int "  where 
     " TLBEntries = ( (( 32 :: int)::ii))"


(*val lookupTLB39 : mword ty16 -> mword ty39 -> M (maybe ((ii * TLB39_Entry)))*)

definition lookupTLB39  :: "(16)Word.word \<Rightarrow>(39)Word.word \<Rightarrow>((register_value),((int*TLB39_Entry)option),(exception))monad "  where 
     " lookupTLB39 asid vaddr = (
   read_reg tlb39_ref \<bind> (\<lambda> (w__0 ::  TLB39_Entry option) . 
   return ((case  w__0 of
     None => None
   | Some (e) =>
      if (((((((TLB39_Entry_global   e) \<or> ((((TLB39_Entry_asid   e) = asid)))))) \<and> ((((TLB39_Entry_vAddr   e) = ((and_vec(TLB39_Entry_vMatchMask   e) vaddr  ::  39 Word.word))))))))
      then
        Some ((( 0 :: int)::ii), e)
      else None
   ))))"


(*val addToTLB39 : mword ty16 -> mword ty39 -> mword ty56 -> SV39_PTE -> mword ty56 -> ii -> bool -> M unit*)

definition addToTLB39  :: "(16)Word.word \<Rightarrow>(39)Word.word \<Rightarrow>(56)Word.word \<Rightarrow> SV39_PTE \<Rightarrow>(56)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " addToTLB39 asid vAddr pAddr pte pteAddr level global1 = (
   make_TLB39_Entry asid global1 vAddr pAddr pte level pteAddr \<bind> (\<lambda> ent . 
   write_reg tlb39_ref (Some ent)))"


(*val writeTLB39 : ii -> TLB39_Entry -> M unit*)

definition writeTLB39  :: " int \<Rightarrow> TLB39_Entry \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " writeTLB39 (idx :: ii) (ent :: TLB39_Entry) = ( write_reg tlb39_ref (Some ent))"


(*val flushTLB : maybe (mword ty16) -> maybe (mword ty39) -> M unit*)

definition flushTLB  :: "((16)Word.word)option \<Rightarrow>((39)Word.word)option \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " flushTLB asid addr = (
   read_reg tlb39_ref \<bind> (\<lambda> (w__0 ::  TLB39_Entry option) . 
   (let (ent ::  TLB39_Entry option) =
     ((case  (w__0, asid, addr) of
       (None, _, _) => None
     | (Some (e), None, None) => None
     | (Some (e), None, Some (a)) =>
        if ((((TLB39_Entry_vAddr   e) = ((and_vec(TLB39_Entry_vMatchMask   e) a  ::  39 Word.word))))) then
          None
        else Some e
     | (Some (e), Some (i), None) =>
        if (((((((TLB39_Entry_asid   e) = i))) \<and> ((\<not>(TLB39_Entry_global   e)))))) then None
        else Some e
     | (Some (e), Some (i), Some (a)) =>
        if (((((((TLB39_Entry_asid   e) = i))) \<and> (((((((TLB39_Entry_vAddr   e) = ((and_vec a(TLB39_Entry_vMatchMask   e)  ::  39 Word.word))))) \<and> ((\<not>(TLB39_Entry_global   e))))))))) then
          None
        else Some e
     )) in
   write_reg tlb39_ref ent)))"


definition enable_dirty_update  :: " bool "  where 
     " enable_dirty_update = ( False )"


(*val translate39 : mword ty39 -> AccessType -> Privilege -> bool -> bool -> ii -> M TR39_Result*)

definition translate39  :: "(39)Word.word \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),(TR39_Result),(exception))monad "  where 
     " translate39 vAddr ac priv mxr do_sum level = (
   (curAsid64 ()   :: ( 16 Word.word) M) \<bind> (\<lambda> asid . 
   lookupTLB39 asid vAddr \<bind> (\<lambda> (w__0 ::  ((ii * TLB39_Entry))option) . 
   (case  w__0 of
     Some (idx,ent) =>
      (let pteBits = (Mk_PTE_Bits ((get_SV39_PTE_BITS(TLB39_Entry_pte   ent)  ::  8 Word.word))) in
      checkPTEPermission ac priv mxr do_sum pteBits \<bind> (\<lambda> (w__1 :: bool) . 
      if ((\<not> w__1)) then return (TR39_Failure PTW_No_Permission)
      else
        (case  ((update_PTE_Bits pteBits ac)) of
          None =>
           return (TR39_Address ((or_vec(TLB39_Entry_pAddr   ent)
                                    ((EXTZ (( 56 :: int)::ii)
                                        ((and_vec vAddr(TLB39_Entry_vAddrMask   ent)  ::  39 Word.word))
                                       ::  56 Word.word))
                                   ::  56 Word.word)))
        | Some (pbits) =>
           if ((\<not> enable_dirty_update)) then return (TR39_Failure PTW_PTE_Update)
           else
             (let (n_ent :: TLB39_Entry) = ent in
             (let n_ent =
               ((n_ent (|
                 TLB39_Entry_pte :=
                   ((update_SV39_PTE_BITS(TLB39_Entry_pte   ent) ((get_PTE_Bits pbits  ::  8 Word.word))))|))) in
             (writeTLB39 idx n_ent \<then>
             checked_mem_write ((EXTZ (( 64 :: int)::ii)(TLB39_Entry_pteAddr   ent)  ::  64 Word.word)) (( 8 :: int)::ii)
               ((get_SV39_PTE(TLB39_Entry_pte   ent)  ::  64 Word.word))) \<bind> (\<lambda> (w__2 :: unit
               MemoryOpResult) . 
             (case  w__2 of
               MemValue (_) => return () 
             | MemException (e) => internal_error (''invalid physical address in TLB'')
             ) \<then>
             return (TR39_Address ((or_vec(TLB39_Entry_pAddr   ent)
                                      ((EXTZ (( 56 :: int)::ii)
                                          ((and_vec vAddr(TLB39_Entry_vAddrMask   ent)  ::  39 Word.word))
                                         ::  56 Word.word))
                                     ::  56 Word.word))))))
        )))
   | None =>
      (curPTB39 ()   :: ( 56 Word.word) M) \<bind> (\<lambda> (w__6 ::  56 Word.word) . 
      walk39 vAddr ac priv mxr do_sum w__6 level False \<bind> (\<lambda> (w__7 :: PTW_Result) . 
      (case  w__7 of
        PTW_Failure (f) => return (TR39_Failure f)
      | PTW_Success (pAddr,pte,pteAddr,level,global1) =>
         (case  ((update_PTE_Bits (Mk_PTE_Bits ((get_SV39_PTE_BITS pte  ::  8 Word.word))) ac)) of
           None =>
            addToTLB39 asid vAddr pAddr pte pteAddr level global1 \<then> return (TR39_Address pAddr)
         | Some (pbits) =>
            if ((\<not> enable_dirty_update)) then return (TR39_Failure PTW_PTE_Update)
            else
              (let (w_pte :: SV39_PTE) =
                (update_SV39_PTE_BITS pte ((get_PTE_Bits pbits  ::  8 Word.word))) in
              checked_mem_write ((EXTZ (( 64 :: int)::ii) pteAddr  ::  64 Word.word)) (( 8 :: int)::ii)
                ((get_SV39_PTE w_pte  ::  64 Word.word)) \<bind> (\<lambda> (w__8 :: unit MemoryOpResult) . 
              (case  w__8 of
                MemValue (_) =>
                 addToTLB39 asid vAddr pAddr w_pte pteAddr level global1 \<then>
                 return (TR39_Address pAddr)
              | MemException (e) => return (TR39_Failure PTW_Access)
              )))
         )
      )))
   ))))"


(*val translationMode : Privilege -> M SATPMode*)

definition translationMode  :: " Privilege \<Rightarrow>((register_value),(SATPMode),(exception))monad "  where 
     " translationMode priv = (
   if (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   then
     return Sbare
   else
     read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
     (let arch = (architecture ((get_Mstatus_SXL w__0  ::  2 Word.word))) in
     (case  arch of
       Some (RV64) =>
        (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
        (let (mbits :: satp_mode) = ((get_Satp64_Mode (Mk_Satp64 w__1)  ::  4 Word.word)) in
        (case  ((satpMode_of_bits RV64 mbits)) of
          Some (m) => return m
        | None => internal_error (''invalid RV64 translation mode in satp'')
        )))
     | _ => internal_error (''unsupported address translation arch'')
     ))))"


(*val translateAddr : mword ty64 -> AccessType -> ReadType -> M TR_Result*)

definition translateAddr  :: "(64)Word.word \<Rightarrow> AccessType \<Rightarrow> ReadType \<Rightarrow>((register_value),(TR_Result),(exception))monad "  where 
     " translateAddr vAddr ac rt = (
   (case  rt of
     Instruction => read_reg cur_privilege_ref
   | Data =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      if (((((get_Mstatus_MPRV w__1  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
        read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) . 
        return ((privLevel_of_bits ((get_Mstatus_MPP w__2  ::  2 Word.word)))))
      else read_reg cur_privilege_ref)
   ) \<bind> (\<lambda> (effPriv :: Privilege) . 
   read_reg mstatus_ref \<bind> (\<lambda> (w__5 :: Mstatus) . 
   (let (mxr :: bool) =
     (((get_Mstatus_MXR w__5  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))) in
   read_reg mstatus_ref \<bind> (\<lambda> (w__6 :: Mstatus) . 
   (let (do_sum :: bool) =
     (((get_Mstatus_SUM w__6  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))) in
   translationMode effPriv \<bind> (\<lambda> (mode :: SATPMode) .  
  (case  mode of
        Sbare => return (TR_Address vAddr)
    | SV39 =>
  translate39
    ((subrange_vec_dec vAddr (( 38 :: int):: ii) (( 0 :: int):: ii) :: 39 Word.word))
    ac effPriv mxr do_sum ((SV39_LEVELS - (( 1 :: int):: ii))) \<bind>
    (\<lambda> (w__7 :: TR39_Result) . 
     return
       ((case  w__7 of
              TR39_Address (pa) => TR_Address
                                     ((EXTZ (( 64 :: int):: ii) pa :: 64 Word.word))
          | TR39_Failure (f) => TR_Failure ((translationException ac f))
        )))
  ))))))))"


(*val decode : mword ty32 -> maybe ast*)

(*val decodeCompressed : mword ty16 -> maybe ast*)

(*val execute : ast -> M unit*)

(*val print_insn : ast -> string*)

(*val extend_value : forall 'int8_times_n . Size 'int8_times_n => bool -> MemoryOpResult (mword 'int8_times_n) -> MemoryOpResult (mword ty64)*)

fun extend_value  :: " bool \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow>((64)Word.word)MemoryOpResult "  where 
     " extend_value is_unsigned (MemValue (v)) = (
      MemValue (if is_unsigned then (EXTZ (( 64 :: int)::ii) v  ::  64 Word.word)
                else (EXTS (( 64 :: int)::ii) v  ::  64 Word.word)))"
|" extend_value is_unsigned (MemException (e)) = ( MemException e )"


(*val process_load : forall 'int8_times_n . Size 'int8_times_n => mword ty5 -> mword ty64 -> MemoryOpResult (mword 'int8_times_n) -> bool -> M unit*)

definition process_load  :: "(5)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " process_load rd addr value1 is_unsigned = (
   (case  ((extend_value is_unsigned value1  :: ( 64 Word.word) MemoryOpResult)) of
     MemValue (result) => wX ((regbits_to_regno rd)) result
   | MemException (e) => handle_mem_exception addr e
   ))"


(*val process_loadres : forall 'int8_times_n . regbits -> xlenbits -> MemoryOpResult (bits 'int8_times_n) -> bool -> unit*)

(*val readCSR : mword ty12 -> M (mword ty64)*)

definition readCSR  :: "(12)Word.word \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " readCSR csr = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (read_reg mvendorid_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (read_reg marchid_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (read_reg mimpid_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (read_reg mhartid_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     read_reg mstatus_ref \<bind> (\<lambda> (w__4 :: Mstatus) .  return ((get_Mstatus w__4  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     read_reg misa_ref \<bind> (\<lambda> (w__5 :: Misa) .  return ((get_Misa w__5  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     read_reg medeleg_ref \<bind> (\<lambda> (w__6 :: Medeleg) .  return ((get_Medeleg w__6  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     read_reg mideleg_ref \<bind> (\<lambda> (w__7 :: Minterrupts) . 
     return ((get_Minterrupts w__7  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     read_reg mie_ref \<bind> (\<lambda> (w__8 :: Minterrupts) .  return ((get_Minterrupts w__8  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     read_reg mtvec_ref \<bind> (\<lambda> (w__9 :: Mtvec) .  return ((get_Mtvec w__9  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (read_reg mscratch_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (read_reg mepc_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     read_reg mcause_ref \<bind> (\<lambda> (w__12 :: Mcause) .  return ((get_Mcause w__12  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (read_reg mtval_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     read_reg mip_ref \<bind> (\<lambda> (w__14 :: Minterrupts) . 
     return ((get_Minterrupts w__14  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     read_reg mstatus_ref \<bind> (\<lambda> (w__15 :: Mstatus) .  return ((get_Mstatus w__15  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     read_reg sedeleg_ref \<bind> (\<lambda> (w__16 :: Sedeleg) .  return ((get_Sedeleg w__16  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     read_reg sideleg_ref \<bind> (\<lambda> (w__17 :: Sinterrupts) . 
     return ((get_Sinterrupts w__17  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     read_reg mie_ref \<bind> (\<lambda> (w__18 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> (\<lambda> (w__19 :: Minterrupts) . 
     return ((get_Sinterrupts ((lower_mie w__18 w__19))  ::  64 Word.word))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     read_reg stvec_ref \<bind> (\<lambda> (w__20 :: Mtvec) .  return ((get_Mtvec w__20  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (read_reg sscratch_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (read_reg sepc_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     read_reg scause_ref \<bind> (\<lambda> (w__23 :: Mcause) .  return ((get_Mcause w__23  ::  64 Word.word)))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (read_reg stval_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     read_reg mip_ref \<bind> (\<lambda> (w__25 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> (\<lambda> (w__26 :: Minterrupts) . 
     return ((get_Sinterrupts ((lower_mip w__25 w__26))  ::  64 Word.word))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (read_reg satp_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (read_reg mcycle_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (read_reg mtime_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (read_reg minstret_ref  :: ( 64 Word.word) M)
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (read_reg tselect_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__31 ::  64 Word.word) . 
     return ((not_vec w__31  ::  64 Word.word)))
   else
     (let (_ :: unit) = (print_bits (''unhandled read to CSR '') csr) in
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                          B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                          B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
              ::  64 Word.word))))"


(*val writeCSR : mword ty12 -> mword ty64 -> M unit*)

definition writeCSR  :: "(12)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " writeCSR (csr :: csreg) (value1 :: xlenbits) = (
   (let b__0 = csr in
   (if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
      (write_reg mstatus_ref ((legalize_mstatus w__0 value1)) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__1 :: Mstatus) . 
      return (Some ((get_Mstatus w__1  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
      read_reg medeleg_ref \<bind> (\<lambda> (w__2 :: Medeleg) . 
      (write_reg medeleg_ref ((legalize_medeleg w__2 value1)) \<then>
      read_reg medeleg_ref) \<bind> (\<lambda> (w__3 :: Medeleg) . 
      return (Some ((get_Medeleg w__3  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
      read_reg mideleg_ref \<bind> (\<lambda> (w__4 :: Minterrupts) . 
      (write_reg mideleg_ref ((legalize_mideleg w__4 value1)) \<then>
      read_reg mideleg_ref) \<bind> (\<lambda> (w__5 :: Minterrupts) . 
      return (Some ((get_Minterrupts w__5  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
      read_reg mie_ref \<bind> (\<lambda> (w__6 :: Minterrupts) . 
      (write_reg mie_ref ((legalize_mie w__6 value1)) \<then>
      read_reg mie_ref) \<bind> (\<lambda> (w__7 :: Minterrupts) . 
      return (Some ((get_Minterrupts w__7  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
      read_reg mtvec_ref \<bind> (\<lambda> (w__8 :: Mtvec) . 
      (write_reg mtvec_ref ((legalize_tvec w__8 value1)) \<then>
      read_reg mtvec_ref) \<bind> (\<lambda> (w__9 :: Mtvec) .  return (Some ((get_Mtvec w__9  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      (write_reg mscratch_ref value1 \<then>
      (read_reg mscratch_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__10 ::  64 Word.word) .  return (Some w__10))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
      (legalize_xepc value1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 :: xlenbits) . 
      (write_reg mepc_ref w__11 \<then>
      (read_reg mepc_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__12 ::  64 Word.word) .  return (Some w__12)))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
      (set_Mcause mcause_ref value1 \<then>
      read_reg mcause_ref) \<bind> (\<lambda> (w__13 :: Mcause) . 
      return (Some ((get_Mcause w__13  ::  64 Word.word))))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
      (write_reg mtval_ref value1 \<then>
      (read_reg mtval_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__14 ::  64 Word.word) .  return (Some w__14))
    else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
      read_reg mip_ref \<bind> (\<lambda> (w__15 :: Minterrupts) . 
      (write_reg mip_ref ((legalize_mip w__15 value1)) \<then>
      read_reg mip_ref) \<bind> (\<lambda> (w__16 :: Minterrupts) . 
      return (Some ((get_Minterrupts w__16  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      read_reg mstatus_ref \<bind> (\<lambda> (w__17 :: Mstatus) . 
      (write_reg mstatus_ref ((legalize_sstatus w__17 value1)) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__18 :: Mstatus) . 
      return (Some ((get_Mstatus w__18  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
      read_reg sedeleg_ref \<bind> (\<lambda> (w__19 :: Sedeleg) . 
      (write_reg sedeleg_ref ((legalize_sedeleg w__19 value1)) \<then>
      read_reg sedeleg_ref) \<bind> (\<lambda> (w__20 :: Sedeleg) . 
      return (Some ((get_Sedeleg w__20  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
      (set_Sinterrupts sideleg_ref value1 \<then>
      read_reg sideleg_ref) \<bind> (\<lambda> (w__21 :: Sinterrupts) . 
      return (Some ((get_Sinterrupts w__21  ::  64 Word.word))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
      read_reg mie_ref \<bind> (\<lambda> (w__22 :: Minterrupts) . 
      read_reg mideleg_ref \<bind> (\<lambda> (w__23 :: Minterrupts) . 
      (write_reg mie_ref ((legalize_sie w__22 w__23 value1)) \<then>
      read_reg mie_ref) \<bind> (\<lambda> (w__24 :: Minterrupts) . 
      return (Some ((get_Minterrupts w__24  ::  64 Word.word))))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
      read_reg stvec_ref \<bind> (\<lambda> (w__25 :: Mtvec) . 
      (write_reg stvec_ref ((legalize_tvec w__25 value1)) \<then>
      read_reg stvec_ref) \<bind> (\<lambda> (w__26 :: Mtvec) .  return (Some ((get_Mtvec w__26  ::  64 Word.word)))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      (write_reg sscratch_ref value1 \<then>
      (read_reg sscratch_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__27 ::  64 Word.word) .  return (Some w__27))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
      (legalize_xepc value1  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__28 :: xlenbits) . 
      (write_reg sepc_ref w__28 \<then>
      (read_reg sepc_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__29 ::  64 Word.word) .  return (Some w__29)))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
      (set_Mcause scause_ref value1 \<then>
      read_reg scause_ref) \<bind> (\<lambda> (w__30 :: Mcause) . 
      return (Some ((get_Mcause w__30  ::  64 Word.word))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
      (write_reg stval_ref value1 \<then>
      (read_reg stval_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__31 ::  64 Word.word) .  return (Some w__31))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
      read_reg mip_ref \<bind> (\<lambda> (w__32 :: Minterrupts) . 
      read_reg mideleg_ref \<bind> (\<lambda> (w__33 :: Minterrupts) . 
      (write_reg mip_ref ((legalize_sip w__32 w__33 value1)) \<then>
      read_reg mip_ref) \<bind> (\<lambda> (w__34 :: Minterrupts) . 
      return (Some ((get_Minterrupts w__34  ::  64 Word.word))))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      cur_Architecture ()  \<bind> (\<lambda> (w__35 :: Architecture) . 
      (read_reg satp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__36 ::  64 Word.word) . 
      (write_reg satp_ref ((legalize_satp w__35 w__36 value1  ::  64 Word.word)) \<then>
      (read_reg satp_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__37 ::  64 Word.word) .  return (Some w__37))))
    else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      (write_reg tselect_ref value1 \<then>
      (read_reg tselect_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__38 ::  64 Word.word) .  return (Some w__38))
    else return None) \<bind> (\<lambda> (res ::  xlenbits option) . 
   return ((case  res of
     Some (v) =>
      prerr_endline
        (((op@) (''CSR '')
            (((op@) ((csr_name csr))
                (((op@) ('' <- '')
                    (((op@) ((string_of_vec v))
                        (((op@) ('' (input: '') (((op@) ((string_of_vec value1)) ('')'')))))))))))))
   | None => print_bits (''unhandled write to CSR '') csr
   )))))"


definition decode  :: "(32)Word.word \<Rightarrow>(ast)option "  where 
     " decode v__0 = (
   if (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B1,B1,B1]  ::  7 Word.word)))) then
     (let (imm :: 20 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (UTYPE (imm,rd,RISCV_LUI))))
   else if (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B1,B1,B1]  ::  7 Word.word)))) then
     (let (imm :: 20 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (UTYPE (imm,rd,RISCV_AUIPC))))
   else if (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))) then
     (let (imm :: 20 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RISCV_JAL ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm (( 19 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                             ((concat_vec
                                 ((cast_unit_vec0 ((access_vec_dec imm (( 8 :: int)::ii)))  ::  1 Word.word))
                                 ((concat_vec ((subrange_vec_dec imm (( 18 :: int)::ii) (( 13 :: int)::ii)  ::  6 Word.word))
                                     ((concat_vec
                                         ((subrange_vec_dec imm (( 12 :: int)::ii) (( 9 :: int)::ii)  ::  4 Word.word))
                                         (vec_of_bits [B0]  ::  1 Word.word)
                                        ::  5 Word.word))
                                    ::  11 Word.word))
                                ::  12 Word.word))
                            ::  20 Word.word))
                        ::  21 Word.word),rd))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RISCV_JALR (imm,rs1,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 :: int)::ii)))  ::  1 Word.word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word))
                                 (vec_of_bits [B0]  ::  1 Word.word)
                                ::  5 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word),rs2,rs1,RISCV_BEQ))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 :: int)::ii)))  ::  1 Word.word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word))
                                 (vec_of_bits [B0]  ::  1 Word.word)
                                ::  5 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word),rs2,rs1,RISCV_BNE))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 :: int)::ii)))  ::  1 Word.word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word))
                                 (vec_of_bits [B0]  ::  1 Word.word)
                                ::  5 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word),rs2,rs1,RISCV_BLT))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 :: int)::ii)))  ::  1 Word.word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word))
                                 (vec_of_bits [B0]  ::  1 Word.word)
                                ::  5 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word),rs2,rs1,RISCV_BGE))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 :: int)::ii)))  ::  1 Word.word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word))
                                 (vec_of_bits [B0]  ::  1 Word.word)
                                ::  5 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word),rs2,rs1,RISCV_BLTU))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (BTYPE ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm7 (( 6 :: int)::ii)))  ::  1 Word.word))
                     ((concat_vec ((cast_unit_vec0 ((access_vec_dec imm5 (( 0 :: int)::ii)))  ::  1 Word.word))
                         ((concat_vec ((subrange_vec_dec imm7 (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
                             ((concat_vec ((subrange_vec_dec imm5 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word))
                                 (vec_of_bits [B0]  ::  1 Word.word)
                                ::  5 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word),rs2,rs1,RISCV_BGEU))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ITYPE (imm,rs1,rd,RISCV_ADDI)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ITYPE (imm,rs1,rd,RISCV_SLTI)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ITYPE (imm,rs1,rd,RISCV_SLTIU)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ITYPE (imm,rs1,rd,RISCV_XORI)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ITYPE (imm,rs1,rd,RISCV_ORI)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ITYPE (imm,rs1,rd,RISCV_ANDI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (shamt :: 6 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (SHIFTIOP (shamt,rs1,rd,RISCV_SLLI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (shamt :: 6 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (SHIFTIOP (shamt,rs1,rd,RISCV_SRLI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (shamt :: 6 bits) = ((subrange_vec_dec v__0 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (SHIFTIOP (shamt,rs1,rd,RISCV_SRAI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_ADD)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_SUB)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_SLL)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_SLT)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_SLTU)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_XOR)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_SRL)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_SRA)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_OR)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPE (rs2,rs1,rd,RISCV_AND)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,False,BYTE,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,False,HALF,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,False,WORD,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,False,DOUBLE,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,True,BYTE,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,True,HALF,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOAD (imm,rs1,rd,True,WORD,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (STORE ((concat_vec imm7 imm5  ::  12 Word.word),rs2,rs1,BYTE,False,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (STORE ((concat_vec imm7 imm5  ::  12 Word.word),rs2,rs1,HALF,False,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (STORE ((concat_vec imm7 imm5  ::  12 Word.word),rs2,rs1,WORD,False,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm7 :: 7 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 5 bits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (STORE ((concat_vec imm7 imm5  ::  12 Word.word),rs2,rs1,DOUBLE,False,False))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (imm :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (ADDIW (imm,rs1,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (shamt :: 5 bits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (SHIFTW (shamt,rs1,rd,RISCV_SLLI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (shamt :: 5 bits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (SHIFTW (shamt,rs1,rd,RISCV_SRLI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (shamt :: 5 bits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (SHIFTW (shamt,rs1,rd,RISCV_SRAI)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPEW (rs2,rs1,rd,RISCV_ADDW)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPEW (rs2,rs1,rd,RISCV_SUBW)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPEW (rs2,rs1,rd,RISCV_SLLW)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPEW (rs2,rs1,rd,RISCV_SRLW)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (RTYPEW (rs2,rs1,rd,RISCV_SRAW)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (MUL (rs2,rs1,rd,False,True,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (MUL (rs2,rs1,rd,True,True,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (MUL (rs2,rs1,rd,True,True,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (MUL (rs2,rs1,rd,True,False,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (DIV (rs2,rs1,rd,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (DIV (rs2,rs1,rd,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (REM (rs2,rs1,rd,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (REM (rs2,rs1,rd,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (MULW (rs2,rs1,rd)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (DIVW (rs2,rs1,rd,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (DIVW (rs2,rs1,rd,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (REMW (rs2,rs1,rd,True)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (REMW (rs2,rs1,rd,False)))))
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                     ::  20 Word.word))))))) then
     (let (pred :: 4 bits) = ((subrange_vec_dec v__0 (( 27 :: int)::ii) (( 24 :: int)::ii)  ::  4 Word.word)) in
     (let (succ :: 4 bits) = ((subrange_vec_dec v__0 (( 23 :: int)::ii) (( 20 :: int)::ii)  ::  4 Word.word)) in
     Some (FENCE (pred,succ))))
   else if (((v__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,
                             B0,B0,B0,B0,B1,B1,B1,B1]
                 ::  32 Word.word)))) then
     Some (FENCEI () )
   else if (((v__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B1,B1,B1,B0,B0,B1,B1]
                 ::  32 Word.word)))) then
     Some (ECALL () )
   else if (((v__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B1,B1,B1,B0,B0,B1,B1]
                 ::  32 Word.word)))) then
     Some (MRET () )
   else if (((v__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B1,B1,B1,B0,B0,B1,B1]
                 ::  32 Word.word)))) then
     Some (SRET () )
   else if (((v__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B1,B1,B1,B0,B0,B1,B1]
                 ::  32 Word.word)))) then
     Some (EBREAK () )
   else if (((v__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                             B0,B1,B1,B1,B0,B0,B1,B1]
                 ::  32 Word.word)))) then
     Some (WFI () )
   else if ((((((((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 0 :: int)::ii)  ::  15 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]  ::  15 Word.word)))))))
   then
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     Some (SFENCE_VMA (rs1,rs2))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word))))))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOADRES (bit_to_bool aq,bit_to_bool rl,rs1,WORD,rd))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word))))))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (LOADRES (bit_to_bool aq,bit_to_bool rl,rs1,DOUBLE,rd))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (STORECON (bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (STORECON (bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOSWAP,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOSWAP,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOADD,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOADD,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOXOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOXOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOAND,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOAND,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOOR,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMIN,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMIN,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMAX,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMAX,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMINU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMINU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMAXU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,WORD,rd)))))))
   else if ((((((((regbits_to_regno ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))) then
     (let aq = (access_vec_dec v__0 (( 26 :: int)::ii)) in
     (let rl = (access_vec_dec v__0 (( 25 :: int)::ii)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__0 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (AMO (AMOMAXU,bit_to_bool aq,bit_to_bool rl,rs2,rs1,DOUBLE,rd)))))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (csr :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (CSR (csr,rs1,rd,False,CSRRW)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (csr :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (CSR (csr,rs1,rd,False,CSRRS)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (csr :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (CSR (csr,rs1,rd,False,CSRRC)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (csr :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (CSR (csr,rs1,rd,True,CSRRW)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (csr :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (CSR (csr,rs1,rd,True,CSRRS)))))
   else if ((((((((subrange_vec_dec v__0 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__0 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))) then
     (let (csr :: 12 bits) = ((subrange_vec_dec v__0 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 :: regbits) = ((subrange_vec_dec v__0 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__0 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     Some (CSR (csr,rs1,rd,True,CSRRC)))))
   else None )"


definition decodeCompressed  :: "(16)Word.word \<Rightarrow>(ast)option "  where 
     " decodeCompressed v__418 = (
   if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> ((((((((regbits_to_regno ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (nzi1 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi0 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     if ((((((nzi1 = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((regbits_to_regno nzi0)) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))))) then
       Some (NOP () )
     else None))
   else if (((v__418 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  16 Word.word)))) then
     Some (ILLEGAL () )
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (nz54 :: 2 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
     (let (nz96 :: 4 bits) = ((subrange_vec_dec v__418 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
     (let (nz2 :: 1 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (nz3 :: 1 bits) = ((subrange_vec_dec v__418 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (rd :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let nzimm =
       ((concat_vec nz96 ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
         ::  8 Word.word)) in
     if (((nzimm = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))) then None
     else Some (C_ADDI4SPN (rd,nzimm))))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (ui2 :: 1 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (ui6 :: 1 bits) = ((subrange_vec_dec v__418 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (rd :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let uimm = ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word)) in
     Some (C_LW (uimm,rs1,rd))))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (rd :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let uimm = ((concat_vec ui76 ui53  ::  5 Word.word)) in
     Some (C_LD (uimm,rs1,rd)))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (ui2 :: 1 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (ui6 :: 1 bits) = ((subrange_vec_dec v__418 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let uimm = ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word)) in
     Some (C_SW (uimm,rs1,rs2))))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: 3 bits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (rs2 :: 3 bits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let uimm = ((concat_vec ui76 ui53  ::  5 Word.word)) in
     Some (C_SD (uimm,rs1,rs2)))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rsd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let nzi = ((concat_vec nzi5 nzi40  ::  6 Word.word)) in
     if ((((((nzi = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<or> (((((regbits_to_regno rsd)) = ((regbits_to_regno zreg)))))))) then
       None
     else Some (C_ADDI (nzi,rsd))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rsd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     Some (C_ADDIW ((concat_vec imm5 imm40  ::  6 Word.word),rsd)))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then None
     else Some (C_LI ((concat_vec imm5 imm40  ::  6 Word.word),rd)))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> ((((((((regbits_to_regno ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)))) = ((regbits_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__418 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__418 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let nzimm =
       ((concat_vec nzi9
          ((concat_vec nzi87 ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
             ::  5 Word.word))
         ::  6 Word.word)) in
     if (((nzimm = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then None
     else Some (C_ADDI16SP nzimm)))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (imm17 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     if ((((((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) \<or> (((((regbits_to_regno rd)) = ((regbits_to_regno sp)))))))) then
       None
     else Some (C_LUI ((concat_vec imm17 imm1612  ::  6 Word.word),rd)))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (shamt :: 6 bits) = ((concat_vec nzui5 nzui40  ::  6 Word.word)) in
     if (((shamt = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then None
     else Some (C_SRLI (shamt,rsd))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (shamt :: 6 bits) = ((concat_vec nzui5 nzui40  ::  6 Word.word)) in
     if (((shamt = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then None
     else Some (C_SRAI (shamt,rsd))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     Some (C_ANDI ((concat_vec i5 i40  ::  6 Word.word),rsd)))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     Some (C_SUB (rsd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     Some (C_XOR (rsd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     Some (C_OR (rsd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     Some (C_AND (rsd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     Some (C_SUBW (rsd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregbits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     Some (C_ADDW (rsd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (i11 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i4 :: 1 bits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
     (let (i98 :: 2 bits) = ((subrange_vec_dec v__418 (( 10 :: int)::ii) (( 9 :: int)::ii)  ::  2 Word.word)) in
     (let (i10 :: 1 bits) = ((subrange_vec_dec v__418 (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word)) in
     (let (i6 :: 1 bits) = ((subrange_vec_dec v__418 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
     (let (i7 :: 1 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (i31 :: 3 bits) = ((subrange_vec_dec v__418 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__418 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     Some (C_J ((concat_vec i11
                   ((concat_vec i10
                       ((concat_vec i98
                           ((concat_vec i7
                               ((concat_vec i6
                                   ((concat_vec i5 ((concat_vec i4 i31  ::  4 Word.word))  ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  9 Word.word))
                      ::  10 Word.word))
                  ::  11 Word.word)))))))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (i8 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i43 :: 2 bits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (rs :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i76 :: 2 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (i21 :: 2 bits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__418 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     Some (C_BEQZ ((concat_vec i8
                      ((concat_vec i76
                          ((concat_vec i5 ((concat_vec i43 i21  ::  4 Word.word))  ::  5 Word.word))
                         ::  7 Word.word))
                     ::  8 Word.word),rs))))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (i8 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i43 :: 2 bits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (rs :: cregbits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i76 :: 2 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (i21 :: 2 bits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__418 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     Some (C_BNEZ ((concat_vec i8
                      ((concat_vec i76
                          ((concat_vec i5 ((concat_vec i43 i21  ::  4 Word.word))  ::  5 Word.word))
                         ::  7 Word.word))
                     ::  8 Word.word),rs))))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rsd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (shamt :: 6 bits) = ((concat_vec nzui5 nzui40  ::  6 Word.word)) in
     if ((((((shamt = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<or> (((((regbits_to_regno rsd)) = ((regbits_to_regno zreg)))))))) then
       None
     else Some (C_SLLI (shamt,rsd))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (ui5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (ui42 :: 3 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) in
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__418 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
     (let (uimm :: 6 bits) = ((concat_vec ui76 ((concat_vec ui5 ui42  ::  4 Word.word))  ::  6 Word.word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then None
     else Some (C_LWSP (uimm,rd)))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (ui5 :: 1 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (rd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (ui43 :: 2 bits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (ui86 :: 3 bits) = ((subrange_vec_dec v__418 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (uimm :: 6 bits) = ((concat_vec ui86 ((concat_vec ui5 ui43  ::  3 Word.word))  ::  6 Word.word)) in
     if (((((regbits_to_regno rd)) = ((regbits_to_regno zreg))))) then None
     else Some (C_LDSP (uimm,rd)))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (ui52 :: 4 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 9 :: int)::ii)  ::  4 Word.word)) in
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__418 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (uimm :: 6 bits) = ((concat_vec ui76 ui52  ::  6 Word.word)) in
     Some (C_SWSP (uimm,rs2))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__418 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (ui86 :: 3 bits) = ((subrange_vec_dec v__418 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (uimm :: 6 bits) = ((concat_vec ui86 ui53  ::  6 Word.word)) in
     Some (C_SDSP (uimm,rs2))))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word))))))) then
     (let (rs1 :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     if (((((regbits_to_regno rs1)) = ((regbits_to_regno zreg))))) then None
     else Some (C_JR rs1))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word))))))) then
     (let (rs1 :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     if (((((regbits_to_regno rs1)) = ((regbits_to_regno zreg))))) then None
     else Some (C_JALR rs1))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (rd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     if ((((((((regbits_to_regno rs2)) = ((regbits_to_regno zreg))))) \<or> (((((regbits_to_regno rd)) = ((regbits_to_regno zreg)))))))) then
       None
     else Some (C_MV (rd,rs2))))
   else if ((((((((subrange_vec_dec v__418 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__418 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (rsd :: regbits) = ((subrange_vec_dec v__418 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (rs2 :: regbits) = ((subrange_vec_dec v__418 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     if ((((((((regbits_to_regno rsd)) = ((regbits_to_regno zreg))))) \<or> (((((regbits_to_regno rs2)) = ((regbits_to_regno zreg)))))))) then
       None
     else Some (C_ADD (rsd,rs2))))
   else None )"


(*val execute_WFI : unit -> M unit*)

fun  execute_WFI  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_WFI g__110 = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     Machine => return () 
   | Supervisor =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      if (((((get_Mstatus_TW w__1  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
        handle_illegal () 
      else return () )
   | User => handle_illegal () 
   )))"


(*val execute_UTYPE : mword ty20 -> mword ty5 -> uop -> M unit*)

fun  execute_UTYPE  :: "(20)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> uop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_UTYPE imm rd op1 = (
   (let (off :: xlenbits) =
     ((EXTS (( 64 :: int)::ii)
        ((concat_vec imm (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
           ::  32 Word.word))
       ::  64 Word.word)) in
   (case  op1 of
     RISCV_LUI => return off
   | RISCV_AUIPC =>
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      return ((add_vec w__0 off  ::  64 Word.word)))
   ) \<bind> (\<lambda> (ret :: xlenbits) . 
   wX ((regbits_to_regno rd)) ret)))"


(*val execute_STORECON : bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M unit*)

fun  execute_STORECON  :: " bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_STORECON aq rl rs2 rs1 width rd = (
   speculate_conditional_success ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (let (status :: 1 bits) =
     (if w__0 then (vec_of_bits [B0]  ::  1 Word.word)
     else (vec_of_bits [B1]  ::  1 Word.word)) in
   wX ((regbits_to_regno rd)) ((EXTZ (( 64 :: int)::ii) status  ::  64 Word.word)) \<then>
   (if (((status = (vec_of_bits [B1]  ::  1 Word.word)))) then return () 
   else
     (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (vaddr :: xlenbits) . 
     translateAddr vaddr Write Data \<bind> (\<lambda> (w__1 :: TR_Result) . 
     (case  w__1 of
       TR_Failure (e) => handle_mem_exception vaddr e
     | TR_Address (addr) =>
        (case  width of
          WORD => mem_write_ea addr (( 4 :: int)::ii) aq rl True
        | DOUBLE => mem_write_ea addr (( 8 :: int)::ii) aq rl True
        | _ => internal_error (''STORECON expected word or double'')
        ) \<bind> (\<lambda> (eares :: unit MemoryOpResult) . 
        (case  eares of
          MemException (e) => handle_mem_exception addr e
        | MemValue (_) =>
           (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
           (case  width of
             WORD =>
              mem_write_value addr (( 4 :: int)::ii) ((subrange_vec_dec rs2_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                aq rl True
           | DOUBLE => mem_write_value addr (( 8 :: int)::ii) rs2_val aq rl True
           | _ => internal_error (''STORECON expected word or double'')
           ) \<bind> (\<lambda> (res :: unit MemoryOpResult) . 
           (case  res of
             MemValue (_) => return () 
           | MemException (e) => handle_mem_exception addr e
           )))
        ))
     )))))))"


(*val execute_STORE : mword ty12 -> mword ty5 -> mword ty5 -> word_width -> bool -> bool -> M unit*)

fun  execute_STORE  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_STORE imm rs2 rs1 width aq rl = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let (vaddr :: xlenbits) = ((add_vec w__0 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)) in
   translateAddr vaddr Write Data \<bind> (\<lambda> (w__1 :: TR_Result) . 
   (case  w__1 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case  width of
        BYTE => mem_write_ea addr (( 1 :: int)::ii) aq rl False
      | HALF => mem_write_ea addr (( 2 :: int)::ii) aq rl False
      | WORD => mem_write_ea addr (( 4 :: int)::ii) aq rl False
      | DOUBLE => mem_write_ea addr (( 8 :: int)::ii) aq rl False
      ) \<bind> (\<lambda> (eares :: unit MemoryOpResult) . 
      (case  eares of
        MemException (e) => handle_mem_exception addr e
      | MemValue (_) =>
         (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
         (case  width of
           BYTE =>
            mem_write_value addr (( 1 :: int)::ii) ((subrange_vec_dec rs2_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) aq
              rl False
         | HALF =>
            mem_write_value addr (( 2 :: int)::ii) ((subrange_vec_dec rs2_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) aq
              rl False
         | WORD =>
            mem_write_value addr (( 4 :: int)::ii) ((subrange_vec_dec rs2_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) aq
              rl False
         | DOUBLE => mem_write_value addr (( 8 :: int)::ii) rs2_val aq rl False
         ) \<bind> (\<lambda> (res :: unit MemoryOpResult) . 
         (case  res of
           MemValue (_) => return () 
         | MemException (e) => handle_mem_exception addr e
         )))
      ))
   )))))"


(*val execute_SRET : unit -> M unit*)

fun  execute_SRET  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SRET g__108 = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     User => handle_illegal () 
   | Supervisor =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      if (((((get_Mstatus_TSR w__1  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
        handle_illegal () 
      else
        read_reg cur_privilege_ref \<bind> (\<lambda> (w__2 :: Privilege) . 
        (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
        (handle_exception w__2 (CTL_SRET () ) w__3  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 :: xlenbits) . 
        write_reg nextPC_ref w__4))))
   | Machine =>
      read_reg cur_privilege_ref \<bind> (\<lambda> (w__5 :: Privilege) . 
      (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
      (handle_exception w__5 (CTL_SRET () ) w__6  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 :: xlenbits) . 
      write_reg nextPC_ref w__7)))
   )))"


(*val execute_SHIFTW : mword ty5 -> mword ty5 -> mword ty5 -> sop -> M unit*)

fun  execute_SHIFTW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SHIFTW shamt rs1 rd op1 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  ::  32 Word.word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  ::  32 Word.word)
     | RISCV_SRAI => (shift_right_arith32 rs1_val shamt  ::  32 Word.word)
     )) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 :: int)::ii) result  ::  64 Word.word))))))"


(*val execute_SHIFTIOP : mword ty6 -> mword ty5 -> mword ty5 -> sop -> M unit*)

fun  execute_SHIFTIOP  :: "(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SHIFTIOP shamt rs1 rd op1 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  ::  64 Word.word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  ::  64 Word.word)
     | RISCV_SRAI => (shift_right_arith64 rs1_val shamt  ::  64 Word.word)
     )) in
   wX ((regbits_to_regno rd)) result)))"


(*val execute_SFENCE_VMA : mword ty5 -> mword ty5 -> M unit*)

fun  execute_SFENCE_VMA  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_SFENCE_VMA rs1 rs2 = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   if (((((privLevel_to_bits w__0  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word)))))
   then
     handle_illegal () 
   else
     read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
     read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) . 
     (let p__104 =
       (architecture ((get_Mstatus_SXL w__1  ::  2 Word.word)), (get_Mstatus_TVM w__2  ::  1 Word.word)) in
     (case  p__104 of
       (Some (RV64), v_0) =>
        if (((v_0 = ((bool_to_bits True  ::  1 Word.word))))) then handle_illegal () 
        else
          (if (((((regbits_to_regno rs1)) = (( 0 :: int)::ii)))) then return None
           else
             (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
             return (Some ((subrange_vec_dec w__3 (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word))))) \<bind> (\<lambda> (addr ::
             vaddr39 option) . 
          (if (((((regbits_to_regno rs2)) = (( 0 :: int)::ii)))) then return None
           else
             (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
             return (Some ((subrange_vec_dec w__4 (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))))) \<bind> (\<lambda> (asid ::
             asid64 option) . 
          flushTLB asid addr))
     | (g__102, g__103) => internal_error (''unimplemented sfence architecture'')
     ))))))"


(*val execute_RTYPEW : mword ty5 -> mword ty5 -> mword ty5 -> ropw -> M unit*)

fun  execute_RTYPEW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> ropw \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_RTYPEW rs2 rs1 rd op1 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_ADDW => (add_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SUBW => (sub_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SLLW =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRLW =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRAW =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     )) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 :: int)::ii) result  ::  64 Word.word))))))))"


(*val execute_RTYPE : mword ty5 -> mword ty5 -> mword ty5 -> rop -> M unit*)

fun  execute_RTYPE  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_RTYPE rs2 rs1 rd op1 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_ADD => (add_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_SUB => (sub_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_SLL =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
          ::  64 Word.word)
     | RISCV_SLT =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_s rs1_val rs2_val))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_SLTU =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_u rs1_val rs2_val))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_XOR => (xor_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_SRL =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
          ::  64 Word.word)
     | RISCV_SRA =>
        (shift_right_arith64 rs1_val ((subrange_vec_dec rs2_val (( 5 :: int)::ii) (( 0 :: int)::ii)  ::  6 Word.word))
          ::  64 Word.word)
     | RISCV_OR => (or_vec rs1_val rs2_val  ::  64 Word.word)
     | RISCV_AND => (and_vec rs1_val rs2_val  ::  64 Word.word)
     )) in
   wX ((regbits_to_regno rd)) result))))"


(*val execute_RISCV_JALR : mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

fun  execute_RISCV_JALR  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_RISCV_JALR imm rs1 rd = (
   (read_reg nextPC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (wX ((regbits_to_regno rd)) w__0 \<then>
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let (newPC :: xlenbits) = ((add_vec w__1 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)) in
   write_reg
     nextPC_ref
     ((concat_vec ((subrange_vec_dec newPC (( 63 :: int)::ii) (( 1 :: int)::ii)  ::  63 Word.word))
         (vec_of_bits [B0]  ::  1 Word.word)
        ::  64 Word.word))))))"


(*val execute_RISCV_JAL : mword ty21 -> mword ty5 -> M unit*)

fun  execute_RISCV_JAL  :: "(21)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_RISCV_JAL imm rd = (
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (pc :: xlenbits) . 
   (read_reg nextPC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   wX ((regbits_to_regno rd)) w__0 \<then>
   ((let (offset :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   write_reg nextPC_ref ((add_vec pc offset  ::  64 Word.word)))))))"


(*val execute_REMW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

fun  execute_REMW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_REMW rs2 rs1 rd s = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
   (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
   (let (r :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 :: int)::ii) ((to_bits (( 32 :: int)::ii) r  ::  32 Word.word))  ::  64 Word.word))))))))))"


(*val execute_REM : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

fun  execute_REM  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_REM rs2 rs1 rd s = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
   (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
   (let (r :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
   wX ((regbits_to_regno rd)) ((to_bits xlen r  ::  64 Word.word))))))))"


(*val execute_NOP : unit -> unit*)

fun  execute_NOP  :: " unit \<Rightarrow> unit "  where 
     " execute_NOP g__111 = ( ()  )"


(*val execute_MULW : mword ty5 -> mword ty5 -> mword ty5 -> M unit*)

fun  execute_MULW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MULW rs2 rs1 rd = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (rs1_int :: ii) = (Word.sint rs1_val) in
   (let (rs2_int :: ii) = (Word.sint rs2_val) in
   (let result32 =
     ((subrange_vec_dec ((to_bits (( 64 :: int)::ii) ((rs1_int * rs2_int))  ::  64 Word.word)) (( 31 :: int)::ii)
        (( 0 :: int)::ii)
       ::  32 Word.word)) in
   (let (result :: xlenbits) = ((EXTS (( 64 :: int)::ii) result32  ::  64 Word.word)) in
   wX ((regbits_to_regno rd)) result)))))))))"


(*val execute_MUL : mword ty5 -> mword ty5 -> mword ty5 -> bool -> bool -> bool -> M unit*)

fun  execute_MUL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MUL rs2 rs1 rd high signed1 signed2 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (rs1_int :: ii) = (if signed1 then Word.sint rs1_val else Word.uint rs1_val) in
   (let (rs2_int :: ii) = (if signed2 then Word.sint rs2_val else Word.uint rs2_val) in
   (let result128 = ((to_bits (( 128 :: int)::ii) ((rs1_int * rs2_int))  ::  128 Word.word)) in
   (let result =
     (if high then (subrange_vec_dec result128 (( 127 :: int)::ii) (( 64 :: int)::ii)  ::  64 Word.word)
     else (subrange_vec_dec result128 (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) in
   wX ((regbits_to_regno rd)) result)))))))"


(*val execute_MRET : unit -> M unit*)

fun  execute_MRET  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_MRET g__107 = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   if (((((privLevel_to_bits w__0  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   then
     read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
     (handle_exception w__1 (CTL_MRET () ) w__2  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: xlenbits) . 
     write_reg nextPC_ref w__3)))
   else handle_illegal () ))"


(*val execute_LOADRES : bool -> bool -> mword ty5 -> word_width -> mword ty5 -> M unit*)

fun  execute_LOADRES  :: " bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LOADRES aq rl rs1 width rd = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (vaddr :: xlenbits) . 
   translateAddr vaddr Read Data \<bind> (\<lambda> (w__0 :: TR_Result) . 
   (case  w__0 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case  width of
        WORD =>
         (mem_read addr (( 4 :: int)::ii) aq rl True  :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__1 :: ( 32 Word.word)
           MemoryOpResult) . 
         process_load rd addr w__1 False)
      | DOUBLE =>
         (mem_read addr (( 8 :: int)::ii) aq rl True  :: ( ( 64 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__2 :: ( 64 Word.word)
           MemoryOpResult) . 
         process_load rd addr w__2 False)
      | _ => internal_error (''LOADRES expected WORD or DOUBLE'')
      )
   ))))"


(*val execute_LOAD : mword ty12 -> mword ty5 -> mword ty5 -> bool -> word_width -> bool -> bool -> M unit*)

fun  execute_LOAD  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> word_width \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_LOAD imm rs1 rd is_unsigned width aq rl = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let (vaddr :: xlenbits) = ((add_vec w__0 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)) in
   translateAddr vaddr Read Data \<bind> (\<lambda> (w__1 :: TR_Result) . 
   (case  w__1 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case  width of
        BYTE =>
         (mem_read addr (( 1 :: int)::ii) aq rl False  :: ( ( 8 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__2 :: ( 8 Word.word)
           MemoryOpResult) . 
         process_load rd vaddr w__2 is_unsigned)
      | HALF =>
         (mem_read addr (( 2 :: int)::ii) aq rl False  :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__3 :: ( 16 Word.word)
           MemoryOpResult) . 
         process_load rd vaddr w__3 is_unsigned)
      | WORD =>
         (mem_read addr (( 4 :: int)::ii) aq rl False  :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__4 :: ( 32 Word.word)
           MemoryOpResult) . 
         process_load rd vaddr w__4 is_unsigned)
      | DOUBLE =>
         (mem_read addr (( 8 :: int)::ii) aq rl False  :: ( ( 64 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__5 :: ( 64 Word.word)
           MemoryOpResult) . 
         process_load rd vaddr w__5 is_unsigned)
      )
   )))))"


(*val execute_ITYPE : mword ty12 -> mword ty5 -> mword ty5 -> iop -> M unit*)

fun  execute_ITYPE  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> iop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ITYPE imm rs1 rd op1 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (let (immext :: xlenbits) = ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) in
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_ADDI => (add_vec rs1_val immext  ::  64 Word.word)
     | RISCV_SLTI =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_s rs1_val immext))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_SLTIU =>
        (EXTZ (( 64 :: int)::ii) ((bool_to_bits ((zopz0zI_u rs1_val immext))  ::  1 Word.word))  ::  64 Word.word)
     | RISCV_XORI => (xor_vec rs1_val immext  ::  64 Word.word)
     | RISCV_ORI => (or_vec rs1_val immext  ::  64 Word.word)
     | RISCV_ANDI => (and_vec rs1_val immext  ::  64 Word.word)
     )) in
   wX ((regbits_to_regno rd)) result))))"


(*val execute_ILLEGAL : unit -> M unit*)

fun  execute_ILLEGAL  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ILLEGAL g__112 = ( handle_illegal ()  )"


(*val execute_FENCEI : unit -> M unit*)

fun  execute_FENCEI  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_FENCEI g__105 = ( MEM_fence_i ()  )"


(*val execute_FENCE : mword ty4 -> mword ty4 -> M unit*)

fun  execute_FENCE  :: "(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_FENCE b__0 b__1 = (
      if ((((((b__0 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word))))))) then
        MEM_fence_rw_rw () 
      else if ((((((b__0 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word))))))) then
        MEM_fence_r_rw () 
      else if ((((((b__0 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0,B1,B0]  ::  4 Word.word))))))) then
        MEM_fence_r_r () 
      else if ((((((b__0 = (vec_of_bits [B0,B0,B1,B1]  ::  4 Word.word)))) \<and> (((b__1 = (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word))))))) then
        MEM_fence_rw_w () 
      else MEM_fence_w_w ()  )"


(*val execute_ECALL : unit -> M unit*)

fun  execute_ECALL  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ECALL g__106 = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (let (t :: sync_exception) =
     ((| sync_exception_trap =
          ((case  w__0 of
            User => E_U_EnvCall
          | Supervisor => E_S_EnvCall
          | Machine => E_M_EnvCall
          )), 
        sync_exception_excinfo = None |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
   (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
   (handle_exception w__1 (CTL_TRAP t) w__2  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 :: xlenbits) . 
   write_reg nextPC_ref w__3))))))"


(*val execute_EBREAK : unit -> M unit*)

fun  execute_EBREAK  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_EBREAK g__109 = ( throw (Error_EBREAK () ))"


(*val execute_DIVW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

fun  execute_DIVW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DIVW rs2 rs1 rd s = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (let rs2_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
   (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
   (let (q :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then ((( 0 :: int)-( 1 :: int))::ii) else hardware_quot rs1_int rs2_int) in
   (let (q' :: ii) =
     (if (((s \<and> ((q > ((((pow2 (( 31 :: int)::ii))) - (( 1 :: int)::ii)))))))) then
       (( 0 :: int)::ii) - ((ex_int ((pow (( 2 :: int)::ii) (( 31 :: int)::ii)))))
     else q) in
   wX ((regbits_to_regno rd)) ((EXTS (( 64 :: int)::ii) ((to_bits (( 32 :: int)::ii) q'  ::  32 Word.word))  ::  64 Word.word)))))))))))"


(*val execute_DIV : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M unit*)

fun  execute_DIV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_DIV rs2 rs1 rd s = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
   (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
   (let (q :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then ((( 0 :: int)-( 1 :: int))::ii) else hardware_quot rs1_int rs2_int) in
   (let (q' :: ii) = (if (((s \<and> ((q > xlen_max_signed))))) then xlen_min_signed else q) in
   wX ((regbits_to_regno rd)) ((to_bits xlen q'  ::  64 Word.word)))))))))"


(*val execute_C_ADDIW : mword ty6 -> mword ty5 -> M unit*)

fun  execute_C_ADDIW  :: "(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_C_ADDIW imm rsd = (
   (let (imm :: 32 bits) = ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word)) in
   (rX ((regbits_to_regno rsd))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs_val . 
   (let (res :: 32 bits) =
     ((add_vec ((subrange_vec_dec rs_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) imm  ::  32 Word.word)) in
   wX ((regbits_to_regno rsd)) ((EXTS (( 64 :: int)::ii) res  ::  64 Word.word))))))"


(*val execute_CSR : mword ty12 -> mword ty5 -> mword ty5 -> bool -> csrop -> M unit*)

fun  execute_CSR  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> csrop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_CSR csr rs1 rd is_imm op1 = (
   (if is_imm then return ((EXTZ (( 64 :: int)::ii) rs1  ::  64 Word.word))
    else (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M)) \<bind> (\<lambda> (rs1_val :: xlenbits) . 
   (let (isWrite :: bool) =
     ((case  op1 of
       CSRRW => True
     | _ => if is_imm then (((Word.uint rs1_val)) \<noteq> (( 0 :: int)::ii)) else (((Word.uint rs1)) \<noteq> (( 0 :: int)::ii))
     )) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
   check_CSR csr w__1 isWrite \<bind> (\<lambda> (w__2 :: bool) . 
   if ((\<not> w__2)) then handle_illegal () 
   else
     (readCSR csr  :: ( 64 Word.word) M) \<bind> (\<lambda> csr_val . 
     (if isWrite then
        (let (new_val :: xlenbits) =
          ((case  op1 of
            CSRRW => rs1_val
          | CSRRS => (or_vec csr_val rs1_val  ::  64 Word.word)
          | CSRRC => (and_vec csr_val ((not_vec rs1_val  ::  64 Word.word))  ::  64 Word.word)
          )) in
        writeCSR csr new_val)
      else return () ) \<then>
     wX ((regbits_to_regno rd)) csr_val))))))"


(*val execute_BTYPE : mword ty13 -> mword ty5 -> mword ty5 -> bop -> M unit*)

fun  execute_BTYPE  :: "(13)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bop \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_BTYPE imm rs2 rs1 op1 = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (taken :: bool) =
     ((case  op1 of
       RISCV_BEQ => (rs1_val = rs2_val)
     | RISCV_BNE => (rs1_val \<noteq> rs2_val)
     | RISCV_BLT => zopz0zI_s rs1_val rs2_val
     | RISCV_BGE => zopz0zKzJ_s rs1_val rs2_val
     | RISCV_BLTU => zopz0zI_u rs1_val rs2_val
     | RISCV_BGEU => zopz0zKzJ_u rs1_val rs2_val
     )) in
   if taken then
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     write_reg nextPC_ref ((add_vec w__0 ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word))  ::  64 Word.word)))
   else return () ))))"


(*val execute_AMO : amoop -> bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M unit*)

fun  execute_AMO  :: " amoop \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_AMO op1 aq rl rs2 rs1 width rd = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (vaddr :: xlenbits) . 
   translateAddr vaddr ReadWrite Data \<bind> (\<lambda> (w__0 :: TR_Result) . 
   (case  w__0 of
     TR_Failure (e) => handle_mem_exception vaddr e
   | TR_Address (addr) =>
      (case  width of
        WORD => mem_write_ea addr (( 4 :: int)::ii) (((aq \<and> rl))) rl True
      | DOUBLE => mem_write_ea addr (( 8 :: int)::ii) (((aq \<and> rl))) rl True
      | _ => internal_error (''AMO expected WORD or DOUBLE'')
      ) \<bind> (\<lambda> (eares :: unit MemoryOpResult) . 
      (case  eares of
        MemException (e) => handle_mem_exception addr e
      | MemValue (_) =>
         (case  width of
           WORD =>
            (mem_read addr (( 4 :: int)::ii) aq (((aq \<and> rl))) True  :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__4 :: ( 32 Word.word)
              MemoryOpResult) . 
            return ((extend_value False w__4  :: ( 64 Word.word) MemoryOpResult)))
         | DOUBLE =>
            (mem_read addr (( 8 :: int)::ii) aq (((aq \<and> rl))) True  :: ( ( 64 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__5 :: ( 64 Word.word)
              MemoryOpResult) . 
            return ((extend_value False w__5  :: ( 64 Word.word) MemoryOpResult)))
         | _ => (internal_error (''AMO expected WORD or DOUBLE'')  :: ( ( 64 Word.word)MemoryOpResult) M)
         ) \<bind> (\<lambda> (rval :: xlenbits MemoryOpResult) . 
         (case  rval of
           MemException (e) => handle_mem_exception addr e
         | MemValue (loaded) =>
            (rX ((regbits_to_regno rs2))  :: ( 64 Word.word) M) \<bind> (\<lambda> (rs2_val :: xlenbits) . 
            (let (result :: xlenbits) =
              ((case  op1 of
                AMOSWAP => rs2_val
              | AMOADD => (add_vec rs2_val loaded  ::  64 Word.word)
              | AMOXOR => (xor_vec rs2_val loaded  ::  64 Word.word)
              | AMOAND => (and_vec rs2_val loaded  ::  64 Word.word)
              | AMOOR => (or_vec rs2_val loaded  ::  64 Word.word)
              | AMOMIN => (vector64 ((min ((Word.sint rs2_val)) ((Word.sint loaded))))  ::  64 Word.word)
              | AMOMAX => (vector64 ((max ((Word.sint rs2_val)) ((Word.sint loaded))))  ::  64 Word.word)
              | AMOMINU => (vector64 ((min ((Word.uint rs2_val)) ((Word.uint loaded))))  ::  64 Word.word)
              | AMOMAXU => (vector64 ((max ((Word.uint rs2_val)) ((Word.uint loaded))))  ::  64 Word.word)
              )) in
            (case  width of
              WORD =>
               mem_write_value addr (( 4 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                 (((aq \<and> rl))) rl True
            | DOUBLE => mem_write_value addr (( 8 :: int)::ii) result (((aq \<and> rl))) rl True
            | _ => internal_error (''AMO expected WORD or DOUBLE'')
            ) \<bind> (\<lambda> (wval :: unit MemoryOpResult) . 
            (case  wval of
              MemValue (_) => wX ((regbits_to_regno rd)) loaded
            | MemException (e) => handle_mem_exception addr e
            ))))
         ))
      ))
   ))))"


(*val execute_ADDIW : mword ty12 -> mword ty5 -> mword ty5 -> M unit*)

fun  execute_ADDIW  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute_ADDIW imm rs1 rd = (
   (rX ((regbits_to_regno rs1))  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (let (result :: xlenbits) = ((add_vec ((EXTS (( 64 :: int)::ii) imm  ::  64 Word.word)) w__0  ::  64 Word.word)) in
   wX ((regbits_to_regno rd))
     ((EXTS (( 64 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))  ::  64 Word.word)))))"


function (sequential,domintros)  execute  :: " ast \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " execute (C_ADDI4SPN (rdc,nzimm)) = (
      (let (imm :: 12 bits) =
        ((concat_vec (vec_of_bits [B0,B0]  ::  2 Word.word)
           ((concat_vec nzimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  10 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_bits rdc  ::  5 Word.word)) in
      execute (ITYPE (imm,sp,rd,RISCV_ADDI)))))"
|" execute (C_LW (uimm,rsc,rdc)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  7 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_bits rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_bits rsc  ::  5 Word.word)) in
      execute (LOAD (imm,rs,rd,False,WORD,False,False))))))"
|" execute (C_LD (uimm,rsc,rdc)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_bits rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_bits rsc  ::  5 Word.word)) in
      execute (LOAD (imm,rs,rd,False,DOUBLE,False,False))))))"
|" execute (C_SW (uimm,rsc1,rsc2)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  7 Word.word))
          ::  12 Word.word)) in
      (let rs1 = ((creg2reg_bits rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rsc2  ::  5 Word.word)) in
      execute (STORE (imm,rs2,rs1,WORD,False,False))))))"
|" execute (C_SD (uimm,rsc1,rsc2)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      (let rs1 = ((creg2reg_bits rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rsc2  ::  5 Word.word)) in
      execute (STORE (imm,rs2,rs1,DOUBLE,False,False))))))"
|" execute (C_ADDI (nzi,rsd)) = (
      (let (imm :: 12 bits) = ((EXTS (( 12 :: int)::ii) nzi  ::  12 Word.word)) in
      execute (ITYPE (imm,rsd,rsd,RISCV_ADDI))))"
|" execute (C_JAL (imm)) = (
      execute
        (RISCV_JAL ((EXTS (( 21 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word))
                      ::  21 Word.word),ra)))"
|" execute (C_LI (imm,rd)) = (
      (let (imm :: 12 bits) = ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word)) in
      execute (ITYPE (imm,zreg,rd,RISCV_ADDI))))"
|" execute (C_ADDI16SP (imm)) = (
      (let (imm :: 12 bits) =
        ((EXTS (( 12 :: int)::ii) ((concat_vec imm (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)  ::  10 Word.word))
          ::  12 Word.word)) in
      execute (ITYPE (imm,sp,sp,RISCV_ADDI))))"
|" execute (C_LUI (imm,rd)) = (
      (let (res :: 20 bits) = ((EXTS (( 20 :: int)::ii) imm  ::  20 Word.word)) in
      execute (UTYPE (res,rd,RISCV_LUI))))"
|" execute (C_SRLI (shamt,rsd)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SRLI))))"
|" execute (C_SRAI (shamt,rsd)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SRAI))))"
|" execute (C_ANDI (imm,rsd)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      execute (ITYPE ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word),rsd,rsd,RISCV_ANDI))))"
|" execute (C_SUB (rsd,rs2)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_SUB)))))"
|" execute (C_XOR (rsd,rs2)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_XOR)))))"
|" execute (C_OR (rsd,rs2)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_OR)))))"
|" execute (C_AND (rsd,rs2)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2,rsd,rsd,RISCV_AND)))))"
|" execute (C_SUBW (rsd,rs2)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rs2  ::  5 Word.word)) in
      execute (RTYPEW (rs2,rsd,rsd,RISCV_SUBW)))))"
|" execute (C_ADDW (rsd,rs2)) = (
      (let rsd = ((creg2reg_bits rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_bits rs2  ::  5 Word.word)) in
      execute (RTYPEW (rs2,rsd,rsd,RISCV_ADDW)))))"
|" execute (C_J (imm)) = (
      execute
        (RISCV_JAL ((EXTS (( 21 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word))
                      ::  21 Word.word),zreg)))"
|" execute (C_BEQZ (imm,rs)) = (
      execute
        (BTYPE ((EXTS (( 13 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  9 Word.word))
                  ::  13 Word.word),zreg,(creg2reg_bits rs  ::  5 Word.word),RISCV_BEQ)))"
|" execute (C_BNEZ (imm,rs)) = (
      execute
        (BTYPE ((EXTS (( 13 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  9 Word.word))
                  ::  13 Word.word),zreg,(creg2reg_bits rs  ::  5 Word.word),RISCV_BNE)))"
|" execute (C_SLLI (shamt,rsd)) = ( execute (SHIFTIOP (shamt,rsd,rsd,RISCV_SLLI)))"
|" execute (C_LWSP (uimm,rd)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      execute (LOAD (imm,sp,rd,False,WORD,False,False))))"
|" execute (C_LDSP (uimm,rd)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  9 Word.word))
          ::  12 Word.word)) in
      execute (LOAD (imm,sp,rd,False,DOUBLE,False,False))))"
|" execute (C_SWSP (uimm,rs2)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      execute (STORE (imm,rs2,sp,WORD,False,False))))"
|" execute (C_SDSP (uimm,rs2)) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  9 Word.word))
          ::  12 Word.word)) in
      execute (STORE (imm,rs2,sp,DOUBLE,False,False))))"
|" execute (C_JR (rs1)) = (
      execute (RISCV_JALR ((EXTZ (( 12 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word),rs1,zreg)))"
|" execute (C_JALR (rs1)) = (
      execute (RISCV_JALR ((EXTZ (( 12 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word),rs1,ra)))"
|" execute (C_MV (rd,rs2)) = ( execute (RTYPE (rs2,zreg,rd,RISCV_ADD)))"
|" execute (C_ADD (rsd,rs2)) = ( execute (RTYPE (rs2,rsd,rsd,RISCV_ADD)))"
|" execute (UTYPE (imm,rd,op1)) = ( execute_UTYPE imm rd op1 )"
|" execute (RISCV_JAL (imm,rd)) = ( execute_RISCV_JAL imm rd )"
|" execute (RISCV_JALR (imm,rs1,rd)) = ( execute_RISCV_JALR imm rs1 rd )"
|" execute (BTYPE (imm,rs2,rs1,op1)) = ( execute_BTYPE imm rs2 rs1 op1 )"
|" execute (ITYPE (imm,rs1,rd,op1)) = ( execute_ITYPE imm rs1 rd op1 )"
|" execute (SHIFTIOP (shamt,rs1,rd,op1)) = ( execute_SHIFTIOP shamt rs1 rd op1 )"
|" execute (RTYPE (rs2,rs1,rd,op1)) = ( execute_RTYPE rs2 rs1 rd op1 )"
|" execute (LOAD (imm,rs1,rd,is_unsigned,width,aq,rl)) = ( execute_LOAD imm rs1 rd is_unsigned width aq rl )"
|" execute (STORE (imm,rs2,rs1,width,aq,rl)) = ( execute_STORE imm rs2 rs1 width aq rl )"
|" execute (ADDIW (imm,rs1,rd)) = ( execute_ADDIW imm rs1 rd )"
|" execute (SHIFTW (shamt,rs1,rd,op1)) = ( execute_SHIFTW shamt rs1 rd op1 )"
|" execute (RTYPEW (rs2,rs1,rd,op1)) = ( execute_RTYPEW rs2 rs1 rd op1 )"
|" execute (MUL (rs2,rs1,rd,high,signed1,signed2)) = ( execute_MUL rs2 rs1 rd high signed1 signed2 )"
|" execute (DIV (rs2,rs1,rd,s)) = ( execute_DIV rs2 rs1 rd s )"
|" execute (REM (rs2,rs1,rd,s)) = ( execute_REM rs2 rs1 rd s )"
|" execute (MULW (rs2,rs1,rd)) = ( execute_MULW rs2 rs1 rd )"
|" execute (DIVW (rs2,rs1,rd,s)) = ( execute_DIVW rs2 rs1 rd s )"
|" execute (REMW (rs2,rs1,rd,s)) = ( execute_REMW rs2 rs1 rd s )"
|" execute (FENCE (pred,succ)) = ( execute_FENCE pred succ )"
|" execute (FENCEI (g__105)) = ( execute_FENCEI g__105 )"
|" execute (ECALL (g__106)) = ( execute_ECALL g__106 )"
|" execute (MRET (g__107)) = ( execute_MRET g__107 )"
|" execute (SRET (g__108)) = ( execute_SRET g__108 )"
|" execute (EBREAK (g__109)) = ( execute_EBREAK g__109 )"
|" execute (WFI (g__110)) = ( execute_WFI g__110 )"
|" execute (SFENCE_VMA (rs1,rs2)) = ( execute_SFENCE_VMA rs1 rs2 )"
|" execute (LOADRES (aq,rl,rs1,width,rd)) = ( execute_LOADRES aq rl rs1 width rd )"
|" execute (STORECON (aq,rl,rs2,rs1,width,rd)) = ( execute_STORECON aq rl rs2 rs1 width rd )"
|" execute (AMO (op1,aq,rl,rs2,rs1,width,rd)) = ( execute_AMO op1 aq rl rs2 rs1 width rd )"
|" execute (CSR (csr,rs1,rd,is_imm,op1)) = ( execute_CSR csr rs1 rd is_imm op1 )"
|" execute (NOP (g__111)) = ( return ((execute_NOP g__111)))"
|" execute (ILLEGAL (g__112)) = ( execute_ILLEGAL g__112 )"
|" execute (C_ADDIW (imm,rsd)) = ( execute_C_ADDIW imm rsd )" 
by pat_completeness auto


fun print_insn  :: " ast \<Rightarrow> string "  where 
     " print_insn (UTYPE (imm,rd,op1)) = (
      (case  op1 of
        RISCV_LUI =>
         (op@) (''lui   '')
           (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec imm))))))
      | RISCV_AUIPC =>
         (op@) (''auipc '')
           (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec imm))))))
      ))"
|" print_insn (RISCV_JAL (imm,rd)) = (
      (op@) (''jal   '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (RISCV_JALR (imm,rs1,rd)) = (
      (op@) (''jalr  '')
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec imm)))))))))))"
|" print_insn (BTYPE (imm,rs2,rs1,op1)) = (
      (let (insn :: string) =
        ((case  op1 of
          RISCV_BEQ => (''beq   '')
        | RISCV_BNE => (''bne   '')
        | RISCV_BLT => (''blt   '')
        | RISCV_BGE => (''bge   '')
        | RISCV_BLTU => (''bltu  '')
        | RISCV_BGEU => (''bgeu  '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rs1))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs2)) (((op@) ('', '') ((string_of_vec imm))))))))))))"
|" print_insn (ITYPE (imm,rs1,rd,op1)) = (
      (let (insn :: string) =
        ((case  op1 of
          RISCV_ADDI => (''addi  '')
        | RISCV_SLTI => (''slti  '')
        | RISCV_SLTIU => (''sltiu '')
        | RISCV_XORI => (''xori  '')
        | RISCV_ORI => (''ori   '')
        | RISCV_ANDI => (''andi  '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec imm))))))))))))"
|" print_insn (SHIFTIOP (shamt,rs1,rd,op1)) = (
      (let (insn :: string) =
        ((case  op1 of   RISCV_SLLI => (''slli  '') | RISCV_SRLI => (''srli  '') | RISCV_SRAI => (''srai  '') )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec shamt))))))))))))"
|" print_insn (RTYPE (rs2,rs1,rd,op1)) = (
      (let (insn :: string) =
        ((case  op1 of
          RISCV_ADD => (''add   '')
        | RISCV_SUB => (''sub   '')
        | RISCV_SLL => (''sll   '')
        | RISCV_SLT => (''slt   '')
        | RISCV_SLTU => (''sltu  '')
        | RISCV_XOR => (''xor   '')
        | RISCV_SRL => (''srl   '')
        | RISCV_SRA => (''sra   '')
        | RISCV_OR => (''or    '')
        | RISCV_AND => (''and   '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (LOAD (imm,rs1,rd,is_unsigned,width,aq,rl)) = (
      (let (insn :: string) =
        ((case  (width, is_unsigned) of
          (BYTE, False) => (''lb    '')
        | (BYTE, True) => (''lbu   '')
        | (HALF, False) => (''lh    '')
        | (HALF, True) => (''lhu   '')
        | (WORD, False) => (''lw    '')
        | (WORD, True) => (''lwu   '')
        | (DOUBLE, False) => (''ld    '')
        | (DOUBLE, True) => (''ldu   '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec imm))))))))))))"
|" print_insn (STORE (imm,rs2,rs1,width,aq,rl)) = (
      (let (insn :: string) =
        ((case  width of
          BYTE => (''sb    '')
        | HALF => (''sh    '')
        | WORD => (''sw    '')
        | DOUBLE => (''sd    '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rs2))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec imm))))))))))))"
|" print_insn (ADDIW (imm,rs1,rd)) = (
      (op@) (''addiw '')
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec imm)))))))))))"
|" print_insn (SHIFTW (shamt,rs1,rd,op1)) = (
      (let (insn :: string) =
        ((case  op1 of   RISCV_SLLI => (''slli  '') | RISCV_SRLI => (''srli  '') | RISCV_SRAI => (''srai  '') )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((string_of_vec shamt))))))))))))"
|" print_insn (RTYPEW (rs2,rs1,rd,op1)) = (
      (let (insn :: string) =
        ((case  op1 of
          RISCV_ADDW => (''addw  '')
        | RISCV_SUBW => (''subw  '')
        | RISCV_SLLW => (''sllw  '')
        | RISCV_SRLW => (''srlw  '')
        | RISCV_SRAW => (''sraw  '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (MUL (rs2,rs1,rd,high,signed1,signed2)) = (
      (let (insn :: string) =
        ((case  (high, signed1, signed2) of
          (False, True, True) => (''mul   '')
        | (True, True, True) => (''mulh  '')
        | (True, True, False) => (''mulhsu '')
        | (True, False, False) => (''mulhu'')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (DIV (rs2,rs1,rd,s)) = (
      (let (insn :: string) = (if s then (''div   '') else (''divu  '')) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (REM (rs2,rs1,rd,s)) = (
      (let (insn :: string) = (if s then (''rem   '') else (''remu  '')) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (MULW (rs2,rs1,rd)) = (
      (op@) (''mulw  '')
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2)))))))))))"
|" print_insn (DIVW (rs2,rs1,rd,s)) = (
      (let (insn :: string) = (if s then (''divw  '') else (''divuw '')) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (REMW (rs2,rs1,rd,s)) = (
      (let (insn :: string) = (if s then (''remw  '') else (''remuw '')) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (FENCE (pred,succ)) = ( (''fence''))"
|" print_insn (FENCEI (g__93)) = ( (''fence.i''))"
|" print_insn (ECALL (g__94)) = ( (''ecall''))"
|" print_insn (MRET (g__95)) = ( (''mret''))"
|" print_insn (SRET (g__96)) = ( (''sret''))"
|" print_insn (EBREAK (g__97)) = ( (''ebreak''))"
|" print_insn (WFI (g__98)) = ( (''wfi''))"
|" print_insn (SFENCE_VMA (rs1,rs2)) = (
      (op@) (''sfence.vma '')
        (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2)))))))"
|" print_insn (LOADRES (aq,rl,rs1,width,rd)) = (
      (let (insn :: string) =
        ((case  width of   WORD => (''lr.w  '') | DOUBLE => (''lr.d  '') | _ => (''lr.bad '') )) in
      (op@) insn
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((reg_name_abi rs1))))))))"
|" print_insn (STORECON (aq,rl,rs2,rs1,width,rd)) = (
      (let (insn :: string) =
        ((case  width of   WORD => (''sc.w  '') | DOUBLE => (''sc.d  '') | _ => (''sc.bad '') )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (AMO (op1,aq,rl,rs2,rs1,width,rd)) = (
      (let (insn :: string) =
        ((case  (op1, width) of
          (AMOSWAP, WORD) => (''amoswap.w '')
        | (AMOADD, WORD) => (''amoadd.w  '')
        | (AMOXOR, WORD) => (''amoxor.w  '')
        | (AMOAND, WORD) => (''amoand.w  '')
        | (AMOOR, WORD) => (''amoor.w   '')
        | (AMOMIN, WORD) => (''amomin.w  '')
        | (AMOMAX, WORD) => (''amomax.w  '')
        | (AMOMINU, WORD) => (''amominu.w '')
        | (AMOMAXU, WORD) => (''amomaxu.w '')
        | (AMOSWAP, DOUBLE) => (''amoswap.d '')
        | (AMOADD, DOUBLE) => (''amoadd.d  '')
        | (AMOXOR, DOUBLE) => (''amoxor.d  '')
        | (AMOAND, DOUBLE) => (''amoand.d  '')
        | (AMOOR, DOUBLE) => (''amoor.d   '')
        | (AMOMIN, DOUBLE) => (''amomin.d  '')
        | (AMOMAX, DOUBLE) => (''amomax.d  '')
        | (AMOMINU, DOUBLE) => (''amominu.d '')
        | (AMOMAXU, DOUBLE) => (''amomaxu.d '')
        | (_, _) => (''amo.bad '')
        )) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '')
                (((op@) ((reg_name_abi rs1)) (((op@) ('', '') ((reg_name_abi rs2))))))))))))"
|" print_insn (CSR (csr,rs1,rd,is_imm,op1)) = (
      (let (insn :: string) =
        ((case  (op1, is_imm) of
          (CSRRW, True) => (''csrrwi '')
        | (CSRRW, False) => (''csrrw  '')
        | (CSRRS, True) => (''csrrsi '')
        | (CSRRS, False) => (''csrrs  '')
        | (CSRRC, True) => (''csrrci '')
        | (CSRRC, False) => (''csrrc  '')
        )) in
      (let (rs1_str :: string) = (if is_imm then string_of_vec rs1 else reg_name_abi rs1) in
      (op@) insn
        (((op@) ((reg_name_abi rd))
            (((op@) ('', '') (((op@) rs1_str (((op@) ('', '') ((csr_name csr)))))))))))))"
|" print_insn (NOP (g__99)) = ( (''nop''))"
|" print_insn (ILLEGAL (g__100)) = ( (''illegal''))"
|" print_insn (C_ADDI4SPN (rdc,nzimm)) = (
      (op@) (''c.addi4spn '')
        (((op@) ((reg_name_abi ((creg2reg_bits rdc  ::  5 Word.word))))
            (((op@) ('', '') ((string_of_vec nzimm)))))))"
|" print_insn (C_LW (uimm,rsc,rdc)) = (
      (op@) (''c.lw   '')
        (((op@) ((reg_name_abi ((creg2reg_bits rdc  ::  5 Word.word))))
            (((op@) ('', '')
                (((op@) ((reg_name_abi ((creg2reg_bits rsc  ::  5 Word.word))))
                    (((op@) ('', '') ((string_of_vec uimm)))))))))))"
|" print_insn (C_LD (uimm,rsc,rdc)) = (
      (op@) (''c.ld   '')
        (((op@) ((reg_name_abi ((creg2reg_bits rdc  ::  5 Word.word))))
            (((op@) ('', '')
                (((op@) ((reg_name_abi ((creg2reg_bits rsc  ::  5 Word.word))))
                    (((op@) ('', '') ((string_of_vec uimm)))))))))))"
|" print_insn (C_SW (uimm,rsc1,rsc2)) = (
      (op@) (''c.sw   '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsc1  ::  5 Word.word))))
            (((op@) ('', '')
                (((op@) ((reg_name_abi ((creg2reg_bits rsc2  ::  5 Word.word))))
                    (((op@) ('', '') ((string_of_vec uimm)))))))))))"
|" print_insn (C_SD (uimm,rsc1,rsc2)) = (
      (op@) (''c.sd   '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsc1  ::  5 Word.word))))
            (((op@) ('', '')
                (((op@) ((reg_name_abi ((creg2reg_bits rsc2  ::  5 Word.word))))
                    (((op@) ('', '') ((string_of_vec uimm)))))))))))"
|" print_insn (C_ADDI (nzi,rsd)) = (
      (op@) (''c.addi   '')
        (((op@) ((reg_name_abi rsd)) (((op@) ('', '') ((string_of_vec nzi)))))))"
|" print_insn (C_JAL (imm)) = ( (op@) (''c.jal   '') ((string_of_vec imm)))"
|" print_insn (C_ADDIW (imm,rsd)) = (
      (op@) (''c.addiw '')
        (((op@) ((reg_name_abi rsd)) (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (C_LI (imm,rd)) = (
      (op@) (''c.li  '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (C_ADDI16SP (imm)) = ( (op@) (''c.addi16sp  '') ((string_of_vec imm)))"
|" print_insn (C_LUI (imm,rd)) = (
      (op@) (''c.lui  '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (C_SRLI (shamt,rsd)) = (
      (op@) (''c.srli  '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((string_of_vec shamt)))))))"
|" print_insn (C_SRAI (shamt,rsd)) = (
      (op@) (''c.srai  '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((string_of_vec shamt)))))))"
|" print_insn (C_ANDI (imm,rsd)) = (
      (op@) (''c.andi  '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (C_SUB (rsd,rs2)) = (
      (op@) (''c.sub  '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((reg_name_abi ((creg2reg_bits rs2  ::  5 Word.word)))))))))"
|" print_insn (C_XOR (rsd,rs2)) = (
      (op@) (''c.xor  '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((reg_name_abi ((creg2reg_bits rs2  ::  5 Word.word)))))))))"
|" print_insn (C_OR (rsd,rs2)) = (
      (op@) (''c.or   '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((reg_name_abi ((creg2reg_bits rs2  ::  5 Word.word)))))))))"
|" print_insn (C_AND (rsd,rs2)) = (
      (op@) (''c.and  '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((reg_name_abi ((creg2reg_bits rs2  ::  5 Word.word)))))))))"
|" print_insn (C_SUBW (rsd,rs2)) = (
      (op@) (''c.subw '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((reg_name_abi ((creg2reg_bits rs2  ::  5 Word.word)))))))))"
|" print_insn (C_ADDW (rsd,rs2)) = (
      (op@) (''c.addw '')
        (((op@) ((reg_name_abi ((creg2reg_bits rsd  ::  5 Word.word))))
            (((op@) ('', '') ((reg_name_abi ((creg2reg_bits rs2  ::  5 Word.word)))))))))"
|" print_insn (C_J (imm)) = ( (op@) (''c.j    '') ((string_of_vec imm)))"
|" print_insn (C_BEQZ (imm,rs)) = (
      (op@) (''c.beqz '')
        (((op@) ((reg_name_abi ((creg2reg_bits rs  ::  5 Word.word))))
            (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (C_BNEZ (imm,rs)) = (
      (op@) (''c.bnez '')
        (((op@) ((reg_name_abi ((creg2reg_bits rs  ::  5 Word.word))))
            (((op@) ('', '') ((string_of_vec imm)))))))"
|" print_insn (C_SLLI (shamt,rsd)) = (
      (op@) (''c.slli '')
        (((op@) ((reg_name_abi rsd)) (((op@) ('', '') ((string_of_vec shamt)))))))"
|" print_insn (C_LWSP (uimm,rd)) = (
      (op@) (''c.lwsp '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec uimm)))))))"
|" print_insn (C_LDSP (uimm,rd)) = (
      (op@) (''c.ldsp '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec uimm)))))))"
|" print_insn (C_SWSP (uimm,rd)) = (
      (op@) (''c.swsp '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec uimm)))))))"
|" print_insn (C_SDSP (uimm,rd)) = (
      (op@) (''c.sdsp '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((string_of_vec uimm)))))))"
|" print_insn (C_JR (rs1)) = ( (op@) (''c.jr  '') ((reg_name_abi rs1)))"
|" print_insn (C_JALR (rs1)) = ( (op@) (''c.jalr  '') ((reg_name_abi rs1)))"
|" print_insn (C_MV (rd,rs2)) = (
      (op@) (''c.mv  '')
        (((op@) ((reg_name_abi rd)) (((op@) ('', '') ((reg_name_abi rs2)))))))"
|" print_insn (C_ADD (rsd,rs2)) = (
      (op@) (''c.add  '')
        (((op@) ((reg_name_abi rsd)) (((op@) ('', '') ((reg_name_abi rs2)))))))"


(*val isRVC : mword ty16 -> bool*)

definition isRVC  :: "(16)Word.word \<Rightarrow> bool "  where 
     " isRVC h = (
   \<not> (((((subrange_vec_dec h (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))"


(*val fetch : unit -> M FetchResult*)

definition fetch  :: " unit \<Rightarrow>((register_value),(FetchResult),(exception))monad "  where 
     " fetch _ = (
   or_boolM
     ((read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 :: xlenbits) . 
      return (((((cast_unit_vec0 ((access_vec_dec w__0 (( 0 :: int)::ii)))  ::  1 Word.word)) \<noteq> (vec_of_bits [B0]  ::  1 Word.word))))))
     (and_boolM
        ((read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 :: xlenbits) . 
         return (((((cast_unit_vec0 ((access_vec_dec w__1 (( 1 :: int)::ii)))  ::  1 Word.word)) \<noteq> (vec_of_bits [B0]  ::  1 Word.word))))))
        (haveRVC ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> (\<lambda> (w__4 :: bool) . 
   if w__4 then
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
     return (F_Error (E_Fetch_Addr_Align,w__5)))
   else
     (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
     translateAddr w__6 Execute Instruction \<bind> (\<lambda> (w__7 :: TR_Result) . 
     (case  w__7 of
       TR_Failure (e) =>
        (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 ::  64 Word.word) .  return (F_Error (e,w__8)))
     | TR_Address (ppclo) =>
        (checked_mem_read Instruction ppclo (( 2 :: int)::ii)  :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__9 :: ( 16 Word.word)
          MemoryOpResult) . 
        (case  w__9 of
          MemException (e) =>
           (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 ::  64 Word.word) . 
           return (F_Error (E_Fetch_Access_Fault,w__10)))
        | MemValue (ilo) =>
           if ((isRVC ilo)) then return (F_RVC ilo)
           else
             (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 ::  64 Word.word) . 
             (let (PChi :: xlenbits) = ((add_vec_int w__11 (( 2 :: int)::ii)  ::  64 Word.word)) in
             translateAddr PChi Execute Instruction \<bind> (\<lambda> (w__12 :: TR_Result) . 
             (case  w__12 of
               TR_Failure (e) => return (F_Error (e,PChi))
             | TR_Address (ppchi) =>
                (checked_mem_read Instruction ppchi (( 2 :: int)::ii)  :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__13 :: ( 16 Word.word)
                  MemoryOpResult) . 
                return ((case  w__13 of
                  MemException (e) => F_Error (E_Fetch_Access_Fault,PChi)
                | MemValue (ihi) => F_Base ((concat_vec ihi ilo  ::  32 Word.word))
                )))
             ))))
        ))
     )))))"


(*val step : unit -> M bool*)

definition step  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " step _ = (
   read_reg mip_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
   read_reg mie_ref \<bind> (\<lambda> (w__1 :: Minterrupts) . 
   read_reg mideleg_ref \<bind> (\<lambda> (w__2 :: Minterrupts) . 
   curInterrupt w__0 w__1 w__2 \<bind> (\<lambda> (w__3 ::  ((InterruptType * Privilege))option) . 
   (case  w__3 of
     Some (intr,priv) =>
      (let (_ :: unit) = (print_bits (''Handling interrupt: '') ((interruptType_to_bits intr  ::  4 Word.word))) in
      handle_interrupt intr priv \<then> return False)
   | None =>
      fetch ()  \<bind> (\<lambda> (w__4 :: FetchResult) . 
      (case  w__4 of
        F_Error (e,addr) => handle_mem_exception addr e \<then> return False
      | F_RVC (h) =>
         (case  ((decodeCompressed h)) of
           None =>
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__5 :: xlenbits) . 
            (let (_ :: unit) =
              (prerr_endline
                (((op@) (''PC: '')
                    (((op@) ((string_of_vec w__5))
                        (((op@) ('' instr: '')
                            (((op@) ((string_of_vec h)) ('' :  <no-decode>'')))))))))) in
            handle_decode_exception ((EXTZ (( 64 :: int)::ii) h  ::  64 Word.word)) \<then> return False))
         | Some (ast) =>
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 :: xlenbits) . 
            (let (_ :: unit) =
              (prerr_endline
                (((op@) (''PC: '')
                    (((op@) ((string_of_vec w__6))
                        (((op@) ('' instr: '')
                            (((op@) ((string_of_vec h))
                                (((op@) ('' :  '') ((print_insn ast))))))))))))) in
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
            (write_reg nextPC_ref ((add_vec_int w__7 (( 2 :: int)::ii)  ::  64 Word.word)) \<then>
            execute ast) \<then> return True)))
         )
      | F_Base (w) =>
         (case  ((decode w)) of
           None =>
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__9 :: xlenbits) . 
            (let (_ :: unit) =
              (prerr_endline
                (((op@) (''PC: '')
                    (((op@) ((string_of_vec w__9))
                        (((op@) ('' instr: '')
                            (((op@) ((string_of_vec w)) ('' :  <no-decode>'')))))))))) in
            handle_decode_exception ((EXTZ (( 64 :: int)::ii) w  ::  64 Word.word)) \<then> return False))
         | Some (ast) =>
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 :: xlenbits) . 
            (let (_ :: unit) =
              (prerr_endline
                (((op@) (''PC: '')
                    (((op@) ((string_of_vec w__10))
                        (((op@) ('' instr: '')
                            (((op@) ((string_of_vec w))
                                (((op@) ('' :  '') ((print_insn ast))))))))))))) in
            (read_reg PC_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__11 ::  64 Word.word) . 
            (write_reg nextPC_ref ((add_vec_int w__11 (( 4 :: int)::ii)  ::  64 Word.word)) \<then>
            execute ast) \<then> return True)))
         )
      ))
   ))))))"


definition initial_regstate  :: " regstate "  where 
     " initial_regstate = (
  (| tlb39 = None, 
     tselect =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     stval =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     scause =
       (Mk_Mcause (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                    ::  64 Word.word)), 
     sepc =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     sscratch =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     stvec =
       (Mk_Mtvec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                               B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                               B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                   ::  64 Word.word)), 
     satp =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     sideleg =
       (Mk_Sinterrupts (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0]
                         ::  64 Word.word)), 
     sedeleg =
       (Mk_Sedeleg (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  64 Word.word)), 
     pmpcfg0 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     pmpaddr0 =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mhartid =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     marchid =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mimpid =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mvendorid =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     minstret =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mtime =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mcycle =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mscratch =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mtval =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mepc =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     mcause =
       (Mk_Mcause (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                    ::  64 Word.word)), 
     mtvec =
       (Mk_Mtvec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                               B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                               B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                   ::  64 Word.word)), 
     medeleg =
       (Mk_Medeleg (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  64 Word.word)), 
     mideleg =
       (Mk_Minterrupts (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0]
                         ::  64 Word.word)), 
     mie =
       (Mk_Minterrupts (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0]
                         ::  64 Word.word)), 
     mip =
       (Mk_Minterrupts (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0]
                         ::  64 Word.word)), 
     mstatus =
       (Mk_Mstatus (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                 B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                     ::  64 Word.word)), 
     misa =
       (Mk_Misa (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                              B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                              B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
                  ::  64 Word.word)), 
     cur_inst =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     cur_privilege = User, 
     Xs =
       ([(vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word),
         (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                       B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
           ::  64 Word.word)]), 
     nextPC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)), 
     PC =
       ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                     B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]
         ::  64 Word.word)) |) )"



end
