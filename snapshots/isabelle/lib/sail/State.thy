chapter \<open>Generated by Lem from ../../src/gen_lib/state.lem.\<close>

theory "State" 

imports 
 	 Main
	 "Lem_pervasives_extra" 
	 "Sail_values" 
	 "Prompt_monad" 
	 "Prompt" 
	 "State_monad" 
	 "State_monad_lemmas" 

begin 

(*open import Pervasives_extra*)
(*open import Sail_impl_base*)
(*open import Sail_values*)
(*open import Prompt_monad*)
(*open import Prompt*)
(*open import State_monad*)
(*open import {isabelle} `State_monad_lemmas`*)

(* State monad wrapper around prompt monad *)

(*val liftState : forall 'regval 'regs 'a 'e. register_accessors 'regs 'regval -> monad 'regval 'a 'e -> monadS 'regs 'a 'e*)
function (sequential,domintros)  liftState  :: "(string \<Rightarrow> 'regs \<Rightarrow> 'regval option)*(string \<Rightarrow> 'regval \<Rightarrow> 'regs \<Rightarrow> 'regs option)\<Rightarrow>('regval,'a,'e)monad \<Rightarrow> 'regs sequential_state \<Rightarrow>(('a,'e)result*'regs sequential_state)set "  where 
     " liftState ra (Done a) = ( returnS a )"
|" liftState ra (Read_mem rk a sz k) = ( bindS (read_mem_bytesS 
  (instance_Sail_values_Bitvector_list_dict
     instance_Sail_values_BitU_Sail_values_bitU_dict) rk a sz) (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Read_tag t k) = ( bindS (read_tagS 
  (instance_Sail_values_Bitvector_list_dict
     instance_Sail_values_BitU_Sail_values_bitU_dict) t)             (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Write_memv a k) = ( bindS (write_mem_bytesS a)      (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Write_tag a t k) = ( bindS (write_tagS 
  (instance_Sail_values_Bitvector_list_dict
     instance_Sail_values_BitU_Sail_values_bitU_dict) a t)          (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Read_reg r k) = ( bindS (read_regvalS ra r)       (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Excl_res k) = ( bindS (excl_resultS () )         (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Undefined k) = ( bindS (undefined_boolS () )      (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Write_ea wk a sz k) = ( seqS (write_mem_eaS 
  (instance_Sail_values_Bitvector_list_dict
     instance_Sail_values_BitU_Sail_values_bitU_dict) wk a sz)    (liftState ra k))"
|" liftState ra (Write_reg r v k) = ( seqS (write_regvalS ra r v)     (liftState ra k))"
|" liftState ra (Footprint k) = ( liftState ra k )"
|" liftState ra (Barrier _ k) = ( liftState ra k )"
|" liftState ra (Print _ k) = ( liftState ra k )"
|" liftState ra (Fail descr) = ( failS descr )"
|" liftState ra (Exception e) = ( throwS e )" 
by pat_completeness auto



(*val iterS_aux : forall 'rv 'a 'e. integer -> (integer -> 'a -> monadS 'rv unit 'e) -> list 'a -> monadS 'rv unit 'e*)
fun  iterS_aux  :: " int \<Rightarrow>(int \<Rightarrow> 'a \<Rightarrow> 'rv sequential_state \<Rightarrow>(((unit),'e)result*'rv sequential_state)set)\<Rightarrow> 'a list \<Rightarrow>('rv,(unit),'e)monadS "  where 
     " iterS_aux i f (x # xs) = ( seqS (f i x) (iterS_aux (i +( 1 :: int)) f xs))"
|" iterS_aux i f ([]) = ( returnS ()  )"


(*val iteriS : forall 'rv 'a 'e. (integer -> 'a -> monadS 'rv unit 'e) -> list 'a -> monadS 'rv unit 'e*)
definition iteriS  :: "(int \<Rightarrow> 'a \<Rightarrow>('rv,(unit),'e)monadS)\<Rightarrow> 'a list \<Rightarrow> 'rv sequential_state \<Rightarrow>(((unit),'e)result*'rv sequential_state)set "  where 
     " iteriS f xs = ( iterS_aux(( 0 :: int)) f xs )"


(*val iterS : forall 'rv 'a 'e. ('a -> monadS 'rv unit 'e) -> list 'a -> monadS 'rv unit 'e*)
definition iterS  :: "('a \<Rightarrow> 'rv sequential_state \<Rightarrow>(((unit),'e)result*'rv sequential_state)set)\<Rightarrow> 'a list \<Rightarrow> 'rv sequential_state \<Rightarrow>(((unit),'e)result*'rv sequential_state)set "  where 
     " iterS f xs = ( iteriS ( \<lambda>x .  
  (case  x of _ => \<lambda> x .  f x )) xs )"


(*val foreachS : forall 'a 'rv 'vars 'e.
  list 'a -> 'vars -> ('a -> 'vars -> monadS 'rv 'vars 'e) -> monadS 'rv 'vars 'e*)
fun  foreachS  :: " 'a list \<Rightarrow> 'vars \<Rightarrow>('a \<Rightarrow> 'vars \<Rightarrow> 'rv sequential_state \<Rightarrow>(('vars,'e)result*'rv sequential_state)set)\<Rightarrow> 'rv sequential_state \<Rightarrow>(('vars,'e)result*'rv sequential_state)set "  where 
     " foreachS ([]) vars body = ( returnS vars )"
|" foreachS (x # xs) vars body = ( bindS
     (body x vars) (\<lambda> vars . 
     foreachS xs vars body))"



(*val whileS : forall 'rv 'vars 'e. 'vars -> ('vars -> monadS 'rv bool 'e) ->
                ('vars -> monadS 'rv 'vars 'e) -> monadS 'rv 'vars 'e*)
function (sequential,domintros)  whileS  :: " 'vars \<Rightarrow>('vars \<Rightarrow> 'rv sequential_state \<Rightarrow>(((bool),'e)result*'rv sequential_state)set)\<Rightarrow>('vars \<Rightarrow> 'rv sequential_state \<Rightarrow>(('vars,'e)result*'rv sequential_state)set)\<Rightarrow> 'rv sequential_state \<Rightarrow>(('vars,'e)result*'rv sequential_state)set "  where 
     " whileS vars cond body s = (
  ( bindS(cond vars) (\<lambda> cond_val s' . 
  if cond_val then
    ( bindS(body vars) (\<lambda> vars s'' .  whileS vars cond body s'')) s'
  else returnS vars s')) s )" 
by pat_completeness auto


(*val untilS : forall 'rv 'vars 'e. 'vars -> ('vars -> monadS 'rv bool 'e) ->
                ('vars -> monadS 'rv 'vars 'e) -> monadS 'rv 'vars 'e*)
function (sequential,domintros)  untilS  :: " 'vars \<Rightarrow>('vars \<Rightarrow> 'rv sequential_state \<Rightarrow>(((bool),'e)result*'rv sequential_state)set)\<Rightarrow>('vars \<Rightarrow> 'rv sequential_state \<Rightarrow>(('vars,'e)result*'rv sequential_state)set)\<Rightarrow> 'rv sequential_state \<Rightarrow>(('vars,'e)result*'rv sequential_state)set "  where 
     " untilS vars cond body s = (
  ( bindS(body vars) (\<lambda> vars s' . 
  ( bindS(cond vars) (\<lambda> cond_val s'' . 
  if cond_val then returnS vars s'' else untilS vars cond body s'')) s')) s )" 
by pat_completeness auto

end
