open import Pervasives_extra
open import Sail_impl_base
open import Sail_values

(* 'a is result type *)
type State 's 'a = 's -> (either 'a string * 's)

type memstate = map integer memory_byte
type regstate = map string (vector bitU)

type state = <| regstate : regstate;
                memstate : memstate; 
                write_ea : integer * integer |>

type M 'a = State state 'a
                     
val return : forall 's 'a. 'a -> State 's 'a
let return a s = (Left a,s)

val (>>=) : forall 's 'a 'b. State 's 'a -> ('a -> State 's 'b) -> State 's 'b
let (>>=) m f s = match m s with
  | (Left a,s') -> f a s'
  | (Right error,s') -> (Right error,s')
  end

val (>>): forall 's 'b. State 's unit -> State 's 'b -> State 's 'b
let (>>) m n = m >>= fun _ -> n

val exit : forall 's 'e 'a. 'e -> State 's 'a
let exit _ s = (Right "exit",s)


val range : integer -> integer -> list integer
let rec range i j = 
  if i = j then [i]
  else i :: range (i+1) j

val read_mem : end_flag -> bool -> read_kind -> vector bitU -> integer -> M (vector bitU)
let read_mem endian dir _ addr sz state =
  let addr = integer_of_address (address_of_bitv addr) in
  let addrs = range addr (addr+sz-1) in
  let memory_value = List.map (fun addr -> Map_extra.find addr state.memstate) addrs in
  let value = intern_mem_value endian dir memory_value in
  (Left value,state)

val write_mem_ea : write_kind -> vector bitU -> integer -> M unit
let write_mem_ea _ addr sz state = 
  let addr = integer_of_address (address_of_bitv addr) in
  let sz = sz in
  (Left (), <| state with write_ea = (addr,sz) |>)

val write_mem_val : end_flag -> vector bitU -> M bool
let write_mem_val endian v state =
  let (addr,sz) = state.write_ea in
  let addrs = range addr (addr+sz-1) in
  let v = extern_mem_value endian v in
  let addresses_with_value = List.zip addrs v in
  let mem = List.foldl (fun mem (addr,v) -> Map.insert addr v mem)
                       state.memstate addresses_with_value in
  (Left true,<| state with memstate = mem |>)

val read_reg : register -> M (vector bitU)
let read_reg reg state =
  let v = Map_extra.find (name_of_reg reg) state.regstate in
  (Left v,state)
let read_reg_range reg i j =
  read_reg reg >>= fun rv ->
  return (slice rv i j)
let read_reg_bit reg i =
  read_reg_range reg i i >>= fun v ->
  return (extract_only_bit v)
let read_reg_field reg regfield =
  let (i,j) = register_field_indices reg regfield in
  read_reg_range reg i j
let read_reg_bitfield reg regfield =
  let (i,_) = register_field_indices reg regfield in
  read_reg_bit reg i 

val write_reg : register -> vector bitU -> M unit
let write_reg reg v state =
  (Left (),<| state with regstate = Map.insert (name_of_reg reg) v state.regstate |>)
let write_reg_range reg i j v =
  read_reg reg >>= fun current_value ->
  let new_value = update current_value i j v in
  write_reg reg new_value
let write_reg_bit reg i bit =
  write_reg_range reg i i (Vector [bit] i (is_inc_of_reg reg))
let write_reg_field reg regfield =
  let (i,j) = register_field_indices reg regfield in  
  write_reg_range reg i j
let write_reg_bitfield reg regfield =
  let (i,_) = register_field_indices reg regfield in  
  write_reg_bit reg i
let write_reg_field_range reg regfield i j v =
  read_reg_field reg regfield >>= fun current_field_value ->
  let new_field_value = update current_field_value i j v in
  write_reg_field reg regfield new_field_value


val barrier : barrier_kind -> M unit
let barrier _ = return ()

val footprint : M unit
let footprint = return ()


val foreachM_inc : forall 'vars. (integer * integer * integer) -> 'vars ->
                  (integer -> 'vars -> M 'vars) -> M 'vars
let rec foreachM_inc (i,stop,by) vars body =
  if i <= stop
  then
    body i vars >>= fun vars ->
    foreachM_inc (i + by,stop,by) vars body
  else return vars


val foreachM_dec : forall 'vars. (integer * integer * integer) -> 'vars ->
                  (integer -> 'vars -> M 'vars) -> M 'vars
let rec foreachM_dec (i,stop,by) vars body =
  if i >= stop
  then
    body i vars >>= fun vars ->
    foreachM_dec (i - by,stop,by) vars body
  else return vars

let write_two_regs r1 r2 vec =
  let is_inc =
    let is_inc_r1 = is_inc_of_reg r1 in
    let is_inc_r2 = is_inc_of_reg r2 in
    let () = ensure (is_inc_r1 = is_inc_r2)
                    "write_two_regs called with vectors of different direction" in
    is_inc_r1 in

  let (size_r1 : integer) = size_of_reg r1 in
  let (start_vec : integer) = get_start vec in
  let size_vec = length vec in
  let r1_v =
    if is_inc
    then slice vec start_vec (size_r1 - start_vec - 1)
    else slice vec start_vec (start_vec - size_r1 - 1) in
  let r2_v =
    if is_inc
    then slice vec (size_r1 - start_vec) (size_vec - start_vec)
    else slice vec (start_vec - size_r1) (start_vec - size_vec) in
  write_reg r1 r1_v >> write_reg r2 r2_v
