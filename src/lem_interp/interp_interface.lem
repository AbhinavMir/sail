(* PS NOTES FOR KATHY:

pls also change:  

  decode_to_istate
  decode_to_instruction 

to take an opcode as defined above, instead of a value 

and change 

*)


import Interp
open import Interp_ast
open import Pervasives
open import Num

open import Assert_extra

(* maybe isn't a member of type Ord - this should be in the Lem standard library*)
instance forall 'a. Ord 'a => (Ord (maybe 'a))
  let compare = maybeCompare compare
  let (<)  r1 r2 = (maybeCompare compare r1 r2) = LT
  let (<=) r1 r2 = (maybeCompare compare r1 r2) <> GT
  let (>)  r1 r2 = (maybeCompare compare r1 r2) = GT
  let (>=) r1 r2 = (maybeCompare compare r1 r2) <> LT
end

type word8 = nat (* bounded at a byte, for when lem supports it*)

type interpreter_state = Interp.stack (*Deem abstract*)
(* Will come from a .lem file generated by Sail, bound to a 'defs' identifier *)
type specification = Interp_ast.defs Interp.tannot (*Deem abstract*)
type interp_mode = Interp.interp_mode (*Deem abstract*)
val make_mode : bool -> bool -> interp_mode
val tracking_dependencies : interp_mode -> bool

(** basic values *)

type bit =
  | Bitc_zero
  | Bitc_one

type bit_lifted = 
  | Bitl_zero
  | Bitl_one
  | Bitl_undef
  | Bitl_unknown

type direction = 
  | D_increasing
  | D_decreasing

type register_value = <| 
    rv_bits: list bit_lifted (* MSB first, smallest index number *); 
    rv_dir: direction; 
    rv_start: nat ;
    rv_start_internal: nat; 
    (*when dir is increasing, rv_start = rv_start_internal. 
      Otherwise, tells interpreter how to reconstruct a proper decreasing value*)
    |>

type byte_lifted = Byte_lifted of list bit_lifted (* of length 8 *)

type instruction_field_value = list bit

type byte = Byte of list bit (* of length 8 *)  (*MSB first*) 

type address_lifted = Address_lifted of list byte_lifted (* of length 8 for 64bit machines*) * maybe integer

type memory_byte = byte_lifted

type memory_value = list memory_byte (* the head of the list, most-significant first, at the lowest address, of length >=1 *)

(* not sure which of these is more handy yet *)
type address = Address of list byte (* of length 8 *) * integer
(* type address = Address of integer *)

type opcode = Opcode of list byte (* of length 4 *)

(** typeclass instantiations *)

let bitCompare (b1:bit) (b2:bit) =
  match (b1,b2) with
  | (Bitc_zero, Bitc_zero) -> EQ
  | (Bitc_one, Bitc_one) -> EQ
  | (Bitc_zero, _) -> LT
  | (_,_) -> GT
  end

let bit_liftedCompare (bl1:bit_lifted) (bl2:bit_lifted) =
  match (bl1,bl2) with
  | (Bitl_zero, Bitl_zero) -> EQ
  | (Bitl_one, Bitl_one) -> EQ
  | (Bitl_undef,Bitl_undef) -> EQ
  | (Bitl_unknown,Bitl_unknown) -> EQ
  | (Bitl_zero,_) -> LT
  | (Bitl_one, _) -> LT
  | (Bitl_undef, _) -> LT
  | (_,_) -> GT
  end

instance (Ord bit_lifted)
  let compare = bit_liftedCompare
  let (<)  b1 b2 = (bit_liftedCompare b1 b2) = LT
  let (<=) b1 b2 = (bit_liftedCompare b1 b2) <> GT
  let (>)  b1 b2 = (bit_liftedCompare b1 b2) = GT
  let (>=) b1 b2 = (bit_liftedCompare b1 b2) <> LT
 end

instance (Ord byte_lifted)
  let compare = defaultCompare
  let (<) = defaultLess
  let (>) = defaultGreater
  let (<=) = defaultLessEq
  let (>=) = defaultGreaterEq
end

let addressCompare = defaultCompare

instance (Ord register_value)
  let compare = defaultCompare
  let (<) = defaultLess
  let (<=) = defaultLessEq
  let (>) = defaultGreater
  let (>=) = defaultGreaterEq
end

instance (Ord address_lifted)
  let compare = defaultCompare
  let (<) = defaultLess
  let (<=) = defaultLessEq
  let (>) = defaultGreater
  let (>=) = defaultGreaterEq
end

(* Registers *)
type slice = (nat * nat)

type reg_name = 
| Reg of string * nat * nat * direction
(*Name of the register, accessing the entire register, the start and size of this register, and it's direction *)

| Reg_slice of string * nat * direction * slice 
(* Name of the register, accessing from the bit indexed by the first
to the bit indexed by the second integer of the slice, inclusive. For
machineDef* the first is a smaller number or equal to the second, adjusted
to reflect the correct span direction in the interpreter side.  *)

| Reg_field of string * nat * direction * string * slice 
(*Name of the register, start and direction, and name of the field of the register
accessed. The slice specifies where this field is in the register*)

| Reg_f_slice of string * nat * direction * string * slice * slice 
(* The first four components are as in Reg_field; the final slice
specifies a part of the field, indexed w.r.t. the register as a whole *)

let slice_eq (s1l,s1r) (s2l,s2r) = (s1l = s2l) && (s1r = s2r)

let reg_nameEqual r1 r2 = 
  match (r1,r2) with
  | (Reg s1 ns1 d1 l1, Reg s2 ns2 d2 l2) -> s1=s2 && ns1 = ns2 && l1=l2 && d1=d2
  | (Reg_slice s1 ns1 d1 sl1, Reg_slice s2 ns2 d2 sl2) -> s1=s2 && ns1=ns2 && d1=d2 && (slice_eq sl1 sl2)
  | (Reg_field s1 ns1 d1 f1 sl1, Reg_field s2 ns2 d2 f2 sl2) -> s1=s2 && ns1=ns2 && d1=d2 && f1=f2 && (slice_eq sl1 sl2)
  | (Reg_f_slice s1 ns1 d1 f1 sl1 sl1', Reg_f_slice s2 ns2 d2 f2 sl2 sl2') -> 
    s1=s2 && ns1=ns2 && d1=d2 && f1=f2 && (slice_eq sl1 sl2) && (slice_eq sl1' sl2')
  | _ -> false
  end

instance (Ord direction)
  let compare = defaultCompare
  let (<) = defaultLess
  let (<=) = defaultLessEq
  let (>) = defaultGreater
  let (>=) = defaultGreaterEq
end  

instance  (Eq reg_name)
  let (=) = reg_nameEqual
  let (<>) x y = not (reg_nameEqual x y)
end

let reg_nameCompare r1 r2 = 
  match (r1,r2) with
  | (Reg s1 _ _ l1, Reg s2 _ _ l2) -> pairCompare compare compare (s1,l1) (s2,l2)
  | (Reg_slice s1 _ _ sl1, Reg_slice s2 _ _ sl2) -> pairCompare compare compare (s1,sl1) (s2,sl2)
  | (Reg_field s1 _ _ f1 sl1, Reg_field s2 _ _ f2 sl2) -> 
      tripleCompare compare compare compare (s1,f1,sl1) (s2,f2,sl2)
  | (Reg_f_slice s1 _ _ f1 sl1 sl1', Reg_f_slice s2 _ _ f2 sl2 sl2') -> 
      pairCompare compare (tripleCompare compare compare compare) (s1,(f1,sl1,sl1')) (s2,(f2,sl2,sl2'))
  | (Reg _ _ _ _, _)  -> LT
  | (Reg_slice _ _ _ _, _) -> LT
  | (Reg_field _ _ _ _ _, _) -> LT
  | (_, _) -> GT
  end

instance (SetType reg_name)
  let setElemCompare = reg_nameCompare
end

instance (Ord reg_name)
  let compare = reg_nameCompare
  let (<)  r1 r2 = (reg_nameCompare r1 r2) = LT
  let (<=) r1 r2 = (reg_nameCompare r1 r2) <> GT
  let (>)  r1 r2 = (reg_nameCompare r1 r2) = GT
  let (>=) r1 r2 = (reg_nameCompare r1 r2) <> LT
end

let direction_of_reg_name r = match r with
  | Reg _ _ _ d -> d
  | Reg_slice _ _ d _ -> d
  | Reg_field _ _ d _ _ -> d
  | Reg_f_slice _ _ d _ _ _ -> d
 end

let start_of_reg_name r = match r with
  | Reg _ start _ _ -> start
  | Reg_slice _ start _ _ -> start
  | Reg_field _ start _ _ _ -> start
  | Reg_f_slice _ start _ _ _ _ -> start
end

(* Data structures for building up instructions *)

type read_kind =
  (* common reads *)
  Read_plain
  (* Power reads *)
  | Read_reserve
  (* AArch64 reads *)
  | Read_acquire | Read_exclusive | Read_exclusive_acquire | Read_stream

type write_kind =
  (* common writes *)
  Write_plain
  (* Power writes *)
  | Write_conditional
  (* AArch64 writes *)
  | Write_release | Write_exclusive | Write_exclusive_release

type barrier_kind =
  (* Power barriers *)
  Sync | LwSync | Eieio | Isync
  (* AArch64 barriers *)
  | DMB | DMB_ST | DMB_LD | DSB | DSB_ST | DSB_LD | ISB 

(*Map between external functions as preceived from a Sail spec and the actual implementation of the function *)
type external_functions = list (string * (Interp.value -> Interp.value))

(*Maps between the memory functions as preceived from a Sail spec and the values needed for actions in the memory model*)
type barriers = list (string * barrier_kind)
type memory_parameter_transformer = interp_mode -> Interp.value -> (memory_value * nat * maybe (list reg_name))
type memory_read = MR of read_kind * memory_parameter_transformer
type memory_reads  = list (string * memory_read)
type memory_write = MW of write_kind * memory_parameter_transformer * (maybe (instruction_state -> bool -> instruction_state))
and memory_writes = list (string * memory_write)

(* Definition information needed to run an instruction *)
and context = Context of Interp.top_level * direction * memory_reads * memory_writes * barriers * external_functions

(* An instruction in flight *)
and instruction_state = IState of interpreter_state * context


type outcome =
(* Request to read memory, value is location to read followed by registers that location depended on when mode.track_values,
   integer is size to read, followed by registers that were used in computing that size *)
| Read_mem of read_kind * address_lifted * nat * maybe (list reg_name) *  (memory_value -> instruction_state)
(* Request to write memory, first value and dependent registers is location, second is the value to write *)
| Write_mem of write_kind * address_lifted * nat * maybe (list reg_name) * memory_value * maybe (list reg_name) * (bool -> instruction_state)
(* Request a memory barrier *)
| Barrier of barrier_kind * instruction_state
(* Tell the system to dynamically recalculate dependency footprint *)
| Footprint of instruction_state
(* Request to read register, will track dependency when mode.track_values *)
| Read_reg of reg_name * (register_value -> instruction_state) 
(* Request to write register *)
| Write_reg of reg_name * register_value * instruction_state
(* List of instruciton states to be run in parrallel, any order permitted *)
| Nondet_choice of list instruction_state * instruction_state
(* Stop for incremental stepping, function can be used to display function call data *)
| Internal of maybe string * maybe (unit -> string) * instruction_state
(* Escape the current instruction, for traps, some sys calls, interrupts, etc. Can optionally provide a handler *)
| Escape of maybe instruction_state
| Done
| Error of string

type event = 
| E_read_mem of read_kind * address_lifted * nat * maybe (list reg_name)
| E_write_mem of write_kind * address_lifted * nat * maybe (list reg_name) * memory_value * maybe (list reg_name)
| E_barrier of barrier_kind
| E_footprint 
| E_read_reg of reg_name
| E_write_reg of reg_name * register_value
| E_escape
| E_error of string (* Should not happen, but may if the symbolic evaluation doesn't work out*)

(* more explicit type classes to work around the occurrences of big_int in reg_name ::no longer necessary?*)
instance (Ord read_kind)
  let compare = defaultCompare
  let (<) = defaultLess
  let (<=) = defaultLessEq
  let (>) = defaultGreater
  let (>=) = defaultGreaterEq
end
instance (Ord write_kind)
  let compare = defaultCompare
  let (<) = defaultLess
  let (<=) = defaultLessEq
  let (>) = defaultGreater
  let (>=) = defaultGreaterEq
end
instance (Ord barrier_kind)
  let compare = defaultCompare
  let (<) = defaultLess
  let (<=) = defaultLessEq
  let (>) = defaultGreater
  let (>=) = defaultGreaterEq
end

let eventCompare e1 e2 = 
  match (e1,e2) with
  | (E_read_mem rk1 v1 i1 tr1, E_read_mem rk2 v2 i2 tr2) -> compare (rk1, (v1,i1,tr1)) (rk2,(v2, i2, tr2)) 
  | (E_write_mem wk1 v1 i1 tr1 v1' tr1', E_write_mem wk2 v2 i2 tr2 v2' tr2') -> 
    compare ((wk1,v1,i1),(tr1,v1',tr1'))  ((wk2,v2,i2),(tr2,v2',tr2')) 
  | (E_barrier bk1, E_barrier bk2) -> compare bk1 bk2
  | (E_read_reg r1, E_read_reg r2) -> compare r1 r2
  | (E_write_reg r1 v1, E_write_reg r2 v2) -> compare (r1,v1) (r2,v2)
  | (E_error s1, E_error s2) -> compare s1 s2
  | (E_escape,E_escape) -> EQ
  | (E_read_mem _ _ _ _, _) -> LT
  | (E_write_mem _ _ _ _ _ _, _) -> LT
  | (E_barrier _, _) -> LT
  | (E_read_reg _, _) -> LT
  | (E_write_reg _ _, _) -> LT
  | _ -> GT
  end



instance (SetType event)
  let setElemCompare = eventCompare
end

(* Functions to build up the initial state for interpretation *)
val build_context : specification -> memory_reads -> memory_writes -> barriers -> external_functions -> context 
val initial_instruction_state : context -> string -> list register_value -> instruction_state 
  (* string is a function name, list of value are the parameters to that function *)

(*Type representint the constructor parameters in instruction, other is a type not representable externally*)
type instr_parm_typ = 
  | Bit (*A single bit, represented as a one element Bitvector as a value*)
  | Range of maybe nat (*Internall represented as a number, externally as a bitvector of length int *)
  | Other (*An unrepresentable type, will be represented as Unknown in instruciton form *)
  | Bvector of maybe nat (* A bitvector type, with length when statically known *)

let instr_parm_typEqual ip1 ip2 = match (ip1,ip2) with
  | (Bit,Bit) -> true
  | (Other,Other) -> true
  | (Range i1,Range i2) -> i1 = i2
  | (Bvector i1,Bvector i2) -> i1 = i2
  | _ -> false
end 

instance (Eq instr_parm_typ) 
  let (=) = instr_parm_typEqual
  let (<>) ip1 ip2 = not (instr_parm_typEqual ip1 ip2)
end 

(*A representation of the AST node for each instruction in the spec, with concrete values from this call,
  and the potential static effects from the funcl clause for this instruction 
  Follows the form of the instruction in instruction_extractor, but populates the parameters with actual values
*)
type instruction = (string * list (string * instr_parm_typ * instruction_field_value) * list base_effect)

let instructionEqual i1 i2 = match (i1,i2) with
  | ((i1,parms1,effects1),(i2,parms2,effects2)) -> i1=i2 && parms1 = parms2 && effects1 = effects2
end

type v_kind = Bitv | Bytev

type decode_error = 
  | Unsupported_instruction_error of instruction
  | Not_an_instruction_error of opcode
  | Internal_error of string

type instruction_or_decode_error =
  | IDE_instr of instruction
  | IDE_decode_error of decode_error

(** propose to remove the following type and use the above instead *)
type i_state_or_error =
  | Instr of instruction * instruction_state
  | Decode_error of decode_error


(** PS:I agree. propose to remove this: Function to decode an instruction and build the state to run it*)
val decode_to_istate : context -> opcode -> i_state_or_error

(** propose to add this, and then use instruction_to_istate on the result: Function to decode an instruction and build the state to run it*)
(** PS made a placeholder in interp_inter_imp.lem, but it just uses decode_to_istate and throws away the istate; surely it's easy to just do what's necessary to get the instruction.   This sort-of works, but it crashes on ioid 10 after 167 steps - maybe instruction_to_istate (which I wasn't using directly before) isn't quite right? *)
val decode_to_instruction : context -> opcode -> instruction_or_decode_error

(*Function to generate the state to run from an instruction form; is always an Instr*)
val instruction_to_istate : context -> instruction -> instruction_state (*i_state_or_error*)

(* Slice a register value into a smaller vector, starting at first number (wrt the indices of the register value, not raw positions in its list of bits) and going to second (inclusive) according to order. *)
val slice_reg_value : register_value -> nat -> nat -> register_value


(* Big step of the interpreter, to the next request for an external action *)
(* When interp_mode has eager_eval false, interpreter is (close to) small step *)
val interp : interp_mode -> instruction_state -> outcome

(* Run the interpreter without external interaction, feeding in Unknown on all reads except for those register values provided *)
val interp_exhaustive : maybe (list (reg_name * register_value)) -> instruction_state -> list event

(* As above, but will request register reads: outcome will only be rreg, done, or error *)
val rr_interp_exhaustive : interp_mode -> instruction_state -> list event -> (outcome * (list event)) 


(** operations and coercions on basic values *)

val word8_to_bitls : word8 -> list bit_lifted
val bitls_to_word8 : list bit_lifted -> word8

val integer_of_word8_list : list word8 -> integer
val word8_list_of_integer : integer -> integer -> list word8 

val concretizable_bitl : bit_lifted -> bool
val concretizable_bytl : byte_lifted -> bool
val concretizable_bytls : list byte_lifted -> bool

let concretizable_bitl = function
  | Bitl_zero -> true
  | Bitl_one -> true
  | Bitl_undef -> false
  | Bitl_unknown -> false
end 

let concretizable_bytl (Byte_lifted bs) = List.all concretizable_bitl bs
let concretizable_bytls = List.all concretizable_bytl

(* constructing values *)

val register_value : bit_lifted -> direction -> nat -> nat -> register_value
let register_value b dir width start_index = 
  <| rv_bits = List.replicate width b;
     rv_dir = dir; (* D_increasing for Power, D_decreasing for ARM *)
     rv_start_internal = start_index; 
     rv_start = if dir = D_increasing 
       then start_index 
       else (start_index+1) - width; (* Smaller index, as in Power, for external interaction *)
  |>

val register_value_zeros : direction -> nat -> nat -> register_value
let register_value_zeros dir width start_index = 
  register_value Bitl_zero dir width start_index

val register_value_ones : direction -> nat -> nat -> register_value
let register_value_ones dir width start_index = 
  register_value Bitl_one dir width start_index

val byte_lifted_unknown : byte_lifted
let byte_lifted_unknown = Byte_lifted (List.replicate 8 Bitl_unknown)

val memory_value_unknown : nat (*the number of bytes*) -> memory_value
let memory_value_unknown (width:nat) : memory_value = 
  List.replicate width byte_lifted_unknown 


(* lengths *)  

val memory_value_length : memory_value -> nat
let memory_value_length (mv:memory_value) = List.length mv


(* aux fns *)

val maybe_all : forall 'a.  list (maybe 'a) -> maybe (list 'a)
let rec maybe_all' xs acc = 
  match xs with
  | [] -> Just (List.reverse acc)
  | Nothing :: _ -> Nothing
  | (Just y)::xs' -> maybe_all' xs' (y::acc)
  end
let maybe_all xs = maybe_all' xs [] 

(** coercions *)

(* bits and bytes *)

let bit_to_bool = function (* TODO: rename bool_of_bit *)
  | Bitc_zero -> false
  | Bitc_one -> true
end


val bit_lifted_of_bit : bit -> bit_lifted
let bit_lifted_of_bit b = 
  match b with
  | Bitc_zero -> Bitl_zero
  | Bitc_one -> Bitl_one
  end

val bit_of_bit_lifted : bit_lifted -> maybe bit
let bit_of_bit_lifted bl =
  match bl with
  | Bitl_zero -> Just Bitc_zero
  | Bitl_one -> Just Bitc_one
  | Bitl_undef -> Nothing
  | Bitl_unknown -> Nothing
  end


val byte_lifted_of_byte : byte -> byte_lifted
let byte_lifted_of_byte (Byte bs) : byte_lifted = Byte_lifted (List.map bit_lifted_of_bit bs)

val byte_of_byte_lifted : byte_lifted -> maybe byte
let byte_of_byte_lifted bl = 
  match bl with
  | Byte_lifted bls -> 
      match maybe_all (List.map bit_of_bit_lifted bls) with
      | Nothing -> Nothing
      | Just bs -> Just (Byte bs)
      end
  end


val bytes_of_bits : list bit -> list byte (*assumes (length bits) mod 8 = 0*)
let rec bytes_of_bits bits = match bits with
  | [] -> []
  | b0::b1::b2::b3::b4::b5::b6::b7::bits -> 
    (Byte [b0;b1;b2;b3;b4;b5;b6;b7])::(bytes_of_bits bits)
end

val byte_lifteds_of_bit_lifteds : list bit_lifted -> list byte_lifted (*assumes (length bits) mod 8 = 0*)
let rec byte_lifteds_of_bit_lifteds bits = match bits with
  | [] -> []
  | b0::b1::b2::b3::b4::b5::b6::b7::bits -> 
    (Byte_lifted [b0;b1;b2;b3;b4;b5;b6;b7])::(byte_lifteds_of_bit_lifteds bits)
end


val byte_of_memory_byte : memory_byte -> maybe byte
let byte_of_memory_byte = byte_of_byte_lifted

val memory_byte_of_byte : byte -> memory_byte
let memory_byte_of_byte = byte_lifted_of_byte




(* to and from integer *)

val integer_of_bit_list : list bit -> integer 
let integer_of_bit_list b =
  integerFromBoolList (false,(List.reverse (List.map bit_to_bool b)))
  (* integerFromBoolList takes a list with LSB first, so we reverse it *)

val bit_list_of_integer : nat -> integer -> list bit 
let bit_list_of_integer len b = 
  List.map (fun b -> if b then Bitc_one else Bitc_zero) 
    (reverse (boolListFrombitSeq len (bitSeqFromInteger Nothing b)))

val integer_of_byte_list : list byte -> integer 
let integer_of_byte_list bytes = integer_of_bit_list (List.concatMap (fun (Byte bs) -> bs) bytes)

val byte_list_of_integer : nat -> integer -> list byte 
let byte_list_of_integer (len:nat) (a:integer):list byte = 
  let bits = bit_list_of_integer (len * 8) a in bytes_of_bits bits


val integer_of_address : address -> integer 
let integer_of_address (a:address):integer = 
  match a with
  | Address bs i -> i 
  end

val address_of_integer : integer -> address 
let address_of_integer (i:integer):address =
  Address (byte_list_of_integer 8 i) i


(* regarding a list of int as a list of bytes in memory, MSB lowest-address first, convert to an integer *)
val integer_address_of_int_list : list int -> integer
let rec integerFromIntListAux (acc: integer) (is: list int) = 
  match is with 
  | [] -> acc
  | (i :: is') -> integerFromIntListAux ((acc * 256) + integerFromInt i) is'
  end
let integer_address_of_int_list (is: list int) =
  integerFromIntListAux 0 is

val address_of_byte_list : list byte -> address 
let address_of_byte_list bs = 
  if List.length bs <> 8 then failwith "address_of_byte_list given list not of length 8" else 
  Address bs (integer_of_byte_list bs)

(* operations on addresses *)

val add_address_nat : address -> nat -> address 
let add_address_nat (a:address) (i:nat) : address = 
  address_of_integer ((integer_of_address a) + (integerFromNat i))

val clear_low_order_bits_of_address : address -> address 
let clear_low_order_bits_of_address a = 
  match a with 
  | Address [b0;b1;b2;b3;b4;b5;b6;b7] i -> 
      match b7 with
      | Byte [bt0;bt1;bt2;bt3;bt4;bt5;bt6;bt7] -> 
          let b7' = Byte [bt0;bt1;bt2;bt3;bt4;bt5;Bitc_zero;Bitc_zero] in
	  let bytes = [b0;b1;b2;b3;b4;b5;b6;b7'] in
          Address bytes (integer_of_byte_list bytes)
        end
  end

val byte_list_of_memory_value : memory_value -> maybe (list byte)
let byte_list_of_memory_value mv = maybe_all (List.map byte_of_memory_byte mv)
    

val integer_of_memory_value : memory_value -> maybe integer 
let integer_of_memory_value (mv:memory_value):maybe integer = 
  match byte_list_of_memory_value mv with
  | Just bs -> Just (integer_of_byte_list bs)
  | Nothing -> Nothing 
  end

val memory_value_of_integer : nat -> integer -> memory_value 
let memory_value_of_integer (len:nat) (i:integer):memory_value =
  List.map (byte_lifted_of_byte) (byte_list_of_integer len i)


val integer_of_register_value : register_value -> maybe integer 
let integer_of_register_value (rv:register_value):maybe integer = 
  match maybe_all (List.map bit_of_bit_lifted rv.rv_bits) with
  | Nothing -> Nothing
  | Just bs -> Just (integer_of_bit_list bs)
  end 
  
val register_value_of_integer : nat -> nat -> direction -> integer -> register_value 
let register_value_of_integer (len:nat) (start:nat) (dir:direction) (i:integer):register_value =
  let bs = bit_list_of_integer len i in
  <| 
  rv_bits = List.map bit_lifted_of_bit bs;
  rv_dir = dir;
  rv_start = start;
  rv_start_internal = if dir = D_increasing then start else start + (List.length bs) - 1
|> 

(* *)

val opcode_of_bytes : byte -> byte -> byte -> byte -> opcode
let opcode_of_bytes b0 b1 b2 b3 : opcode = Opcode [b0;b1;b2;b3]

val register_value_of_address : address -> direction -> register_value   
let register_value_of_address (Address bytes _) dir : register_value = 
  let bits = List.concatMap (fun (Byte bs) -> List.map bit_lifted_of_bit bs) bytes in
   <| rv_bits = bits;
      rv_dir = dir;
      rv_start = 0; 
      rv_start_internal = if dir = D_increasing then 0 else (List.length bits) - 1
   |>


val address_lifted_of_register_value : register_value -> maybe address_lifted
(* returning Nothing iff the register value is not 64 bits wide, but
allowing Bitl_undef and Bitl_unknown *)
let address_lifted_of_register_value (rv:register_value) : maybe address_lifted = 
  if List.length rv.rv_bits <> 64 then Nothing
  else 
    Just (Address_lifted (byte_lifteds_of_bit_lifteds rv.rv_bits)
                         (if List.all concretizable_bitl rv.rv_bits 
			  then let (Just(bits)) = (maybe_all (List.map bit_of_bit_lifted rv.rv_bits)) in
			       Just (integer_of_bit_list bits)
			  else Nothing))

val address_of_address_lifted : address_lifted -> maybe address
(* returning Nothing iff the address contains any Bitl_undef or Bitl_unknown *)
let address_of_address_lifted (al:address_lifted): maybe address =
  match al with
  | Address_lifted bls (Just i)-> 
      match maybe_all ((List.map byte_of_byte_lifted) bls) with
      | Nothing -> Nothing
      | Just bs -> Just (Address bs i)
      end
  | _ -> Nothing
  end

val address_of_register_value : register_value -> maybe address
(* returning Nothing iff the register value is not 64 bits wide, or contains Bitl_undef or Bitl_unknown *)
let address_of_register_value (rv:register_value) : maybe address = 
  match address_lifted_of_register_value rv with
  | Nothing -> Nothing
  | Just al -> 
      match address_of_address_lifted al with
      | Nothing -> Nothing
      | Just a -> Just a
      end
  end

let address_of_memory_value (mv:memory_value) : maybe address = 
  match byte_list_of_memory_value mv with
  | Nothing -> Nothing
  | Just bs -> 
      if List.length bs <> 8 then Nothing else
      Just (address_of_byte_list bs)
  end 

val byte_of_int : int -> byte
let byte_of_int (i:int) : byte = 
  Byte (bit_list_of_integer 8 (integerFromInt i))

val memory_byte_of_int : int -> memory_byte
let memory_byte_of_int (i:int) : memory_byte = 
  memory_byte_of_byte (byte_of_int i)

(*
val int_of_memory_byte : int -> maybe memory_byte
let int_of_memory_byte (mb:memory_byte) : int = 
  failwith "TODO"
*)




val memory_value_of_address_lifted : address_lifted -> memory_value
let memory_value_of_address_lifted (al:address_lifted) =
  match al with
  | Address_lifted bs _ -> bs
  end

val byte_list_of_address : address -> list byte
let byte_list_of_address (a:address) : list byte = 
  match a with
  | Address bs _ -> bs
  end

val byte_list_of_opcode : opcode -> list byte
let byte_list_of_opcode (opc:opcode) : list byte = 
  match opc with
  | Opcode bs -> bs
  end
