import Interp
open import Interp_ast
open import Pervasives
open import Num

type word8 = nat (* bounded at a byte, for when lem supports it*)

(* Abstract types, to be accessed only through this interface *)
type instruction_state = Interp.stack
type context = Interp.top_level
type interp_mode = Interp.interp_mode
val make_mode : bool -> bool -> interp_mode
val tracking_dependencies : interp_mode -> bool

(*Concrete types*)
type read_kind = Read_plain | Read_reserve | Read_acquire
type write_kind = Write_plain | Write_conditional | Write_release
type barrier_kind = Sync | LwSync | Eieio | Isync | DMB | DMB_ST | DMB_LD | DSB | DSB_ST | DSB_LD | ISB (* PS removed "plain" and added "Isync" and "ISB" *)

type value = 
| Bitvector of list bool  * bool * integer 
(* In Bitvector bs b n:
   - the bs are the bits (true represents 1 and false represents 0)
   - the b specifies whether the indicies are increasing (true) or decreasing (false) along the list (for Power the Bitvector values are always increasing)    
   - the n is the index of the head of the list
*)
(*To discuss:  ARM8 uses at least one abstract record form for 
  some special registers, with no clear mapping to bits. Should
  we permit Record of (string * Bitvector) values as well?
*)
| Bytevector of list word8 (* For memory accesses *)
| Unknown
(*To add: an abstract value representing an unknown but named memory address?*)

type slice = (integer * integer)


type reg_name = 
| Reg of string 
(*Name of the register, accessing the entire register*)

| Reg_slice of string * slice 
(* Name of the register, accessing from the bit indexed by the first
to the bit indexed by the second integer of the slice, inclusive. For
Power the first will be a smaller number than or equal to the second;
for other architectures it might be the other way round.  *)

| Reg_field of string * string * slice 
(*Name of the register and name of the field of the register
accessed. The slice specifies where this field is in the register*)

| Reg_f_slice of string * string * slice * slice 
(* The first three components are as in Reg_field; the final slice
specifies a part of the field, indexed w.r.t. the register as a whole *)

let reg_nameEqual r1 r2 = 
  match (r1,r2) with
  | (Reg s1, Reg s2) -> s1=s2
  | (Reg_slice s1 sl1, Reg_slice s2 sl2) -> s1=s2 && sl1=sl2
  | (Reg_field s1 f1 sl1, Reg_field s2 f2 sl2) -> s1=s2 && f1=f2 && sl1=sl2
  | (Reg_f_slice s1 f1 sl1 sl1', Reg_f_slice s2 f2 sl2 sl2') -> s1=s2 && f1=f2 && sl1=sl2 && sl1'=sl2'
  | _ -> false
  end

instance  (Eq reg_name)
  let (=) = reg_nameEqual
  let (<>) x y = not (reg_nameEqual x y)
end



type outcome =
(* Request to read memory, value is location to read followed by registers that location depended on when mode.track_values,
   integer is size to read, followed by registers that were used in computing that size *)
| Read_mem of read_kind * value * integer * maybe (list reg_name) *  (value -> instruction_state)
(* Request to write memory, first value and dependent registers is location, second is the value to write *)
| Write_mem of write_kind * value * integer * maybe (list reg_name) * value * maybe (list reg_name) * (bool -> instruction_state)
(* Request a memory barrier *)
| Barrier of barrier_kind * instruction_state
(* Request to read register, will track dependency when mode.track_values *)
| Read_reg of reg_name * (value -> instruction_state) 
(* Request to write register *)
| Write_reg of reg_name * value * instruction_state
(* List of instruciton states to be run in parrallel, any order permitted *)
| Nondet_choice of list instruction_state * instruction_state
(* Stop for incremental stepping, function can be used to display function call data *)
| Internal of maybe string * maybe (unit -> string) * instruction_state
(* Escape the current instruction, for traps, some sys calls, interrupts, etc. Can optionally provide a handler *)
| Escape of maybe instruction_state
| Done
| Error of string

type event = 
| E_read_mem of read_kind * value * integer * maybe (list reg_name)
| E_write_mem of write_kind * value * integer * maybe (list reg_name) * value * maybe (list reg_name)
| E_barrier of barrier_kind
| E_read_reg of reg_name
| E_write_reg of reg_name * value
| E_error of string (* Should not happen, but may if the symbolic evaluation doesn't work out*)
(*should there be a representation for escape down here?*)
(*To discuss: Should multiple memory accesses be represented with a special form to denote this or potentially merged into one read or left in place*)

(* Functions to build up the initial state for interpretation *)
val build_context : Interp_ast.defs Interp.tannot -> context (*defs should come from a .lem file generated by Sail*)
val initial_instruction_state : context -> string -> list value -> instruction_state 
  (* string is a function name, list of value are the parameters to that function *)

(*Type representint the constructor parameters in instruction, other is a type not representable externally*)
type instr_parm_typ = 
  | Bit (*A single bit, represented as a one element Bitvector as a value*)
  | Other (*An unrepresentable type, will be represented as Unknown in instruciton form *)
  | Bvector of maybe integer (* A bitvector type, with length when statically known *)

(*A representation of the AST node for each instruction in the spec, with concrete values from this call, and the potential static effects from the funcl clause for this instruction 
Follows the form of the instruction in instruction_extractor, but populates the parameters with actual values
*)
type instruction = (string * list (string * instr_parm_typ * value) * list base_effect)

type v_kind = Bitv | Bytev

type decode_error = 
  | Unsupported_instruction_error of instruction
  | Not_an_instruction_error of value
  | Internal_error of string

type i_state_or_error =
  | Instr of instruction * instruction_state
  | Decode_error of decode_error

val num_to_bits : nat -> v_kind -> integer

(** proposed: *)
val nat_to_bytevector : nat -> list word8 

(*Function to decode an instruction and build the state to run it*)
val decode_to_istate : context -> value -> i_state_or_error

(*Function to generate the state to run from an instruction form; is always an Instr*)
val instruction_to_istate : context -> instruction -> i_state_or_error

(* Augment an address by the given value *)
val add_to_address : value -> nat -> value

(* Coerce a Bitvector value (presumed a multiple of 8 bits long) to a Bytevector value *)
val coerce_Bytevector_of_Bitvector : value -> value

(* Coerce a Bytevector value to a Bitvector value, increasing and starting at zero *)
val coerce_Bitvector_of_Bytevector : value -> value

(* Slice a value into a smaller vector, starting at first number (wrt the indices of the bitvector value, not raw positions in its list of bits) and going to second (inclusive) according to order. 
   For bytevectors, assumes you are slicing at the byte level, not the bit level *)
val slice_value : value -> nat -> nat -> value

(*append two vectors (bit x byte -> bit) *)
val append_value : value -> value -> value 

(* Big step of the interpreter, to the next request for an external action *)
(* When interp_mode has eager_eval false, interpreter is (close to) small step *)
val interp : interp_mode -> instruction_state -> outcome

(* Run the interpreter without external interaction, feeding in Unknown on all reads except for those register values provided *)
val interp_exhaustive : maybe (list (reg_name * value)) -> instruction_state -> list event

(* As above, but will request register reads: outcome will only be rreg, done, or error *)
val rr_interp_exhaustive : interp_mode -> instruction_state -> list event -> (outcome * (list event)) 


(*To discuss: Are these functions needed, since the memory requests carry the register dependencies for that request? *)
val mem_read_analysis : instruction_state -> list event (*Should record all rreg events where the registers are involved in memory reads to compute the addressses in is*)

val mem_write_analysis : instruction_state -> list event (*Should record all rreg events where the registers are involved in memory writes to compute the address (and value?, in a separate list?)*)


