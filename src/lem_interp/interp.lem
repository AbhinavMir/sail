open import Pervasives
import Map
import Map_extra
import Maybe
import List_extra
import String

open import Interp_ast

type tannot = maybe (t * tag * list nec * effect)

(* Workaround Lem's inability to scrap my (type classes) boilerplate.
 * Implementing only Eq, and only for literals - hopefully this will
 * be enough, but we should in principle implement ordering for everything in
 * Interp_ast *)

val lit_eq: lit -> lit -> bool
let lit_eq (L_aux left _) (L_aux right _) =
   match (left, right) with
   | (L_unit, L_unit) -> true
   | (L_zero, L_zero) -> true
   | (L_one, L_one) -> true
   | (L_true, L_true) -> true
   | (L_false, L_false) -> true
   | (L_num n, L_num m) -> n = m
   | (L_hex h, L_hex h') -> h = h'
   | (L_bin b, L_bin b') -> b = b'
   | (L_undef, L_undef) -> true
   | (L_string s, L_string s') -> s = s'
   | (_, _) -> false
end

instance (Eq lit)
  let (=) = lit_eq
  let (<>) n1 n2 = not (lit_eq n1 n2)
end

(* type nat = num *)

(* This is different from OCaml: it will drop elements from the longest list. *)
let foldr2 f x l l' = List.foldr (Tuple.uncurry f) x (List.zip l l')
let map2 f l l' = List.map (Tuple.uncurry f) (List.zip l l')

let get_id id = match id with (Id_aux (Id s) _) -> s | (Id_aux (DeIid s) _ ) -> s end

type value =
 | V_boxref of nat 
 | V_lit of lit
 | V_tuple of list value
 | V_list of list value
 | V_vector of natural * bool * list value (* The nat stores the first index, the bool whether that's most or least significant *)
 | V_record of list (id * value)
 | V_ctor of id * value

 (* seems useless currently:
let rec id_value_eq (i, v) (i', v') = i = i' && value_eq v v'
and value_eq left right =
  match (left, right) with
  | (V_lit l, V_lit l') -> lit_eq l l'
  | (V_boxref n, V_boxref m) -> n = m
  | (V_tuple l, V_tuple l') -> listEqualBy value_eq l l'
  | (V_list l, V_list l') -> listEqualBy value_eq l l'
  | (V_vector n b l, V_vector m b' l') ->
      n = m && b = b' && listEqualBy value_eq l l'
  | (V_record l, V_record l') ->
      listEqualBy id_value_eq l l'
  | (V_ctor i v, V_ctor i' v') -> id_value_eq (i, v) (i', v')
  | (_, _) -> false
  end

instance (Eq value)
  let (=) = lit_value
  let (<>) n1 n2 = not (lit_value n1 n2)
end
*)

type mem = Mem of nat * map nat value
type env = list (id * value)

let emem = Mem 1 Map.empty

type reg_form =
 | Reg of id * typ
 | SubReg of id * reg_form * index_range

(* These may need to be refined or expanded based on memory requirement *)
type action = 
 | Read_reg of reg_form * maybe (natural * natural)
 | Write_reg of reg_form * maybe (natural* natural) * value
 | Read_mem of id * value * maybe (natural * natural)
 | Write_mem of id * value * maybe (natural * natural) * value
 | Call_extern of string * value

(* Inverted call stack, where top item on the stack is waiting for an action and all other frames for the right stack *)
type stack = 
 | Top
 | Frame of id * exp tannot * env * mem * stack

(* Either a case must be added for parallel options or action must be tied to a list *)
type outcome =
 | Value of value
 | Action of action * stack
 | Error of string (* When we store location information, it should be added here *)

(* interprets the exp sequentially in the presence of a set of top level definitions and returns a value or a memory request *)
val interp : defs tannot -> exp tannot -> outcome

val to_registers : defs tannot -> list (id * reg_form)
let rec to_registers (Defs defs) =
  match defs with
  | [ ] -> [ ]
  | (DEF_aux def _)::defs -> 
    match def with 
    | DEF_spec valsp -> 
      match valsp with
      | (VS_aux (VS_val_spec (TypSchm_aux (TypSchm_ts tq ((Typ_aux (Typ_app (Id_aux (Id "reg") _) _) _) as t)) _) id) _) -> 
	(id, Reg id t):: (to_registers (Defs defs))
      | _ -> to_registers (Defs defs)
      end
    | DEF_reg_dec typ id -> (id, Reg id typ) :: (to_registers (Defs defs))
    | DEF_type tdef ->
      match tdef with 
      | (TD_aux (TD_register id n1 n2 ranges) _) -> 
	(id,Reg id (Typ_aux (Typ_app (Id_aux (Id "vector") Unknown) []) Unknown))::
	((to_reg_ranges id (Reg id (Typ_aux (Typ_app (Id_aux (Id "vector") Unknown) []) Unknown)) ranges) ++ (to_registers (Defs defs)))
      | _ -> to_registers (Defs defs)
      end
    | _ -> to_registers (Defs defs)
    end 
  end
and to_reg_ranges base_id base_reg ranges =
  match ranges with
  | [ ] -> [ ]
  | (irange,id)::ranges -> (id,(SubReg base_id base_reg irange))::(to_reg_ranges base_id base_reg ranges)
  end

val has_memory_effect : list base_effect -> bool
let rec has_memory_effect efcts =
  match efcts with
  | [] -> false
  | (BE_aux e _)::efcts ->
    match e with
    | BE_wreg -> true
    | BE_wmem -> true
    | _ -> has_memory_effect efcts
    end 
  end

let get_typ (TypSchm_aux (TypSchm_ts tq t) _) = t
let get_effects (Typ_aux t _) =
  match t with
    | Typ_fn a r (Effect_aux (Effect_set eff) _) -> eff
    | _ -> []
  end

(*Look for externs as well*)
val to_memory_ops : defs tannot -> list (id * typ)
let rec to_memory_ops (Defs defs) =
  match defs with
  | [] -> []
  | (DEF_aux def _) ::defs ->
    match def with
    | DEF_spec (VS_aux valsp _) ->
      match valsp with
      | VS_val_spec ts id ->
	let t = get_typ ts in
	let eff = get_effects t in
        if has_memory_effect eff then (id,t)::(to_memory_ops (Defs defs)) else (to_memory_ops (Defs defs))
      | VS_extern_spec ts id _ ->
	let t = get_typ ts in
	let eff = get_effects t in
        if has_memory_effect eff then (id,t)::(to_memory_ops (Defs defs)) else (to_memory_ops (Defs defs))
      | VS_extern_no_rename ts id ->
	let t = get_typ ts in
	let eff = get_effects t in
        if has_memory_effect eff then (id,t)::(to_memory_ops (Defs defs)) else (to_memory_ops (Defs defs))
      | _ -> to_memory_ops (Defs defs) end
    | _ -> to_memory_ops (Defs defs) end
  end

val to_externs : defs tannot -> list (id * string)
let rec to_externs (Defs defs) =
  match defs with
  | [] -> []
  | (DEF_aux def _) ::defs ->
    match def with
    | DEF_spec (VS_aux valsp _) ->
      match valsp with
      | VS_extern_spec (TypSchm_aux (TypSchm_ts tq (Typ_aux (Typ_fn a r e) _)) _) id s ->
        (id,s)::(to_externs (Defs defs))
      | _ -> to_externs (Defs defs) end
    | _ -> to_externs (Defs defs) end
  end

val to_data_constructors : defs tannot -> list (id * typ)
let rec to_data_constructors (Defs defs) =
  match defs with
  | [] -> []
  | (DEF_aux def _) :: defs ->
    match def with
    | DEF_type (TD_aux t _)->
      match t with 
      | TD_variant id _ tq tid_list _ ->
        (List.map 
	   (fun (Tu_aux t _) ->
	     match t with
	    | (Tu_ty_id x y) -> (y,x)
	    | Tu_id x -> (id,Typ_aux(Typ_app (Id_aux (Id "unit") Unknown) []) Unknown) end) tid_list)++(to_data_constructors (Defs defs))
      | _ -> to_data_constructors (Defs defs) end
    | _ -> to_data_constructors (Defs defs) end
   end

val in_env : env -> id -> maybe value
let rec in_env env id =
 match env with
 | [] -> Nothing
 | (eid,value)::env -> if (get_id eid) = (get_id id) then Just value else in_env env id
 end 

val in_mem : mem -> nat -> value
let in_mem (Mem _ m) n = 
  Map_extra.find n m
  (* Map.lookup n m *)

val update_mem : mem -> nat -> value -> mem
let update_mem (Mem c m) loc value =
  let m' = Map.delete loc m in
  let m' = Map.insert loc value m' in
  Mem c m'

val is_lit_vector : lit -> bool
let is_lit_vector (L_aux l _) = 
  match l with
  | L_bin _ -> true 
  | L_hex _ -> true
  | _ -> false
end

val litV_to_vec : lit -> value
let litV_to_vec (L_aux lit l) =
  match lit with
  | L_hex s ->
    let hexes = String.toCharList s in
    (* XXX unimplemented *)
    V_vector 0 true []
  | L_bin s -> 
    let bits = String.toCharList s in
    let exploded_bits = List.map (fun c -> String.toString [c]) bits in
    let bits = List.map (fun s -> match s with | "0" -> (V_lit (L_aux L_zero l)) | "1" -> (V_lit (L_aux L_one l)) end) exploded_bits in
    (* XXX assume binary constants are written in big-endian, convert them to
     * little-endian by default - we might need syntax to change both of those
     * assumptions. *)
    V_vector 0 true (List.reverse bits)
  end

(* Like List_extra.nth with a natural instead of nat index -
 * using an unsafe coercion. *)
val list_nth : forall 'a . list 'a -> natural -> 'a
let list_nth l n = List_extra.nth l (natFromNatural n)

val list_length : forall 'a . list 'a -> natural
let list_length l = naturalFromNat (List.length l)

val access_vector : value -> natural -> value
let access_vector v n =
  match v with
  | V_vector m inc vs -> 
    if inc then
    list_nth vs (n - m)
    else list_nth vs (m - n)
  end

val from_n_to_n :forall 'a. natural -> natural -> natural -> list 'a -> list 'a
let rec from_n_to_n from to_ acc ls =
  match ls with
  | [] -> []
  | l::ls -> 
    if (acc <= from)
    then if (from = to_)
      then [ l ]
      else l::(from_n_to_n (from + 1) to_ acc ls)
    else from_n_to_n from to_ (acc + 1) ls
  end

val slice_vector : value -> natural -> natural -> value
let slice_vector v n1 n2 =
  match v with
  | V_vector m inc vs ->
    if inc 
    then V_vector n1 inc (from_n_to_n (n1 - m) (n2 - m) 0 vs)
    else V_vector n1 inc (from_n_to_n (m - n1) (m - n2) 0 vs)
  end

val update_field_list : list (id * value) -> list (id * value) -> list (id * value)
let rec update_field_list base updates =
  match base with
  | [] -> []
  | (id,v)::bs -> match in_env updates id with
    | Just v -> (id,v)::(update_field_list bs updates)
    | Nothing -> (id,v)::(update_field_list bs updates) end
end

val fupdate_record : value -> value -> value
let fupdate_record base updates = 
  match (base,updates) with
  | (V_record bs,V_record us) -> V_record (update_field_list bs us) end

val update_vector_slice : value -> value -> mem -> mem
let rec update_vector_slice vector value mem = 
  match (vector,value) with
  | ((V_vector m inc vs),(V_vector n inc2 vals)) ->
    foldr2 (fun vbox v mem -> match vbox with
                                       | V_boxref n -> update_mem mem n v end)
      mem vs vals
  | ((V_vector m inc vs),v) ->
    List.foldr (fun vbox mem -> match vbox with
                                    | V_boxref n -> update_mem mem n v end)
      mem vs
end

val fupdate_vec : value -> natural -> value -> value
let fupdate_vec v n vexp =
  match v with
  | V_vector m inc vals -> 
    V_vector m inc (List.update vals (natFromNatural (if inc then (n-m) else (m-n))) vexp)
  end

val replace_is : forall 'a. list 'a -> list 'a -> natural -> natural -> natural -> list 'a
let rec replace_is ls vs base start stop =
  match (ls,vs) with
  | ([],_) -> []
  | (ls,[]) -> ls
  | (l::ls,v::vs) -> 
    if base >= start then
      if start >= stop then ls
      else v::(replace_is ls vs (base + 1) (start + 1) stop)
    else l::(replace_is ls (v::vs) (base+1) start stop)
  end

val fupdate_vector_slice : value -> value -> natural -> natural -> value
let fupdate_vector_slice vec replace start stop =
  match (vec,replace) with
  | (V_vector m inc vals,V_vector _ inc' reps) ->
    V_vector m inc (replace_is vals (if inc=inc' then reps else (List.reverse reps)) 0 (if inc then (start-m) else (m-start)) (if inc then (stop-m) else (m-stop)))
  end

val in_reg : list (id * reg_form) -> id -> maybe reg_form
let rec in_reg regs id =
  match regs with
  | [] -> Nothing
  | (eid,regf)::regs -> if (get_id eid) = (get_id id) then Just regf else in_reg regs id
end
val in_ctors : list (id * typ) -> id -> maybe typ
let rec in_ctors ctors id =
  match ctors with
  | [] -> Nothing
  | (cid,typ)::ctors -> if (get_id cid) = (get_id id) then Just typ else in_ctors ctors id
end

let add_to_top_frame e_builder stack =
  match stack with
  | Frame id e env mem stack -> Frame id (e_builder e) env mem stack
  end

let rec to_exp v =
  E_aux
    (match v with
      | V_boxref n -> E_id (Id_aux (Id ("XXX string_of_num n")) Unknown)
      | V_lit lit -> E_lit lit
      | V_tuple(vals) -> E_tuple (List.map to_exp vals)
      | V_vector n inc vals -> 
	if (inc && n=0) 
	then E_vector (List.map to_exp vals) 
	else if inc then
          E_vector_indexed (List.reverse (snd (List.foldl (fun (n,acc) e -> (n+1,(n, to_exp e)::acc)) (n,[]) vals)))
	else 
          E_vector_indexed (snd (List.foldr (fun e (n,acc) -> (n+1,(n, to_exp e)::acc)) (n-(list_length vals),[]) vals))
      | V_record(ivals) -> 
	E_record(FES_aux (FES_Fexps
			    (List.map (fun (id,value) -> (FE_aux (FE_Fexp id (to_exp value)) (Unknown,Nothing))) ivals) false) 
		   (Unknown,Nothing))
      | V_list(vals) -> E_list (List.map to_exp vals)
      | V_ctor id vals -> E_app id [to_exp vals]
     end)
    (Unknown,Nothing)

val find_type_def : defs tannot -> id -> maybe (type_def tannot)
val find_function : defs tannot -> id -> maybe (list (funcl tannot))

let get_funcls id (FD_aux (FD_function _ _ _ fcls) _) =
  List.filter (fun (FCL_aux (FCL_Funcl name pat exp) _) -> (get_id id) = (get_id name)) fcls

let rec find_function (Defs defs) id =
  match defs with 
  | [] -> Nothing
  | (DEF_aux def _)::defs -> 
    match def with
    | DEF_fundef f -> match get_funcls id f with
      | [] -> find_function (Defs defs) id
      | funcs -> Just funcs end
    | _ -> find_function (Defs defs) id
    end end

val find_memory : list ( id * typ ) -> id -> maybe typ
let find_memory mems id = List.lookup id mems

val find_extern : list ( id * string ) -> id -> maybe string
let find_extern externs id = List.lookup id externs

val match_pattern : pat tannot -> value -> bool * list (id * value)
let rec match_pattern (P_aux p _) value =
  match p with 
  | P_lit(lit) -> 
    if is_lit_vector lit then
      let (V_vector n inc bits) = litV_to_vec lit in
      match value with
      | V_lit litv -> 
        if is_lit_vector litv then 
          let (V_vector n' inc' bits') = litV_to_vec litv in
          if n=n' && inc = inc' then (foldr2 (fun l r rest -> (l = r) && rest) true bits bits', [])
          else (false,[])
        else (false,[])
      | V_vector n' inc' bits' -> 
        if n=n' && inc = inc' then (foldr2 (fun l r rest -> (l=r) && rest) true bits bits',[])
        else (false,[])
      | _ -> (false,[]) end
    else
    match value with
    | V_lit(litv) -> (lit = litv, [])
    | _ -> (false,[])
    end
 | P_wild -> (true,[])
 | P_as pat id ->  let (matched_p,bounds) = match_pattern pat value in
		     if matched_p then
		       (matched_p,(id,value)::bounds)
		     else (false,[])
 | P_typ typ pat -> match_pattern pat value (* Might like to destructure against the type to get information *)
 | P_id id -> (true, [(id,value)])
 | P_app id pats -> 
   match value with
   | V_ctor cid (V_tuple vals) -> 
     if (id = cid && ((List.length pats) = (List.length vals)))
     then foldr2
          (fun pat value (matched_p,bounds) ->
            if matched_p then
              let (matched_p,new_bounds) = match_pattern pat value in
              (matched_p, (new_bounds ++ bounds))
            else (false,[])) (true,[]) pats vals
     else (false,[])
   | _ -> (false,[]) end
 | P_record fpats _ ->
   match value with
   | V_record fvals ->
     List.foldr
       (fun (FP_aux (FP_Fpat id pat) _) (matched_p,bounds) ->
         if matched_p then
           let (matched_p,new_bounds) = match in_env fvals id with
                                       | Nothing -> (false,[])
                                       | Just v -> match_pattern pat v end in
           (matched_p, (new_bounds ++ bounds))
         else (false,[])) (true,[]) fpats
   | _ -> (false,[])
   end           
 | P_vector pats ->
   match value with
   | V_vector n inc vals ->
     if ((List.length vals) = (List.length pats))
     then foldr2
       (fun pat value (matched_p,bounds) -> 
	 if matched_p then
	   let (matched_p,new_bounds) = match_pattern pat value in
	   (matched_p, (new_bounds ++ bounds)) 
	 else (false,[]))
       (true,[]) (if inc then pats else List.reverse pats) vals
     else (false,[])
   | _ -> (false,[])
     end
 | P_vector_indexed ipats ->
   match value with
   | V_vector n inc vals ->
     let v_len = if inc then list_length vals + n else n - list_length vals in
     List.foldr
       (fun (i,pat) (matched_p,bounds) -> if matched_p && i < v_len then
	   let (matched_p,new_bounds) = match_pattern pat (list_nth vals (if inc then i+n else i-n)) in
	   (matched_p,new_bounds++bounds)
         else (false,[]))
       (true,[]) ipats
   | _ -> (false, [])
   end 
 | P_vector_concat pats ->
   match value with
   | V_vector n inc vals ->
     let (matched_p,bounds,remaining_vals) =
       List.foldl 
         (fun (matched_p,bounds,r_vals) (P_aux pat _) ->
           match pat with
           | P_vector pats -> vec_concat_match pats r_vals
           | P_id id -> (false,[],[]) (*Need to have at least a guess of how many to consume*)
           | _ -> (false,[],[]) end) (true,[],vals) pats in
     if matched_p && ([] = remaining_vals) then (matched_p,bounds) else (false,[]) 
   | _ -> (false, []) 
   end
 | P_tup(pats) ->
   match value with 
   | V_tuple(vals) ->
     if ((List.length pats)= (List.length vals))
     then foldr2 
       (fun pat v (matched_p,bounds) -> if matched_p then
	   let (matched_p,new_bounds) = match_pattern pat v in
	   (matched_p,bounds++new_bounds)
	 else (false,[]))
       (true,[]) pats vals
     else (false,[])
   | _ -> (false,[])
     end 
 | P_list(pats) ->
   match value with 
   | V_list(vals) ->
     if ((List.length pats)= (List.length vals))
     then foldr2 
       (fun pat v (matched_p,bounds) -> if matched_p then
	   let (matched_p,new_bounds) = match_pattern pat v in
	   (matched_p,bounds++new_bounds)
	 else (false,[]))
       (true,[]) pats vals
     else (false,[])
   | _ -> (false,[]) end
 end 
and vec_concat_match pats r_vals =
    match pats with
    | [] -> (true,[],r_vals)
    | pat::pats -> match r_vals with
      | [] -> (false,[],[])
      | r::r_vals -> let (matched_p,new_bounds) = match_pattern pat r in
                     if matched_p then 
                       let (matched_p,bounds,r_vals) = vec_concat_match pats r_vals in
                       (matched_p, new_bounds++bounds,r_vals)
                     else (false,[],[]) end
    end


val find_funcl : list (funcl tannot) -> value -> maybe (env * (exp tannot))
let rec find_funcl funcls value =
  match funcls with
  | [] -> Nothing
  | (FCL_aux (FCL_Funcl id pat exp) _)::funcls ->
    let (is_matching,env) = match_pattern pat value in
    if is_matching then Just (env,exp) else find_funcl funcls value
  end

val find_case : list (pexp tannot) -> value -> maybe (env * (exp tannot))
let rec find_case pexps value =
  match pexps with
  | [] -> Nothing
  | (Pat_aux (Pat_exp p e) _)::pexps -> 
    let (is_matching,env) = match_pattern p value in
    if is_matching then Just(env,e) else find_case pexps value
  end

(*top_level is a tuple of 
  (all definitions, external functions, letbound values, declared registers, memory functions (typ expected to be num -> num -> a), and Typedef union constructors) *)
type top_level = Env of (defs tannot) * list (id * string) * env * list (id*reg_form) * list (id * typ) * list (id * typ)

val interp_main : top_level -> env -> mem -> (exp tannot) -> (outcome * mem * env)
val exp_list : top_level -> (list (exp tannot) -> (exp tannot)) -> (list value -> value) -> env -> mem -> list value -> list (exp tannot) -> (outcome * mem * env)
val interp_lbind : top_level -> env -> mem -> (letbind tannot) -> ((outcome * mem * env) * (maybe ((exp tannot) -> (letbind tannot))))

let resolve_outcome to_match value_thunk action_thunk =
  match to_match with
  | (Value v,lm,le) -> value_thunk v lm le
  | (Action action stack,lm,le) -> (action_thunk (Action action stack), lm,le)
  | (Error s,lm,le) -> (Error s,lm,le)
  end

let update_stack (Action act stack) fn = Action act (fn stack)  

(*Interpret a list of expressions, tracking local state but evaluating in the same scope (i.e. not tracking env) *)
let rec exp_list t_level build_e build_v l_env l_mem vals exps =
  match exps with
  | [ ] -> (Value (build_v vals), l_mem, l_env)
  | e::exps -> 
    resolve_outcome (interp_main t_level l_env l_mem e)
                    (fun value lm le -> exp_list t_level build_e build_v l_env lm (vals++[value]) exps)
                    (fun a -> update_stack a (add_to_top_frame (fun e -> (build_e ((List.map to_exp vals)++(e::exps))))))
  end

and interp_main t_level l_env l_mem (E_aux exp annot) =
    match exp with
    | E_lit lit -> if is_lit_vector lit then (Value (litV_to_vec lit),l_mem,l_env) else (Value (V_lit lit), l_mem,l_env)
    | E_cast typ exp -> interp_main t_level l_env l_mem exp (* Potentially introduce coercions ie vectors and numbers *)
    | E_id id -> match in_env l_env id with
                 | Just(value) -> match value with
		                  | V_boxref n ->(Value (in_mem l_mem n),l_mem,l_env)
		                  | _ -> (Value value,l_mem,l_env) end
		 | Nothing -> match t_level with
		           | (Env defs externs lets regs mems ctors) ->
                             match in_env lets id with
                             | Just(value) -> (Value value,l_mem,l_env) 
                             | Nothing -> 
			       match in_reg regs id with
			       | Just(regf) -> 
			         (Action (Read_reg regf Nothing) 
				         (Frame (Id_aux (Id "0") Unknown) 
					        (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) l_env l_mem Top), l_mem, l_env) 
			       | Nothing ->                                  
                                 let name = get_id id in
			         (Error (String.stringAppend "unbound identifier " name ),l_mem,l_env)
			        end 
                              end 
                            end
		end
    | E_if cond thn els ->
      resolve_outcome (interp_main t_level l_env l_mem cond)
                      (fun value lm le -> 
                        match value with
                        | V_lit(L_aux L_true _) -> interp_main t_level l_env lm thn
                        | V_lit(L_aux L_false _) -> interp_main t_level l_env lm els
                        | _ -> (Error "Type error, not provided boolean for if",lm,l_env) end)
                      (fun a -> update_stack a (add_to_top_frame (fun c -> (E_aux (E_if c thn els) annot))))
    | E_for id from to_ by order exp ->
      resolve_outcome (interp_main t_level l_env l_mem from)
                      (fun from_val lm le ->
                        match from_val with
                        | V_lit(L_aux(L_num from_num) _) -> 
                          resolve_outcome (interp_main t_level le lm to_)
                                          (fun to_val lm le ->
                                            match to_val with
                                            | V_lit(L_aux (L_num to_num) _) ->
                                              resolve_outcome 
                                                (interp_main t_level le lm by)
                                                (fun by_val lm le ->
                                                  match by_val with 
                                                  | V_lit (L_aux (L_num by_num) _) ->
                                                    if (from_num = to_num) 
                                                    then (Value(V_lit (L_aux L_unit Unknown)),lm,le)
                                                    else interp_main t_level le lm 
                                                      (E_aux 
							 (E_block 
							    [(E_aux (E_let 
								(LB_aux (LB_val_implicit 
									  (P_aux (P_id id) (Unknown,Nothing))
									  (E_aux (E_lit(L_aux(L_num from_num) Unknown)) (Unknown,Nothing)))
								        (Unknown,Nothing))
								exp) (Unknown,Nothing));
                                                             (E_aux (E_for id 
								       (E_aux (E_lit (L_aux (L_num (from_num + by_num)) Unknown))
									      (Unknown,Nothing))
								       (E_aux (E_lit (L_aux (L_num to_num) Unknown)) (Unknown,Nothing))
								       (E_aux (E_lit (L_aux (L_num by_num) Unknown)) (Unknown,Nothing))
								       order exp) annot)])
							 annot)
                                                  | _ -> (Error "by must be a number",lm,le) end)
                                                (fun a -> update_stack a 
						  (add_to_top_frame (fun b -> 
						    (E_aux (E_for id 
							      (E_aux (E_lit (L_aux (L_num from_num) Unknown)) (Unknown,Nothing))
							      (E_aux (E_lit (L_aux (L_num to_num) Unknown)) (Unknown,Nothing))
							      b order exp) annot))))
                                            | _ -> (Error "to must be a number",lm,le) end)
                                           (fun a -> update_stack a 
					     (add_to_top_frame (fun t -> 
					       (E_aux (E_for id (E_aux (E_lit (L_aux (L_num from_num) Unknown)) (Unknown,Nothing))
							 t by order exp) annot))))
                        | _ -> (Error "from must be a number",lm,le) end)
                       (fun a -> update_stack a (add_to_top_frame (fun f -> (E_aux (E_for id f to_ by order exp) annot))))
    | E_case exp pats ->
      resolve_outcome (interp_main t_level l_env l_mem exp)
                      (fun v lm le ->
                        match find_case pats v with
                        | Nothing -> (Error "No matching patterns in case",lm,le)
                        | Just (env,exp) -> interp_main t_level (env++l_env) lm exp end)
                      (fun a -> update_stack a (add_to_top_frame (fun e -> (E_aux (E_case e pats) annot))))
    | E_record(FES_aux (FES_Fexps fexps _) fes_annot) -> 
      let (fields,exps) = List.unzip (List.map (fun (FE_aux (FE_Fexp id exp) _) -> (id,exp)) fexps) in
      exp_list t_level 
	(fun es -> 
	  (E_aux (E_record 
		    (FES_aux (FES_Fexps (map2 (fun id exp -> (FE_aux (FE_Fexp id exp) (Unknown,Nothing))) fields es) false) fes_annot))
	          annot))
	(fun vs -> (V_record (List.zip fields vs))) l_env l_mem [] exps
    | E_record_update exp (FES_aux (FES_Fexps fexps _) fes_annot) ->
      resolve_outcome (interp_main t_level l_env l_mem exp)
                      (fun rv lm le -> 
                        match rv with
                        | V_record fvs ->
                          let (fields,exps) = List.unzip (List.map (fun (FE_aux (FE_Fexp id exp) _) -> (id,exp)) fexps) in
                          resolve_outcome (exp_list t_level 
					     (fun es -> 
					       (E_aux (E_record_update (to_exp rv) 
							 (FES_aux (FES_Fexps 
								     (map2 (fun id exp -> (FE_aux (FE_Fexp id exp) (Unknown,Nothing)))
									fields es) false) fes_annot))
						      annot))					     
                                             (fun vs -> (V_record (List.zip fields vs))) l_env l_mem [] exps)
                                          (fun vs lm le ->
                                            (Value (fupdate_record rv vs), lm, le))
                                          (fun a -> a)
                        | _ -> (Error "record upate requires record",lm,le) end)
                      (fun a -> update_stack a (add_to_top_frame 
						  (fun e -> E_aux(E_record_update e (FES_aux(FES_Fexps fexps false) fes_annot)) annot)))
    | E_list(exps) ->
      exp_list t_level (fun exps -> E_aux (E_list exps) annot) V_list l_env l_mem [] exps
    | E_cons hd tl ->
      resolve_outcome (interp_main t_level l_env l_mem hd)
                      (fun hdv lm le -> resolve_outcome
                                        (interp_main t_level l_env lm tl)
                                        (fun tlv lm le -> match tlv with 
                                                   | V_list t -> (Value(V_list (hdv::t)),lm,le)
                                                   | _ -> (Error ":: of non-list value",lm,le) end)
                                        (fun a -> update_stack a (add_to_top_frame (fun t ->E_aux (E_cons (to_exp hdv) t) annot))))
                      (fun a -> update_stack a (add_to_top_frame (fun h -> E_aux (E_cons h tl) annot)))
    | E_field exp id -> 
      resolve_outcome (interp_main t_level l_env l_mem exp)
                      (fun value lm le -> 
                        match value with 
                        | V_record fexps -> match in_env fexps id with
                                            | Just v -> (Value v,lm,l_env)
                                            | Nothing -> (Error "Field not found in record",lm,le) end
                        | _ -> (Error "Field access requires a record",lm,le)
                        end )
                      (fun a -> update_stack a (add_to_top_frame (fun e -> E_aux(E_field e id) annot)))
    | E_vector_access vec i ->
      resolve_outcome (interp_main t_level l_env l_mem i)
                      (fun iv lm le -> 
                        match iv with
                        | V_lit (L_aux (L_num n) ln) -> 
                          resolve_outcome (interp_main t_level l_env lm vec)
                                          (fun vvec lm le ->
                                            match vvec with
                                            | V_vector base inc vals -> (Value (access_vector vvec n),lm,le)
                                            | _ -> (Error "Vector access of non-vector",lm,le)end)
                                          (fun a -> update_stack a 
					    (add_to_top_frame (fun v -> (E_aux (E_vector_access v (E_aux (E_lit (L_aux (L_num n) ln)) (ln,Nothing))) annot))))
                        | _ -> (Error "Vector access not given a number for index",lm,l_env) end)
                      (fun a -> update_stack a (add_to_top_frame (fun i -> E_aux (E_vector_access vec i) annot)))
    | E_vector_subrange vec i1 i2 ->
      resolve_outcome (interp_main t_level l_env l_mem i1)
                      (fun i1v lm le ->
                        match i1v with
                        | V_lit (L_aux (L_num n1) ln1) ->
                          resolve_outcome (interp_main t_level l_env lm i2)
                                          (fun i2v lm le ->
                                            match i2v with
                                            | V_lit (L_aux (L_num n2) ln2) ->
                                              resolve_outcome (interp_main t_level l_env lm vec)
                                                              (fun vvec lm le ->
                                                                match vvec with
                                                                | V_vector base inc vals -> (Value (slice_vector vvec n1 n2),lm,le)
                                                                | _ -> (Error "Vector slice of non-vector",lm,le)end)
                                                              (fun a -> update_stack a 
                                                                (add_to_top_frame 
								   (fun v -> (E_aux (E_vector_subrange v 
										       (E_aux (E_lit (L_aux (L_num n1) ln1)) (ln1,Nothing))
										       (E_aux (E_lit (L_aux (L_num n2) ln2)) (ln2,Nothing)))
										annot))))
                                            | _ -> (Error "vector slice given non number for last index",lm,le) end)
                                          (fun a -> update_stack a 
					    (add_to_top_frame 
					       (fun i2 -> (E_aux (E_vector_subrange vec 
								    (E_aux (E_lit (L_aux (L_num n1) ln1)) (ln1,Nothing))
								    i2) annot))))
                        | _ -> (Error "Vector slice given non-number for first index",lm,le) end)
                       (fun a -> update_stack a (add_to_top_frame (fun i1 -> (E_aux (E_vector_subrange vec i1 i2) annot))))
    | E_vector_update vec i exp ->
      resolve_outcome (interp_main t_level l_env l_mem i)
                      (fun vi lm le ->
                        match vi with
                        | V_lit (L_aux (L_num n1) ln1) ->
                          resolve_outcome (interp_main t_level le lm exp)
                                          (fun vup lm le ->
                                            resolve_outcome (interp_main t_level le lm vec)
                                                            (fun vec lm le ->
                                                              match vec with
                                                              | V_vector base inc vals -> (Value (fupdate_vec vec n1 vup), lm,le)
                                                              | _ -> (Error "Update of vector given non-vector",lm,le) end)
                                                            (fun a -> update_stack a 
							      (add_to_top_frame 
								 (fun v -> E_aux (E_vector_update v 
										    (E_aux (E_lit (L_aux (L_num n1) ln1)) (ln1,Nothing)) 
										    (to_exp vup)) annot))))
                                          (fun a -> update_stack a 
					    (add_to_top_frame (fun e -> E_aux (E_vector_update vec 
										 (E_aux (E_lit (L_aux (L_num n1) ln1)) (ln1,Nothing))
										 e) annot)))
                        | _ -> (Error "Update of vector requires number for access",lm,le) end)
                      (fun a -> update_stack a (add_to_top_frame (fun i -> E_aux (E_vector_update vec i exp) annot)))
    | E_vector_update_subrange vec i1 i2 exp ->
      resolve_outcome (interp_main t_level l_env l_mem i1)
                      (fun vi1 lm le ->
                        match vi1 with
                        | V_lit (L_aux (L_num n1) ln1) ->
                          resolve_outcome 
                            (interp_main t_level l_env lm i2) 
                            (fun vi2 lm le ->
                              match vi2 with
                              | V_lit (L_aux (L_num n2) ln2) ->
                                resolve_outcome (interp_main t_level l_env lm exp)
                                  (fun v_rep lm le ->
                                    (resolve_outcome 
                                       (interp_main t_level l_env lm vec)
                                       (fun vvec lm le ->
                                         match vvec with
                                         | V_vector m inc vals -> (Value (fupdate_vector_slice vvec v_rep n1 n2),lm,le)
                                         | _ -> (Error "Vector update requires vector",lm,le) end)
                                       (fun a -> update_stack a 
                                         (add_to_top_frame 
					    (fun v -> E_aux (E_vector_update_subrange v 
							       (E_aux (E_lit (L_aux (L_num n1) ln1)) (ln1,Nothing))
							       (E_aux (E_lit (L_aux (L_num n2) ln2)) (ln2,Nothing)) 
							       (to_exp v_rep)) annot)))))
                                  (fun a -> update_stack a 
                                    (add_to_top_frame 
				       (fun e -> E_aux (E_vector_update_subrange vec (to_exp vi1) (to_exp vi2) e) annot)))
                              | _ -> (Error "vector update requires number",lm,le) end)
                            (fun a -> 
			      update_stack a (add_to_top_frame (fun i2 -> E_aux (E_vector_update_subrange vec (to_exp vi1) i2 exp) annot)))
                        | _ -> (Error "vector update requires number",lm,le) end)
                      (fun a -> update_stack a (add_to_top_frame (fun i1 -> E_aux (E_vector_update_subrange vec i1 i2 exp) annot)))
    | E_tuple(exps) -> 
      exp_list t_level (fun exps -> E_aux (E_tuple exps) annot) V_tuple l_env l_mem [] exps
    | E_vector(exps) ->
      exp_list t_level (fun exps -> E_aux (E_vector exps) annot) (fun vals -> V_vector 0 true vals) l_env l_mem [] exps
    | E_vector_indexed(iexps) ->
      let (indexes,exps) = List.unzip iexps in
      exp_list t_level (fun es -> (E_aux (E_vector_indexed (map2 (fun i e -> (i,e)) indexes es)) annot)) 
                       (fun vals -> V_vector (List_extra.head indexes) true vals) (*Need to see increasing or not, can look at types later*) l_env l_mem [] exps
    | E_block(exps) -> interp_block t_level l_env l_env l_mem exps
    | E_app f args ->
      (match (exp_list t_level (fun es -> E_aux (E_app f es) annot) 
		               (fun vs -> match vs with | [] -> V_lit (L_aux L_unit Unknown) | [v] -> v | vs -> V_tuple vs end) 
			       l_env l_mem [] args) with
      | (Value v,lm,le) -> 
         (match (f,t_level) with
      	 | (id,(Env defs externs lets regs mems ctors)) -> 
	   (match find_function defs id with
	   | Just(funcls) -> 
             (match find_funcl funcls v with
	     | Nothing -> 
               let name = get_id id in
               (Error (String.stringAppend "No matching pattern for function " name ),l_mem,l_env)
	     | Just(env,exp) -> 
               resolve_outcome (interp_main t_level env l_mem exp)
	                       (fun ret lm le -> (Value ret, lm,l_env))
                               (fun a -> update_stack a 
				 (fun stack -> (Frame (Id_aux (Id "0") Unknown) 
						  (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) l_env l_mem stack)))
             end)
          | Nothing -> 
            (match in_ctors ctors id with
            | Just(typ) -> (Value (V_ctor id v), lm, le)
            | Nothing -> 
              (match find_memory mems id with
              | Just(typ) -> 
                (Action (Read_mem id v Nothing) 
		        (Frame (Id_aux (Id "0") Unknown) (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) le lm Top), lm, le)
              | Nothing -> 
                (match find_extern externs id with
                | Just(str) -> 
                  (Action (Call_extern str v) 
		          (Frame (Id_aux (Id "0") Unknown) (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) le lm Top), lm, le)
                | Nothing -> (Error (String.stringAppend "Unknown function call " (get_id id)),lm,le) end)
	       end) end) end) end)
         | out -> out end)
    | E_app_infix l op r -> 
       let op = match op with
       | Id_aux (Id x) il -> Id_aux (DeIid x) il
       | _ -> op
       end in
      resolve_outcome (interp_main t_level l_env l_mem l)
                      (fun lv lm le -> 
                         resolve_outcome (interp_main t_level l_env lm r)
                                         (fun rv lm le -> 
			                   (match t_level with
			                   | (Env defs externs lets regs mems ctors) ->
				             (match find_function defs op with
				             | Nothing -> 
                                               (match find_extern externs op with
                                               | Just(str) ->
                                                 (Action (Call_extern str (V_tuple [lv;rv])) 
						         (Frame (Id_aux (Id "0") Unknown) 
							        (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) le lm Top),lm,le)
                                               | Nothing ->
                                                   (Error (String.stringAppend "No matching function " (get_id op)),lm,l_env) end)
				             | Just (funcls) ->
				               (match find_funcl funcls (V_tuple [lv;rv]) with 
				               | Nothing -> (Error "No matching pattern for function",lm,l_env)
				               | Just(env,exp) ->
				                 resolve_outcome (interp_main t_level env emem exp)
				                 (fun ret lm le -> (Value ret,l_mem,l_env))
                                                 (fun a -> update_stack a 
						   (fun stack -> (Frame (Id_aux (Id "0") Unknown)
								        (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) l_env l_mem stack)))
				                end)
				              end)
			                    end))
                                         (fun a -> update_stack a (add_to_top_frame (fun r ->E_aux (E_app_infix (to_exp lv) op r) annot))))
                       (fun a -> update_stack a (add_to_top_frame (fun l -> (E_aux (E_app_infix l op r) annot))))
  | E_let (lbind : letbind tannot) exp -> 
    match (interp_letbind t_level l_env l_mem lbind) with
    | ((Value v,lm,le),_) -> interp_main t_level le lm exp
    | (((Action a s as o),lm,le),Just lbuild) ->  
      ((update_stack o (add_to_top_frame (fun e -> (E_aux (E_let (lbuild e) exp) annot)))),lm,le)
    | (e,_) -> e end
  | E_assign lexp exp ->
    resolve_outcome (interp_main t_level l_env l_mem exp)
                    (fun v lm le -> 
                      (match create_write_message_or_update t_level v l_env lm true lexp with
                      | (outcome,Nothing) -> outcome
                      | (outcome,Just lexp_builder) ->
                        resolve_outcome outcome
                                        (fun v lm le -> (Value v,lm,le))
                                        (fun a -> 
					  (match a with
					    | (Action (Write_reg regf range value) stack) -> 
					      (Action (Write_reg regf range value) stack)
					    | (Action (Write_mem id a range value) stack) -> 
					      (Action (Write_mem id a range value) stack)
					    | _ -> update_stack a (add_to_top_frame 
								     (fun e -> (E_aux (E_assign (lexp_builder e) (to_exp v)) annot) )) end))
		       end))
                    (fun a -> update_stack a (add_to_top_frame (fun v -> (E_aux (E_assign lexp v) annot))))
  end

 and interp_block t_level init_env local_env local_mem exps =
   match exps with
    | [ ] -> (Value (V_lit (L_aux (L_unit) Unknown)), local_mem, init_env)
    | [ exp ] -> interp_main t_level local_env local_mem exp
    | exp:: exps ->
      resolve_outcome (interp_main t_level local_env local_mem exp)
                      (fun _ lm le -> interp_block t_level init_env le lm exps)
                      (fun a -> update_stack a (add_to_top_frame (fun e -> (E_aux (E_block(e::exps)) (Unknown,Nothing)))))
    end

and create_write_message_or_update t_level value l_env l_mem is_top_level ((LEXP_aux lexp annot):lexp tannot) =
   let (Env defs externs lets regs mems ctors) = t_level in
   match lexp with
    | LEXP_id id -> 
      match in_env l_env id with
      | Just (V_boxref n) -> 
	if is_top_level 
	then ((Value (V_lit (L_aux L_unit Unknown)), update_mem l_mem n value, l_env),Nothing)
	else ((Value (in_mem l_mem n), l_mem, l_env),Just (fun e -> LEXP_aux (LEXP_id id) annot))
      | Just v -> 
	if is_top_level then ((Error "Writes must be to reg values",l_mem,l_env),Nothing) 
	else ((Value v,l_mem,l_env),Just (fun e -> LEXP_aux(LEXP_id id) annot))
      | Nothing -> 
	match in_reg regs id with
	| Just regf -> 
	  let request = (Action (Write_reg regf Nothing value) 
			        (Frame (Id_aux (Id "0") Unknown) 
				       (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) l_env l_mem Top),l_mem,l_env) in
          if is_top_level then (request,Nothing) else (request,Just (fun e -> LEXP_aux (LEXP_id id) annot))
	| Nothing -> 
	  if is_top_level 
          then begin
	    let (Mem c m) = l_mem in
	    let l_mem = (Mem (c+1) m) in
	    ((Value (V_lit (L_aux L_unit Unknown)), update_mem l_mem c value, (id,(V_boxref c))::l_env),Nothing)
          end
          else ((Error "Undefined id",l_mem,l_env),Nothing)
        end
      end 
    | LEXP_memory id exps -> 
      match (exp_list t_level (fun exps -> E_aux (E_tuple exps) (Unknown,Nothing)) 
	              (fun vs -> match vs with | [] -> V_lit (L_aux L_unit Unknown) | [v] -> v | vs -> V_tuple vs end)
		      l_env l_mem [] exps) with
      | (Value v,lm,le) ->
        let request = (Action (Write_mem id v Nothing value) 
                              (Frame (Id_aux (Id "0") Unknown) (E_aux (E_id (Id_aux (Id "0") Unknown)) annot) l_env lm Top),lm,l_env) in
        if is_top_level then (request,Nothing) 
	else (request,Just (fun e -> 
	                     (LEXP_aux (LEXP_memory id (match v with | V_tuple vs -> (List.map to_exp vs) | v -> [to_exp v]end)) annot)))
      | (Action a s,lm, le) -> ((Action a s,lm,le), Just (fun (E_aux (E_tuple es) _) -> (LEXP_aux (LEXP_memory id es) annot)))
      | e -> (e,Nothing) end
    | LEXP_vector lexp exp -> 
      match (interp_main t_level l_env l_mem exp) with
      | (Value i,lm,le) ->
        (match i with 
        | V_lit (L_aux (L_num n) ln) -> 
          let next_builder le_builder = (fun e -> 
	                                  LEXP_aux (LEXP_vector (le_builder e) (E_aux (E_lit (L_aux (L_num n) ln)) (ln,Nothing))) annot) in
          (match (create_write_message_or_update t_level value l_env lm false lexp) with
          | ((Value v,lm,le),maybe_builder) ->
            (match v with 
            | V_vector inc m vs -> 
              let nth = access_vector v n in
              (match (nth,is_top_level,maybe_builder) with
              | (V_boxref n,true,_) -> ((Value (V_lit (L_aux L_unit Unknown)), update_mem lm n value, l_env),Nothing)
              | (v,true,_) -> ((Error "Vector does not contain reg values",lm,l_env),Nothing)
              | ((V_boxref n),false, Just lexp_builder) -> ((Value (in_mem lm n),lm, l_env),Just (next_builder lexp_builder))
              | (v,false, Just lexp_builder) -> ((Value v,lm,le), Just (next_builder lexp_builder)) end)
            | _ -> ((Error "Vector access of non-vector",lm,l_env),Nothing) end)
         | ((Action a s,lm,le),Just lexp_builder) ->
           (match (a,is_top_level) with
           | ((Write_reg regf Nothing value),true) -> ((Action (Write_reg regf (Just (n,n)) value) s, lm,le), Nothing)
           | ((Write_reg regf Nothing value),false) -> 
	     ((Action (Write_reg regf (Just (n,n)) value) s,lm,le), Just  (next_builder lexp_builder))
           | ((Write_mem id a Nothing value),true) -> ((Action (Write_mem id a (Just (n,n)) value) s,lm,le), Nothing)
           | ((Write_mem id a Nothing value),false) -> 
	     ((Action (Write_mem id a (Just (n,n)) value) s,lm,le), Just (next_builder lexp_builder))
           | _ -> ((Action a s,lm,le), Just (next_builder lexp_builder)) end)
         | e -> e end)
        | _ -> ((Error "Vector access must be a number",lm,le),Nothing) end)
      | (Action a s,lm,le) -> ((Action a s,lm,le), Just (fun e -> (LEXP_aux (LEXP_vector lexp e) annot)))
      | e -> (e,Nothing) end
    | LEXP_vector_range lexp exp1 exp2  ->
      match (interp_main t_level l_env l_mem exp1) with
      | (Value i1, lm, le) ->
        (match i1 with
        | V_lit (L_aux (L_num n1) ln1) ->
          (match (interp_main t_level l_env l_mem exp2) with
          | (Value i2,lm,le) ->
            (match i2 with
            | V_lit (L_aux (L_num n2) ln2) ->
              let next_builder le_builder = 
		(fun e -> LEXP_aux (LEXP_vector_range (le_builder e) 
				                      (E_aux (E_lit (L_aux (L_num n1) ln1)) (ln1,Nothing))
						      (E_aux (E_lit (L_aux (L_num n2) ln2)) (ln2,Nothing))) annot) in
              (match (create_write_message_or_update t_level value l_env lm false lexp) with
              | ((Value v,lm,le), Just lexp_builder) ->
                (match (v,is_top_level) with
                | (V_vector m inc vs,true) -> 
                  ((Value (V_lit (L_aux L_unit Unknown)), update_vector_slice (slice_vector v n1 n2) value lm, l_env), Nothing)
                | (V_vector m inc vs,false) ->
                  ((Value (slice_vector v n1 n2),lm,l_env), Just (next_builder lexp_builder))
                | _ -> ((Error "Vector required",lm,le),Nothing) end)
              | ((Action (Write_reg regf Nothing value) s, lm,le), Just lexp_builder) ->
                ((Action (Write_reg regf (Just (n1,n2)) value) s,lm,le), Just (next_builder lexp_builder))
              | ((Action (Write_mem id a Nothing value) s,lm,le), Just lexp_builder) ->
                ((Action (Write_mem id a (Just (n1,n2)) value) s,lm,le), Just (next_builder lexp_builder))
              | ((Action a s,lm,le), Just lexp_builder) ->
                ((Action a s,lm,le), Just (next_builder lexp_builder))
              | e -> e end)
            | _ -> ((Error "Vector slice requires a number", lm, le),Nothing) end)
          | (Action a s,lm,le) ->
            ((Action a s,lm, le), Just (fun e -> LEXP_aux (LEXP_vector_range lexp 
							                     (E_aux (E_lit (L_aux (L_num  n1) ln1)) (ln1,Nothing))
									     e) annot))
          | e -> (e,Nothing) end)
        | _ -> ((Error "Vector slice requires a number", lm, le),Nothing) end)
      | (Action a s,lm,le) ->
        ((Action a s, lm,le), Just (fun e -> LEXP_aux (LEXP_vector_range lexp e exp2) annot))
      | e -> (e,Nothing) end
   | LEXP_field lexp id ->
     (match (create_write_message_or_update t_level value l_env l_mem false lexp) with
     | ((Value (V_record fexps),lm,le),Just lexp_builder) ->
       match (in_env fexps id,is_top_level) with
       | (Just (V_boxref n),true) -> ((Value (V_lit (L_aux L_unit Unknown)), update_mem lm n value, l_env),Nothing)
       | (Just (V_boxref n),false) -> 
	 ((Value (in_mem lm n),lm,l_env),Just (fun e -> LEXP_aux (LEXP_field (lexp_builder e) id) annot))
       | (Just v, true) -> ((Error "Field access requires record",lm,le),Nothing)
       | (Just v,false) -> ((Value v,lm,l_env),Just (fun e -> LEXP_aux (LEXP_field (lexp_builder e) id) annot))
       | (Nothing,_) -> ((Error "Field not found in specified record",lm,le),Nothing) end
     | ((Action a s,lm,le), Just lexp_builder) ->  
       match a with
       | Read_reg _ _ -> ((Action a s,lm,le), Just (fun e -> LEXP_aux (LEXP_field (lexp_builder e) id) annot))
       | Read_mem _ _ _ -> ((Action a s,lm,le), Just (fun e -> LEXP_aux (LEXP_field (lexp_builder e) id) annot))
       | Call_extern _ _ -> ((Action a s,lm,le), Just (fun e -> LEXP_aux (LEXP_field (lexp_builder e) id) annot))
       | _ -> ((Error "Unimplemented feature, writing to a field in a register or memory",lm,le),Nothing)
       end 
     | e -> e end)
     end	

and interp_letbind t_level l_env l_mem (LB_aux lbind annot) =
  match lbind with
  | LB_val_explicit t pat exp ->
    match (interp_main t_level l_env l_mem exp) with
    | (Value v,lm,le) ->
      (match match_pattern pat v with
      | (true,env) -> ((Value (V_lit (L_aux L_unit Unknown)), lm, env++l_env),Nothing)
      | _ -> ((Error "Pattern in letbind did not match value",lm,le),Nothing) end)
    | (Action a s,lm,le) -> ((Action a s,lm,le),(Just (fun e -> (LB_aux (LB_val_explicit t pat e) annot))))
    | e -> (e,Nothing) end
  | LB_val_implicit pat exp ->
    match (interp_main t_level l_env l_mem exp) with
    | (Value v,lm,le) ->
      (match match_pattern pat v with
      | (true,env) -> ((Value (V_lit (L_aux L_unit Unknown)), lm, env++l_env),Nothing)
      | _ -> ((Error "Pattern in letbind did not match value",lm,le),Nothing) end)
    | (Action a s,lm,le) -> ((Action a s,lm,le),(Just (fun e -> (LB_aux (LB_val_implicit pat e) annot))))
    | e -> (e,Nothing) end
end	

let rec to_global_letbinds (Defs defs) t_level =
  let  (Env defs' externs lets regs mems ctors) = t_level in
  match defs with
  | [] -> ((Value (V_lit (L_aux L_unit Unknown)), emem, []),t_level)
  | (DEF_aux def _)::defs ->
    match def with
    | DEF_val lbind ->
      match interp_letbind t_level [] emem lbind with
      | ((Value v,lm,le),_) -> to_global_letbinds (Defs defs) (Env defs' externs (lets++le) regs mems ctors)
      | ((Action a s,lm,le),_) -> ((Error "Top level let may not access memory, registers or (for now) external functions", lm,le),t_level)
      | (e,_) -> (e,t_level) end
    | _ -> to_global_letbinds (Defs defs) t_level
    end
  end


let interp defs exp =
  let t_level = Env defs (to_externs defs) [] (to_registers defs) (to_memory_ops defs) (to_data_constructors defs) in 
  let (o,t_level) = to_global_letbinds defs t_level in
  match o with
  | (Value _,_,_) -> 
     match interp_main t_level [] emem exp with
     | (o,_,_) -> o
     end 
  | (o,_,_) -> o 
  end

let rec resume_main t_level stack value =
  match stack with
  | Top -> Error "Top hit without place to put value"
  | Frame id exp env mem Top -> 
    match interp_main t_level ((id,value)::env) mem exp with | (o,_,_) -> o end 
  | Frame id exp env mem stack ->
    match resume_main t_level stack value with
    | Value v -> 
      match interp_main t_level ((id,v)::env) mem exp with | (o,_,_) -> o end 
    | Action action stack -> Action action (Frame id exp env mem stack)
    | Error s -> Error s
    end  
  end

let resume defs stack value =
  let t_level = Env defs (to_externs defs) [] (to_registers defs) (to_memory_ops defs) (to_data_constructors defs) in 
  let (o,t_level) = to_global_letbinds defs t_level in
  match o with
  | (Value _,_,_) -> 
     resume_main t_level stack value
  | (o,_,_) -> o 
  end
